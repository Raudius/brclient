import require$$1, { TextEncoder as TextEncoder$1 } from 'util';
import stream, { Readable } from 'stream';
import require$$1$1 from 'path';
import require$$3 from 'http';
import require$$4 from 'https';
import require$$0$1 from 'url';
import require$$6 from 'fs';
import require$$4$1 from 'assert';
import zlib from 'zlib';
import { EventEmitter } from 'events';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString$1 = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction$1 = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction$1(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction$1(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction$1(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop$1 = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction$1(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************

var utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var Stream$2 = stream.Stream;
var util$2 = require$$1;

var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$2.inherits(DelayedStream$1, Stream$2);

DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream$1.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};

DelayedStream$1.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream$1.prototype.pipe = function() {
  var r = Stream$2.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream$1.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this.emit('error', new Error(message));
};

var util$1 = require$$1;
var Stream$1 = stream.Stream;
var DelayedStream = delayed_stream;

var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$1.inherits(CombinedStream$1, Stream$1);

CombinedStream$1.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream$1.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream$1.prototype.append = function(stream) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$1.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream$1.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream$1.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream$1.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream$1.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream$1.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

var mimeTypes = {};

var require$$0 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

var mimeDb = require$$0;

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

(function (exports) {

	/**
	 * Module dependencies.
	 * @private
	 */

	var db = mimeDb;
	var extname = require$$1$1.extname;

	/**
	 * Module variables.
	 * @private
	 */

	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;

	/**
	 * Module exports.
	 * @public
	 */

	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);

	// Populate the extensions/types maps
	populateMaps(exports.extensions, exports.types);

	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function charset (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = EXTRACT_TYPE_REGEXP.exec(type);
	  var mime = match && db[match[1].toLowerCase()];

	  if (mime && mime.charset) {
	    return mime.charset
	  }

	  // default text/* to utf-8
	  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
	    return 'UTF-8'
	  }

	  return false
	}

	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */

	function contentType (str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false
	  }

	  var mime = str.indexOf('/') === -1
	    ? exports.lookup(str)
	    : str;

	  if (!mime) {
	    return false
	  }

	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports.charset(mime);
	    if (charset) mime += '; charset=' + charset.toLowerCase();
	  }

	  return mime
	}

	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function extension (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = EXTRACT_TYPE_REGEXP.exec(type);

	  // get extensions
	  var exts = match && exports.extensions[match[1].toLowerCase()];

	  if (!exts || !exts.length) {
	    return false
	  }

	  return exts[0]
	}

	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */

	function lookup (path) {
	  if (!path || typeof path !== 'string') {
	    return false
	  }

	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path)
	    .toLowerCase()
	    .substr(1);

	  if (!extension) {
	    return false
	  }

	  return exports.types[extension] || false
	}

	/**
	 * Populate the extensions and types maps.
	 * @private
	 */

	function populateMaps (extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana'];

	  Object.keys(db).forEach(function forEachMimeType (type) {
	    var mime = db[type];
	    var exts = mime.extensions;

	    if (!exts || !exts.length) {
	      return
	    }

	    // mime -> extensions
	    extensions[type] = exts;

	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i];

	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source);
	        var to = preference.indexOf(mime.source);

	        if (types[extension] !== 'application/octet-stream' &&
	          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
	          // skip the remapping
	          continue
	        }
	      }

	      // set the extension -> mime
	      types[extension] = type;
	    }
	  });
	} 
} (mimeTypes));

var defer_1 = defer$1;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer$1(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}

var defer = defer_1;

// API
var async_1 = async$2;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async$2(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}

// API
var abort_1 = abort$2;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort$2(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}

var async$1 = async_1
  , abort$1 = abort_1
  ;

// API
var iterate_1 = iterate$2;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate$2(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort$1(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async$1(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async$1(callback));
  }

  return aborter;
}

// API
var state_1 = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}

var abort = abort_1
  , async = async_1
  ;

// API
var terminator_1 = terminator$2;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator$2(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}

var iterate$1    = iterate_1
  , initState$1  = state_1
  , terminator$1 = terminator_1
  ;

// Public API
var parallel_1 = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState$1(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate$1(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator$1.bind(state, callback);
}

var serialOrdered$2 = {exports: {}};

var iterate    = iterate_1
  , initState  = state_1
  , terminator = terminator_1
  ;

// Public API
serialOrdered$2.exports = serialOrdered$1;
// sorting helpers
serialOrdered$2.exports.ascending  = ascending;
serialOrdered$2.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered$1(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}

var serialOrderedExports = serialOrdered$2.exports;

var serialOrdered = serialOrderedExports;

// Public API
var serial_1 = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}

var asynckit$1 =
{
  parallel      : parallel_1,
  serial        : serial_1,
  serialOrdered : serialOrderedExports
};

// populates missing values
var populate$1 = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};

var CombinedStream = combined_stream;
var util = require$$1;
var path = require$$1$1;
var http$1 = require$$3;
var https$1 = require$$4;
var parseUrl$2 = require$$0$1.parse;
var fs = require$$6;
var Stream = stream.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var populate = populate$1;

// Public API
var form_data = FormData$1;

// make it a Stream
util.inherits(FormData$1, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData$1.LINE_BREAK = '\r\n';
FormData$1.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData$1.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData$1.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData$1.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity > read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData$1.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData$1.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};

FormData$1.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData$1.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData$1.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData$1.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData$1.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData$1.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData$1.LINE_BREAK;
};

FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData$1.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData$1.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData$1.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData$1.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https$1.request(options);
  } else {
    request = http$1.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData$1.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData$1.prototype.toString = function () {
  return '[object FormData]';
};

var FormData$2 = /*@__PURE__*/getDefaultExportFromCjs(form_data);

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData$2 || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = require$$0$1.URLSearchParams;

var platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$2,
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  protocols: [ 'http', 'https', 'file', 'data' ]
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin: origin
});

var platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

var parseUrl$1 = require$$0$1.parse;

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl$1(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

var getProxyForUrl_1 = getProxyForUrl;

var followRedirects$1 = {exports: {}};

var debug$1;

var debug_1 = function () {
  if (!debug$1) {
    try {
      /* eslint global-require: off */
      debug$1 = require("debug")("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug$1 !== "function") {
      debug$1 = function () { /* */ };
    }
  }
  debug$1.apply(null, arguments);
};

var url = require$$0$1;
var URL$1 = url.URL;
var http = require$$3;
var https = require$$4;
var Writable = stream.Writable;
var assert = require$$4$1;
var debug = debug_1;

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL$1());
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC72305.3.1: When making a request directly to an origin server, []
  // a client MUST send only the absolute path [] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC72316.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC72316.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC72316.4: Automatic redirection needs to done with
  // care for methods not known to be safe, []
  // RFC72316.4.23: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  /* istanbul ignore else */
  if (useNativeURL) {
    parsed = new URL$1(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  /* istanbul ignore next */
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL$1 && value instanceof URL$1;
}

// Exports
followRedirects$1.exports = wrap({ http: http, https: https });
followRedirects$1.exports.wrap = wrap;

var followRedirectsExports = followRedirects$1.exports;
var followRedirects = /*@__PURE__*/getDefaultExportFromCjs(followRedirectsExports);

const VERSION = "1.7.5";

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream.Transform{
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

const BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = new TextEncoder$1();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$1.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + utils$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$1.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

class ZlibHeaderTransformStream extends stream.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$1.isFunction(zlib.createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects;

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = getProxyForUrl_1(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
var httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream.Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await require$$1.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream.Readable.from(readBlob(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream.Readable.from(data, {objectMode: false});
      }

      data = stream.pipeline([data, new AxiosTransformStream({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4 : require$$3;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib.createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream.pipeline(streams, utils$1.noop) : streams[0];

      const offListeners = stream.finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

var isURLSameOrigin = platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

var cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

var resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  let controller = new AbortController();

  let aborted;

  const onabort = function (cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };

  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);

  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach(signal => {
        signal &&
        (signal.removeEventListener ? signal.removeEventListener('abort', onabort) : signal.unsubscribe(onabort));
      });
      signals = null;
    }
  };

  signals.forEach((signal) => signal && signal.addEventListener && signal.addEventListener('abort', onabort));

  const {signal} = controller;

  signal.unsubscribe = unsubscribe;

  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize, encode) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : (await encode(String(chunk))), chunkSize);
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {
  const iterator = readBytes(stream, chunkSize, encode);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

var fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let [composedSignal, stopTimeout] = (signal || cancelToken || timeout) ?
    composeSignals([signal, cancelToken], timeout) : [];

  let finished, request;

  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });

    finished = true;
  };

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype; 
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && onFinish();

    stopTimeout && stopTimeout();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    onFinish();

    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode;

axios.default = axios;

/* tslint:disable */
/* eslint-disable */
/**
 * Baserow API spec
 * For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).
 *
 * The version of the OpenAPI document: 1.26.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "http://localhost".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios$1 = axios) {
        var _a;
        this.basePath = basePath;
        this.axios = axios$1;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
/**
 *
 * @export
 */
const operationServerMap = {};

/* tslint:disable */
/* eslint-disable */
/**
 * Baserow API spec
 * For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).
 *
 * The version of the OpenAPI document: 1.26.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = function (object, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken()
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + accessToken;
        }
    });
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null)
        return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        var _a;
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: (axios.defaults.baseURL ? '' : (_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Baserow API spec
 * For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).
 *
 * The version of the OpenAPI document: 1.26.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const AcceptGroupInvitation400ResponseErrorEnum = {
    ErrorGroupInvitationEmailMismatch: 'ERROR_GROUP_INVITATION_EMAIL_MISMATCH'
};
const AdminAddUserToLicense400ResponseErrorEnum = {
    UserAlreadyOnLicense: 'ERROR_USER_ALREADY_ON_LICENSE',
    NoSeatsLeftInLicense: 'ERROR_NO_SEATS_LEFT_IN_LICENSE',
    CantManuallyChangeSeats: 'ERROR_CANT_MANUALLY_CHANGE_SEATS'
};
const AdminAddUserToLicense404ResponseErrorEnum = {
    LicenseDoesNotExist: 'ERROR_LICENSE_DOES_NOT_EXIST',
    UserNotFound: 'ERROR_USER_NOT_FOUND'
};
const AdminCreateUser400ResponseErrorEnum = {
    ErrorRequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    ErrorFeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE',
    UserAdminAlreadyExists: 'USER_ADMIN_ALREADY_EXISTS'
};
const AdminDeleteGroup400ResponseErrorEnum = {
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    FeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE'
};
const AdminDeleteUser400ResponseErrorEnum = {
    UserAdminCannotDeleteSelf: 'USER_ADMIN_CANNOT_DELETE_SELF',
    UserAdminUnknownUser: 'USER_ADMIN_UNKNOWN_USER',
    ErrorFeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE'
};
const AdminEditUser400ResponseErrorEnum = {
    ErrorRequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    UserAdminCannotDeactivateSelf: 'USER_ADMIN_CANNOT_DEACTIVATE_SELF',
    UserAdminUnknownUser: 'USER_ADMIN_UNKNOWN_USER',
    UserAdminAlreadyExists: 'USER_ADMIN_ALREADY_EXISTS',
    ErrorFeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE'
};
const AdminGetLicense404ResponseErrorEnum = {
    ErrorLicenseDoesNotExist: 'ERROR_LICENSE_DOES_NOT_EXIST'
};
const AdminRegisterLicense400ResponseErrorEnum = {
    InvalidLicense: 'ERROR_INVALID_LICENSE',
    UnsupportedLicense: 'ERROR_UNSUPPORTED_LICENSE',
    PremiumLicenseInstanceIdMismatch: 'ERROR_PREMIUM_LICENSE_INSTANCE_ID_MISMATCH',
    LicenseHasExpired: 'ERROR_LICENSE_HAS_EXPIRED',
    LicenseAlreadyExists: 'ERROR_LICENSE_ALREADY_EXISTS'
};
const AdminRemoveUserFromLicense400ResponseErrorEnum = {
    ErrorCantManuallyChangeSeats: 'ERROR_CANT_MANUALLY_CHANGE_SEATS'
};
/**
 * * `empty_count` - empty_count * `not_empty_count` - not_empty_count * `unique_count` - unique_count * `min` - min * `max` - max * `sum` - sum * `average` - average * `median` - median * `decile` - decile * `variance` - variance * `std_dev` - std_dev
 * @export
 * @enum {string}
 */
const AggregationRawTypeEnum = {
    EmptyCount: 'empty_count',
    NotEmptyCount: 'not_empty_count',
    UniqueCount: 'unique_count',
    Min: 'min',
    Max: 'max',
    Sum: 'sum',
    Average: 'average',
    Median: 'median',
    Decile: 'decile',
    Variance: 'variance',
    StdDev: 'std_dev'
};
/**
 * * `top` - Top * `center` - Center * `bottom` - Bottom
 * @export
 * @enum {string}
 */
const AlignmentEnum = {
    Top: 'top',
    Center: 'center',
    Bottom: 'bottom'
};
/**
 * * `invalid` - invalid * `text` - text * `char` - char * `button` - button * `link` - link * `date_interval` - date_interval * `duration` - duration * `date` - date * `boolean` - boolean * `number` - number * `single_select` - single_select * `multiple_select` - multiple_select * `single_file` - single_file * `url` - url
 * @export
 * @enum {string}
 */
const ArrayFormulaTypeEnum = {
    Invalid: 'invalid',
    Text: 'text',
    Char: 'char',
    Button: 'button',
    Link: 'link',
    DateInterval: 'date_interval',
    Duration: 'duration',
    Date: 'date',
    Boolean: 'boolean',
    Number: 'number',
    SingleSelect: 'single_select',
    MultipleSelect: 'multiple_select',
    SingleFile: 'single_file',
    Url: 'url'
};
const AsyncAuditLogExport400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    MaxJobCountExceeded: 'ERROR_MAX_JOB_COUNT_EXCEEDED'
};
const AsyncAuditLogExport404ResponseErrorEnum = {
    ErrorGroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST'
};
const AuditLogList400ResponseErrorEnum = {
    PageSizeLimit: 'ERROR_PAGE_SIZE_LIMIT',
    InvalidPage: 'ERROR_INVALID_PAGE',
    InvalidSortDirection: 'ERROR_INVALID_SORT_DIRECTION',
    InvalidSortAttribute: 'ERROR_INVALID_SORT_ATTRIBUTE'
};
const AuthProviderLoginUrl400ResponseErrorEnum = {
    ErrorSamlInvalidLoginRequest: 'ERROR_SAML_INVALID_LOGIN_REQUEST'
};
const BatchCreateDatabaseTableRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    RowIdsNotUnique: 'ERROR_ROW_IDS_NOT_UNIQUE',
    RequestBodyValidation2: 'ERROR_REQUEST_BODY_VALIDATION'
};
const BatchDeleteDatabaseTableRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CannotDeleteAlreadyDeletedItem: 'ERROR_CANNOT_DELETE_ALREADY_DELETED_ITEM',
    RowIdsNotUnique: 'ERROR_ROW_IDS_NOT_UNIQUE'
};
/**
 *
 * @export
 * @enum {string}
 */
const BlankEnum = {
    Empty: ''
};
/**
 * * `auto` - Auto * `full` - Full
 * @export
 * @enum {string}
 */
const ButtonWidthEnum = {
    Auto: 'auto',
    Full: 'full'
};
const CalendarIcalFeed400ResponseErrorEnum = {
    ErrorCalendarViewHasNoDateField: 'ERROR_CALENDAR_VIEW_HAS_NO_DATE_FIELD'
};
const ChangePassword400ResponseErrorEnum = {
    InvalidOldPassword: 'ERROR_INVALID_OLD_PASSWORD',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION'
};
const ChangePrimaryField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    UserNotInGroup2: 'ERROR_USER_NOT_IN_GROUP',
    FieldIsAlreadyPrimary: 'ERROR_FIELD_IS_ALREADY_PRIMARY',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    IncompatiblePrimaryFieldType: 'ERROR_INCOMPATIBLE_PRIMARY_FIELD_TYPE',
    TableHasNoPrimaryField: 'ERROR_TABLE_HAS_NO_PRIMARY_FIELD'
};
const ChangePrimaryField404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST'
};
/**
 * * `AND` - And * `OR` - Or
 * @export
 * @enum {string}
 */
const ConditionTypeEnum = {
    And: 'AND',
    Or: 'OR'
};
const CreateBuilderPage400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    PageNameNotUnique: 'ERROR_PAGE_NAME_NOT_UNIQUE',
    PagePathNotUnique: 'ERROR_PAGE_PATH_NOT_UNIQUE',
    PathParamNotInPath: 'ERROR_PATH_PARAM_NOT_IN_PATH',
    PathParamNotDefined: 'ERROR_PATH_PARAM_NOT_DEFINED'
};
const CreateDatabaseTable400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    InvalidInitialTableData: 'ERROR_INVALID_INITIAL_TABLE_DATA',
    InitialTableDataLimitExceeded: 'ERROR_INITIAL_TABLE_DATA_LIMIT_EXCEEDED',
    ReservedBaserowFieldName: 'ERROR_RESERVED_BASEROW_FIELD_NAME',
    InitialTableDataHasDuplicateNames: 'ERROR_INITIAL_TABLE_DATA_HAS_DUPLICATE_NAMES',
    InvalidBaserowFieldName: 'ERROR_INVALID_BASEROW_FIELD_NAME',
    MaxJobCountExceeded: 'ERROR_MAX_JOB_COUNT_EXCEEDED'
};
const CreateDatabaseTableField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    MaxFieldCountExceeded: 'ERROR_MAX_FIELD_COUNT_EXCEEDED',
    ReservedBaserowFieldName: 'ERROR_RESERVED_BASEROW_FIELD_NAME',
    FieldWithSameNameAlreadyExists: 'ERROR_FIELD_WITH_SAME_NAME_ALREADY_EXISTS',
    InvalidBaserowFieldName: 'ERROR_INVALID_BASEROW_FIELD_NAME',
    FieldSelfReference: 'ERROR_FIELD_SELF_REFERENCE',
    FieldCircularReference: 'ERROR_FIELD_CIRCULAR_REFERENCE'
};
const CreateDatabaseTableRow400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    RequestBodyValidation2: 'ERROR_REQUEST_BODY_VALIDATION'
};
const CreateDatabaseTableRow404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    RowDoesNotExist: 'ERROR_ROW_DOES_NOT_EXIST'
};
const CreateDatabaseTableViewFilter400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    ViewFilterNotSupported: 'ERROR_VIEW_FILTER_NOT_SUPPORTED',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD'
};
const CreateDatabaseTableViewFilter404ResponseErrorEnum = {
    DoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST',
    FilterGroupDoesNotExist: 'ERROR_VIEW_FILTER_GROUP_DOES_NOT_EXIST'
};
const CreateDatabaseTableViewGroup400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    ViewGroupByNotSupported: 'ERROR_VIEW_GROUP_BY_NOT_SUPPORTED',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    ViewGroupByFieldAlreadyExists: 'ERROR_VIEW_GROUP_BY_FIELD_ALREADY_EXISTS',
    ViewGroupByFieldNotSupported: 'ERROR_VIEW_GROUP_BY_FIELD_NOT_SUPPORTED'
};
const CreateDatabaseTableViewSort400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    ViewSortNotSupported: 'ERROR_VIEW_SORT_NOT_SUPPORTED',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    ViewSortFieldAlreadyExists: 'ERROR_VIEW_SORT_FIELD_ALREADY_EXISTS',
    ViewSortFieldNotSupported: 'ERROR_VIEW_SORT_FIELD_NOT_SUPPORTED'
};
const CreateDatabaseTableWebhook400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TableWebhookMaxLimitExceeded: 'ERROR_TABLE_WEBHOOK_MAX_LIMIT_EXCEEDED'
};
const CreateRowComment400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    InvalidCommentMention: 'ERROR_INVALID_COMMENT_MENTION'
};
const CreateSnapshot400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    MaximumSnapshotsReached: 'ERROR_MAXIMUM_SNAPSHOTS_REACHED',
    ApplicationOperationNotSupported: 'ERROR_APPLICATION_OPERATION_NOT_SUPPORTED',
    SnapshotIsBeingCreated: 'ERROR_SNAPSHOT_IS_BEING_CREATED',
    SnapshotNameNotUnique: 'ERROR_SNAPSHOT_NAME_NOT_UNIQUE',
    SnapshotOperationLimitExceeded: 'ERROR_SNAPSHOT_OPERATION_LIMIT_EXCEEDED'
};
const CreateSubject400ResponseErrorEnum = {
    NotInGroup: 'ERROR_SUBJECT_NOT_IN_GROUP',
    TypeUnsupported: 'ERROR_SUBJECT_TYPE_UNSUPPORTED',
    BadRequest: 'ERROR_SUBJECT_BAD_REQUEST'
};
const CreateSubject404ResponseErrorEnum = {
    TeamDoesNotExist: 'ERROR_TEAM_DOES_NOT_EXIST',
    SubjectDoesNotExist: 'ERROR_SUBJECT_DOES_NOT_EXIST'
};
const CreateUser400ResponseErrorEnum = {
    ErrorAlreadyExists: 'ERROR_ALREADY_EXISTS',
    ErrorGroupInvitationDoesNotExist: 'ERROR_GROUP_INVITATION_DOES_NOT_EXIST',
    ErrorRequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    BadTokenSignature: 'BAD_TOKEN_SIGNATURE'
};
const CreateWorkspaceInvitation400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    UserInvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    MaxNumberOfPendingWorkspaceInvitesReached: 'ERROR_MAX_NUMBER_OF_PENDING_WORKSPACE_INVITES_REACHED'
};
/**
 * * `,` - , * `;` - ; * `|` - | * `tab` -   * `record_separator` -  * `unit_separator` - 
 * @export
 * @enum {string}
 */
const CsvColumnSeparatorEnum = {
    Comma: ',',
    Semicolon: ';',
    Pipe: '|',
    Tab: 'tab',
    RecordSeparator: 'record_separator',
    UnitSeparator: 'unit_separator'
};
const DatabaseTablePublicViewLinkRowFieldLookup401ResponseErrorEnum = {
    ErrorNoAuthorizationToPubliclySharedView: 'ERROR_NO_AUTHORIZATION_TO_PUBLICLY_SHARED_VIEW'
};
const DatabaseTablePublicViewLinkRowFieldLookup404ResponseErrorEnum = {
    ViewDoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST',
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST'
};
/**
 * * `EU` - European (D/M/Y) * `US` - US (M/D/Y) * `ISO` - ISO (Y-M-D)
 * @export
 * @enum {string}
 */
const DateFormatEnum = {
    Eu: 'EU',
    Us: 'US',
    Iso: 'ISO'
};
/**
 * * `24` - 24 hour * `12` - 12 hour
 * @export
 * @enum {string}
 */
const DateTimeFormatEnum = {
    _24: '24',
    _12: '12'
};
const DeleteApplication400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CannotDeleteAlreadyDeletedItem: 'ERROR_CANNOT_DELETE_ALREADY_DELETED_ITEM'
};
const DeleteApplicationIntegration404ResponseErrorEnum = {
    ErrorIntegrationDoesNotExist: 'ERROR_INTEGRATION_DOES_NOT_EXIST'
};
const DeleteApplicationUserSource404ResponseErrorEnum = {
    ErrorUserSourceDoesNotExist: 'ERROR_USER_SOURCE_DOES_NOT_EXIST'
};
const DeleteBuilderDomain404ResponseErrorEnum = {
    ErrorDomainDoesNotExist: 'ERROR_DOMAIN_DOES_NOT_EXIST'
};
const DeleteBuilderPageDataSource404ResponseErrorEnum = {
    ErrorDataSourceDoesNotExist: 'ERROR_DATA_SOURCE_DOES_NOT_EXIST'
};
const DeleteBuilderPageElement404ResponseErrorEnum = {
    ErrorElementDoesNotExist: 'ERROR_ELEMENT_DOES_NOT_EXIST'
};
const DeleteBuilderPageWorkflowAction404ResponseErrorEnum = {
    ErrorWorkflowActionDoesNotExist: 'ERROR_WORKFLOW_ACTION_DOES_NOT_EXIST'
};
const DeleteDatabaseTableField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CannotDeletePrimaryField: 'ERROR_CANNOT_DELETE_PRIMARY_FIELD',
    CannotDeleteAlreadyDeletedItem: 'ERROR_CANNOT_DELETE_ALREADY_DELETED_ITEM'
};
const DeleteGroup400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    UserInvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS',
    CannotDeleteAlreadyDeletedItem: 'ERROR_CANNOT_DELETE_ALREADY_DELETED_ITEM'
};
const DeleteRowComment400ResponseErrorEnum = {
    InGroup: 'ERROR_USER_NOT_IN_GROUP',
    CommentAuthor: 'ERROR_USER_NOT_COMMENT_AUTHOR'
};
const DeleteRowComment404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    RowCommentDoesNotExist: 'ERROR_ROW_COMMENT_DOES_NOT_EXIST'
};
const DeleteSnapshot400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ApplicationOperationNotSupported: 'ERROR_APPLICATION_OPERATION_NOT_SUPPORTED',
    SnapshotIsBeingRestored: 'ERROR_SNAPSHOT_IS_BEING_RESTORED',
    SnapshotIsBeingDeleted: 'ERROR_SNAPSHOT_IS_BEING_DELETED',
    SnapshotOperationLimitExceeded: 'ERROR_SNAPSHOT_OPERATION_LIMIT_EXCEEDED'
};
const DeleteSnapshot404ResponseErrorEnum = {
    ErrorSnapshotDoesNotExist: 'ERROR_SNAPSHOT_DOES_NOT_EXIST'
};
const DeleteSubject400ResponseErrorEnum = {
    ErrorCannotDeleteAlreadyDeletedItem: 'ERROR_CANNOT_DELETE_ALREADY_DELETED_ITEM'
};
const DispatchBuilderPageDataSource404ResponseErrorEnum = {
    DataSourceDoesNotExist: 'ERROR_DATA_SOURCE_DOES_NOT_EXIST',
    DataSourceImproperlyConfigured: 'ERROR_DATA_SOURCE_IMPROPERLY_CONFIGURED',
    InDispatchContext: 'ERROR_IN_DISPATCH_CONTEXT',
    DataDoesNotExist: 'ERROR_DATA_DOES_NOT_EXIST'
};
const DispatchBuilderPageDataSources404ResponseErrorEnum = {
    DataSourceImproperlyConfigured: 'ERROR_DATA_SOURCE_IMPROPERLY_CONFIGURED',
    InDispatchContext: 'ERROR_IN_DISPATCH_CONTEXT',
    DataDoesNotExist: 'ERROR_DATA_DOES_NOT_EXIST',
    PageDoesNotExist: 'ERROR_PAGE_DOES_NOT_EXIST'
};
const DispatchBuilderPageWorkflowAction400ResponseErrorEnum = {
    ErrorWorkflowActionCannotBeDispatched: 'ERROR_WORKFLOW_ACTION_CANNOT_BE_DISPATCHED'
};
const DuplicateApplicationAsync400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ApplicationNotInGroup: 'ERROR_APPLICATION_NOT_IN_GROUP',
    MaxJobCountExceeded: 'ERROR_MAX_JOB_COUNT_EXCEEDED'
};
const DuplicateTableField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    MaxJobCountExceeded: 'ERROR_MAX_JOB_COUNT_EXCEEDED'
};
/**
 * * `h:mm` - hours:minutes * `h:mm:ss` - hours:minutes:seconds * `h:mm:ss.s` - hours:minutes:seconds:deciseconds * `h:mm:ss.ss` - hours:minutes:seconds:centiseconds * `h:mm:ss.sss` - hours:minutes:seconds:milliseconds * `d h` - days:hours * `d h:mm` - days:hours:minutes * `d h:mm:ss` - days:hours:minutes:seconds * `d h mm` - days:hours:minutes:with_spaces * `d h mm ss` - days:hours:minutes:seconds:with_spaces
 * @export
 * @enum {string}
 */
const DurationFormatEnum = {
    Hmm: 'h:mm',
    Hmmss: 'h:mm:ss',
    HmmssS: 'h:mm:ss.s',
    HmmssSs: 'h:mm:ss.ss',
    HmmssSss: 'h:mm:ss.sss',
    DH: 'd h',
    DHmm: 'd h:mm',
    DHmmss: 'd h:mm:ss',
    DHMm: 'd h mm',
    DHMmSs: 'd h mm ss'
};
/**
 * * `instant` - instant * `daily` - daily * `weekly` - weekly * `never` - never
 * @export
 * @enum {string}
 */
const EmailNotificationFrequencyEnum = {
    Instant: 'instant',
    Daily: 'daily',
    Weekly: 'weekly',
    Never: 'never'
};
const EmailTester400ResponseErrorEnum = {
    ErrorRequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION'
};
/**
 * * `no_verification` - no_verification * `recommended` - recommended * `enforced` - enforced
 * @export
 * @enum {string}
 */
const EmailVerificationEnum = {
    NoVerification: 'no_verification',
    Recommended: 'recommended',
    Enforced: 'enforced'
};
/**
 * * `rows.created` - rows.created * `row.created` - row.created * `rows.updated` - rows.updated * `row.updated` - row.updated * `rows.deleted` - rows.deleted * `row.deleted` - row.deleted
 * @export
 * @enum {string}
 */
const EventTypeEnum = {
    RowsCreated: 'rows.created',
    RowCreated: 'row.created',
    RowsUpdated: 'rows.updated',
    RowUpdated: 'row.updated',
    RowsDeleted: 'rows.deleted',
    RowDeleted: 'row.deleted'
};
/**
 * * `rows.created` - rows.created * `rows.updated` - rows.updated * `rows.deleted` - rows.deleted
 * @export
 * @enum {string}
 */
const EventTypesEnum = {
    Created: 'rows.created',
    Updated: 'rows.updated',
    Deleted: 'rows.deleted'
};
/**
 * * `rows.created` - rows.created * `row.created` - row.created * `rows.updated` - rows.updated * `row.updated` - row.updated * `rows.deleted` - rows.deleted * `row.deleted` - row.deleted
 * @export
 * @enum {string}
 */
const Events29bEnum = {
    RowsCreated: 'rows.created',
    RowCreated: 'row.created',
    RowsUpdated: 'rows.updated',
    RowUpdated: 'row.updated',
    RowsDeleted: 'rows.deleted',
    RowDeleted: 'row.deleted'
};
/**
 * * `utf-8` - utf-8 * `iso-8859-6` - iso-8859-6 * `windows-1256` - windows-1256 * `iso-8859-4` - iso-8859-4 * `windows-1257` - windows-1257 * `iso-8859-14` - iso-8859-14 * `iso-8859-2` - iso-8859-2 * `windows-1250` - windows-1250 * `gbk` - gbk * `gb18030` - gb18030 * `big5` - big5 * `koi8-r` - koi8-r * `koi8-u` - koi8-u * `iso-8859-5` - iso-8859-5 * `windows-1251` - windows-1251 * `x-mac-cyrillic` - mac-cyrillic * `iso-8859-7` - iso-8859-7 * `windows-1253` - windows-1253 * `iso-8859-8` - iso-8859-8 * `windows-1255` - windows-1255 * `euc-jp` - euc-jp * `iso-2022-jp` - iso-2022-jp * `shift-jis` - shift-jis * `euc-kr` - euc-kr * `macintosh` - macintosh * `iso-8859-10` - iso-8859-10 * `iso-8859-16` - iso-8859-16 * `windows-874` - cp874 * `windows-1254` - windows-1254 * `windows-1258` - windows-1258 * `iso-8859-1` - iso-8859-1 * `windows-1252` - windows-1252 * `iso-8859-3` - iso-8859-3
 * @export
 * @enum {string}
 */
const ExportCharsetEnum = {
    Utf8: 'utf-8',
    Iso88596: 'iso-8859-6',
    Windows1256: 'windows-1256',
    Iso88594: 'iso-8859-4',
    Windows1257: 'windows-1257',
    Iso885914: 'iso-8859-14',
    Iso88592: 'iso-8859-2',
    Windows1250: 'windows-1250',
    Gbk: 'gbk',
    Gb18030: 'gb18030',
    Big5: 'big5',
    Koi8R: 'koi8-r',
    Koi8U: 'koi8-u',
    Iso88595: 'iso-8859-5',
    Windows1251: 'windows-1251',
    XMacCyrillic: 'x-mac-cyrillic',
    Iso88597: 'iso-8859-7',
    Windows1253: 'windows-1253',
    Iso88598: 'iso-8859-8',
    Windows1255: 'windows-1255',
    EucJp: 'euc-jp',
    Iso2022Jp: 'iso-2022-jp',
    ShiftJis: 'shift-jis',
    EucKr: 'euc-kr',
    Macintosh: 'macintosh',
    Iso885910: 'iso-8859-10',
    Iso885916: 'iso-8859-16',
    Windows874: 'windows-874',
    Windows1254: 'windows-1254',
    Windows1258: 'windows-1258',
    Iso88591: 'iso-8859-1',
    Windows1252: 'windows-1252',
    Iso88593: 'iso-8859-3'
};
const ExportTable400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    TableOnlyExportUnsupported: 'ERROR_TABLE_ONLY_EXPORT_UNSUPPORTED',
    ViewUnsupportedForExportType: 'ERROR_VIEW_UNSUPPORTED_FOR_EXPORT_TYPE',
    ViewNotInTable: 'ERROR_VIEW_NOT_IN_TABLE'
};
const ExportTable404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    ViewDoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST'
};
/**
 * * `csv` - csv * `json` - json * `xml` - xml
 * @export
 * @enum {string}
 */
const ExporterTypeEnum = {
    Csv: 'csv',
    Json: 'json',
    Xml: 'xml'
};
/**
 * * `create_group` - create_group * `delete_group` - delete_group * `update_group` - update_group * `order_groups` - order_groups * `create_application` - create_application * `update_application` - update_application * `delete_application` - delete_application * `order_applications` - order_applications * `duplicate_application` - duplicate_application * `install_template` - install_template * `create_group_invitation` - create_group_invitation * `delete_group_invitation` - delete_group_invitation * `accept_group_invitation` - accept_group_invitation * `reject_group_invitation` - reject_group_invitation * `update_group_invitation_permissions` - update_group_invitation_permissions * `leave_group` - leave_group * `create_initial_workspace` - create_initial_workspace * `create_snapshot` - create_snapshot * `delete_snapshot` - delete_snapshot * `restore_snapshot` - restore_snapshot * `empty_trash` - empty_trash * `restore_from_trash` - restore_from_trash * `create_user` - create_user * `update_user` - update_user * `schedule_user_deletion` - schedule_user_deletion * `cancel_user_deletion` - cancel_user_deletion * `sign_in_user` - sign_in_user * `change_user_password` - change_user_password * `send_reset_user_password` - send_reset_user_password * `reset_user_password` - reset_user_password * `send_verify_email` - send_verify_email * `verify_email` - verify_email * `create_db_token` - create_db_token * `update_db_token_name` - update_db_token_name * `update_db_token_permissions` - update_db_token_permissions * `rotate_db_token_key` - rotate_db_token_key * `delete_db_token_key` - delete_db_token_key * `create_webhook` - create_webhook * `delete_webhook` - delete_webhook * `update_webhook` - update_webhook * `export_table` - export_table * `import_database_from_airtable` - import_database_from_airtable * `create_table` - create_table * `delete_table` - delete_table * `order_tables` - order_tables * `update_table` - update_table * `duplicate_table` - duplicate_table * `create_row` - create_row * `create_rows` - create_rows * `import_rows` - import_rows * `delete_row` - delete_row * `delete_rows` - delete_rows * `move_row` - move_row * `update_row` - update_row * `update_rows` - update_rows * `create_view` - create_view * `duplicate_view` - duplicate_view * `delete_view` - delete_view * `order_views` - order_views * `update_view` - update_view * `create_view_filter` - create_view_filter * `update_view_filter` - update_view_filter * `delete_view_filter` - delete_view_filter * `create_view_sort` - create_view_sort * `update_view_sort` - update_view_sort * `delete_view_sort` - delete_view_sort * `create_view_group` - create_view_group * `update_view_group` - update_view_group * `delete_view_group` - delete_view_group * `rotate_view_slug` - rotate_view_slug * `update_view_field_options` - update_view_field_options * `create_decoration` - create_decoration * `update_decoration` - update_decoration * `delete_decoration` - delete_decoration * `create_view_filter_group` - create_view_filter_group * `update_view_filter_group` - update_view_filter_group * `delete_view_filter_group` - delete_view_filter_group * `create_field` - create_field * `delete_field` - delete_field * `update_field` - update_field * `duplicate_field` - duplicate_field * `change_primary_field` - change_primary_field * `generate_formula_with_ai` - generate_formula_with_ai * `create_row_comment` - create_row_comment * `delete_row_comment` - delete_row_comment * `update_row_comment` - update_row_comment * `rotate_calendar_ical_view_slug` - rotate_calendar_ical_view_slug * `create_team` - create_team * `update_team` - update_team * `delete_team` - delete_team * `create_team_subject` - create_team_subject * `delete_team_subject` - delete_team_subject * `batch_assign_role` - batch_assign_role
 * @export
 * @enum {string}
 */
const FilterActionTypeEnum = {
    CreateGroup: 'create_group',
    DeleteGroup: 'delete_group',
    UpdateGroup: 'update_group',
    OrderGroups: 'order_groups',
    CreateApplication: 'create_application',
    UpdateApplication: 'update_application',
    DeleteApplication: 'delete_application',
    OrderApplications: 'order_applications',
    DuplicateApplication: 'duplicate_application',
    InstallTemplate: 'install_template',
    CreateGroupInvitation: 'create_group_invitation',
    DeleteGroupInvitation: 'delete_group_invitation',
    AcceptGroupInvitation: 'accept_group_invitation',
    RejectGroupInvitation: 'reject_group_invitation',
    UpdateGroupInvitationPermissions: 'update_group_invitation_permissions',
    LeaveGroup: 'leave_group',
    CreateInitialWorkspace: 'create_initial_workspace',
    CreateSnapshot: 'create_snapshot',
    DeleteSnapshot: 'delete_snapshot',
    RestoreSnapshot: 'restore_snapshot',
    EmptyTrash: 'empty_trash',
    RestoreFromTrash: 'restore_from_trash',
    CreateUser: 'create_user',
    UpdateUser: 'update_user',
    ScheduleUserDeletion: 'schedule_user_deletion',
    CancelUserDeletion: 'cancel_user_deletion',
    SignInUser: 'sign_in_user',
    ChangeUserPassword: 'change_user_password',
    SendResetUserPassword: 'send_reset_user_password',
    ResetUserPassword: 'reset_user_password',
    SendVerifyEmail: 'send_verify_email',
    VerifyEmail: 'verify_email',
    CreateDbToken: 'create_db_token',
    UpdateDbTokenName: 'update_db_token_name',
    UpdateDbTokenPermissions: 'update_db_token_permissions',
    RotateDbTokenKey: 'rotate_db_token_key',
    DeleteDbTokenKey: 'delete_db_token_key',
    CreateWebhook: 'create_webhook',
    DeleteWebhook: 'delete_webhook',
    UpdateWebhook: 'update_webhook',
    ExportTable: 'export_table',
    ImportDatabaseFromAirtable: 'import_database_from_airtable',
    CreateTable: 'create_table',
    DeleteTable: 'delete_table',
    OrderTables: 'order_tables',
    UpdateTable: 'update_table',
    DuplicateTable: 'duplicate_table',
    CreateRow: 'create_row',
    CreateRows: 'create_rows',
    ImportRows: 'import_rows',
    DeleteRow: 'delete_row',
    DeleteRows: 'delete_rows',
    MoveRow: 'move_row',
    UpdateRow: 'update_row',
    UpdateRows: 'update_rows',
    CreateView: 'create_view',
    DuplicateView: 'duplicate_view',
    DeleteView: 'delete_view',
    OrderViews: 'order_views',
    UpdateView: 'update_view',
    CreateViewFilter: 'create_view_filter',
    UpdateViewFilter: 'update_view_filter',
    DeleteViewFilter: 'delete_view_filter',
    CreateViewSort: 'create_view_sort',
    UpdateViewSort: 'update_view_sort',
    DeleteViewSort: 'delete_view_sort',
    CreateViewGroup: 'create_view_group',
    UpdateViewGroup: 'update_view_group',
    DeleteViewGroup: 'delete_view_group',
    RotateViewSlug: 'rotate_view_slug',
    UpdateViewFieldOptions: 'update_view_field_options',
    CreateDecoration: 'create_decoration',
    UpdateDecoration: 'update_decoration',
    DeleteDecoration: 'delete_decoration',
    CreateViewFilterGroup: 'create_view_filter_group',
    UpdateViewFilterGroup: 'update_view_filter_group',
    DeleteViewFilterGroup: 'delete_view_filter_group',
    CreateField: 'create_field',
    DeleteField: 'delete_field',
    UpdateField: 'update_field',
    DuplicateField: 'duplicate_field',
    ChangePrimaryField: 'change_primary_field',
    GenerateFormulaWithAi: 'generate_formula_with_ai',
    CreateRowComment: 'create_row_comment',
    DeleteRowComment: 'delete_row_comment',
    UpdateRowComment: 'update_row_comment',
    RotateCalendarIcalViewSlug: 'rotate_calendar_ical_view_slug',
    CreateTeam: 'create_team',
    UpdateTeam: 'update_team',
    DeleteTeam: 'delete_team',
    CreateTeamSubject: 'create_team_subject',
    DeleteTeamSubject: 'delete_team_subject',
    BatchAssignRole: 'batch_assign_role'
};
/**
 * * `plain` - Plain * `markdown` - Markdown
 * @export
 * @enum {string}
 */
const FormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown'
};
/**
 * * `invalid` - invalid * `text` - text * `char` - char * `button` - button * `link` - link * `date_interval` - date_interval * `duration` - duration * `date` - date * `boolean` - boolean * `number` - number * `array` - array * `single_select` - single_select * `multiple_select` - multiple_select * `single_file` - single_file * `url` - url
 * @export
 * @enum {string}
 */
const FormulaTypeEnum = {
    Invalid: 'invalid',
    Text: 'text',
    Char: 'char',
    Button: 'button',
    Link: 'link',
    DateInterval: 'date_interval',
    Duration: 'duration',
    Date: 'date',
    Boolean: 'boolean',
    Number: 'number',
    Array: 'array',
    SingleSelect: 'single_select',
    MultipleSelect: 'multiple_select',
    SingleFile: 'single_file',
    Url: 'url'
};
const GenerateFormulaWithAi400ResponseErrorEnum = {
    GenerativeAiDoesNotExist: 'ERROR_GENERATIVE_AI_DOES_NOT_EXIST',
    ModelDoesNotBelongToType: 'ERROR_MODEL_DOES_NOT_BELONG_TO_TYPE',
    OutputParser: 'ERROR_OUTPUT_PARSER',
    GenerativeAiPrompt: 'ERROR_GENERATIVE_AI_PROMPT',
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP'
};
const GenerateTableAiFieldValue400ResponseErrorEnum = {
    GenerativeAiDoesNotExist: 'ERROR_GENERATIVE_AI_DOES_NOT_EXIST',
    ModelDoesNotBelongToType: 'ERROR_MODEL_DOES_NOT_BELONG_TO_TYPE'
};
const GenerateTableAiFieldValue404ResponseErrorEnum = {
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST',
    RowDoesNotExist: 'ERROR_ROW_DOES_NOT_EXIST'
};
const GetAdjacentDatabaseTableRow404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    RowDoesNotExist: 'ERROR_ROW_DOES_NOT_EXIST',
    ViewDoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST'
};
const GetAuthProvider404ResponseErrorEnum = {
    ErrorAuthProviderDoesNotExist: 'ERROR_AUTH_PROVIDER_DOES_NOT_EXIST'
};
const GetDatabaseTableField404ResponseErrorEnum = {
    ErrorFieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST'
};
const GetDatabaseTableGridViewFieldAggregation400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    AggregationTypeDoesNotExist: 'ERROR_AGGREGATION_TYPE_DOES_NOT_EXIST',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE'
};
const GetDatabaseTableGridViewFieldAggregation404ResponseErrorEnum = {
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST',
    GridDoesNotExist: 'ERROR_GRID_DOES_NOT_EXIST'
};
const GetDatabaseTablePublicGridViewFieldAggregations400ResponseErrorEnum = {
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const GetDatabaseTablePublicGridViewFieldAggregations404ResponseErrorEnum = {
    ErrorGridDoesNotExist: 'ERROR_GRID_DOES_NOT_EXIST'
};
const GetDatabaseTableViewDecoration404ResponseErrorEnum = {
    ErrorViewDecorationDoesNotExist: 'ERROR_VIEW_DECORATION_DOES_NOT_EXIST'
};
const GetDatabaseTableViewFieldOptions400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ViewDoesNotSupportFieldOptions: 'ERROR_VIEW_DOES_NOT_SUPPORT_FIELD_OPTIONS'
};
const GetDatabaseTableViewFilter404ResponseErrorEnum = {
    ErrorViewFilterDoesNotExist: 'ERROR_VIEW_FILTER_DOES_NOT_EXIST'
};
const GetDatabaseTableViewFilterGroup404ResponseErrorEnum = {
    ErrorViewFilterGroupDoesNotExist: 'ERROR_VIEW_FILTER_GROUP_DOES_NOT_EXIST'
};
const GetDatabaseTableViewGroup404ResponseErrorEnum = {
    ErrorViewGroupByDoesNotExist: 'ERROR_VIEW_GROUP_BY_DOES_NOT_EXIST'
};
const GetDatabaseTableViewSort404ResponseErrorEnum = {
    ErrorViewSortDoesNotExist: 'ERROR_VIEW_SORT_DOES_NOT_EXIST'
};
const GetDatabaseTableWebhook404ResponseErrorEnum = {
    ErrorTableWebhookDoesNotExist: 'ERROR_TABLE_WEBHOOK_DOES_NOT_EXIST'
};
const GetDatabaseToken404ResponseErrorEnum = {
    ErrorTokenDoesNotExist: 'ERROR_TOKEN_DOES_NOT_EXIST'
};
const GetExportJob404ResponseErrorEnum = {
    ErrorExportJobDoesNotExist: 'ERROR_EXPORT_JOB_DOES_NOT_EXIST'
};
const GetGroupInvitation400ResponseErrorEnum = {
    NotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    InvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS'
};
const GetGroupInvitation404ResponseErrorEnum = {
    ErrorGroupInvitationDoesNotExist: 'ERROR_GROUP_INVITATION_DOES_NOT_EXIST'
};
const GetGroupInvitationByToken400ResponseErrorEnum = {
    BadTokenSignature: 'BAD_TOKEN_SIGNATURE'
};
const GetJob404ResponseErrorEnum = {
    ErrorJobDoesNotExist: 'ERROR_JOB_DOES_NOT_EXIST'
};
const GetMetaDatabaseTableFormView401ResponseErrorEnum = {
    ErrorNoPermissionToPubliclySharedForm: 'ERROR_NO_PERMISSION_TO_PUBLICLY_SHARED_FORM'
};
const GetMetaDatabaseTableFormView404ResponseErrorEnum = {
    ErrorFormDoesNotExist: 'ERROR_FORM_DOES_NOT_EXIST'
};
const GetPublicBuilderById404ResponseErrorEnum = {
    ErrorBuilderDoesNotExist: 'ERROR_BUILDER_DOES_NOT_EXIST'
};
const GetTeam404ResponseErrorEnum = {
    ErrorTeamDoesNotExist: 'ERROR_TEAM_DOES_NOT_EXIST'
};
const GroupAssignRole400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    CantAssignRoleExceptionToAdmin: 'ERROR_CANT_ASSIGN_ROLE_EXCEPTION_TO_ADMIN'
};
const GroupAssignRole404ResponseErrorEnum = {
    ScopeDoesNotExist: 'ERROR_SCOPE_DOES_NOT_EXIST',
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    ObjectScopeTypeDoesNotExist: 'ERROR_OBJECT_SCOPE_TYPE_DOES_NOT_EXIST',
    SubjectTypeDoesNotExist: 'ERROR_SUBJECT_TYPE_DOES_NOT_EXIST',
    RoleDoesNotExist: 'ERROR_ROLE_DOES_NOT_EXIST'
};
const GroupBatchAssignRole400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    DuplicateRoleAssignments: 'ERROR_DUPLICATE_ROLE_ASSIGNMENTS',
    CantAssignRoleExceptionToAdmin: 'ERROR_CANT_ASSIGN_ROLE_EXCEPTION_TO_ADMIN'
};
const GroupCreateTeam400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    SubjectBadRequest: 'ERROR_SUBJECT_BAD_REQUEST',
    TeamNameNotUnique: 'ERROR_TEAM_NAME_NOT_UNIQUE',
    SubjectNotInGroup: 'ERROR_SUBJECT_NOT_IN_GROUP',
    SubjectTypeUnsupported: 'ERROR_SUBJECT_TYPE_UNSUPPORTED'
};
const GroupCreateTeam404ResponseErrorEnum = {
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    SubjectDoesNotExist: 'ERROR_SUBJECT_DOES_NOT_EXIST',
    RoleDoesNotExist: 'ERROR_ROLE_DOES_NOT_EXIST'
};
const GroupGetContents400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ApplicationNotInGroup: 'ERROR_APPLICATION_NOT_IN_GROUP',
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    ApplicationDoesNotExist: 'ERROR_APPLICATION_DOES_NOT_EXIST'
};
const GroupInstallTemplate400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TemplateFileDoesNotExist: 'ERROR_TEMPLATE_FILE_DOES_NOT_EXIST'
};
const GroupInstallTemplate404ResponseErrorEnum = {
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    TemplateDoesNotExist: 'ERROR_TEMPLATE_DOES_NOT_EXIST'
};
const GroupInstallTemplateAsync400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TemplateFileDoesNotExist: 'ERROR_TEMPLATE_FILE_DOES_NOT_EXIST',
    MaxJobCountExceeded: 'ERROR_MAX_JOB_COUNT_EXCEEDED'
};
const GroupListRoleAssignments404ResponseErrorEnum = {
    ScopeDoesNotExist: 'ERROR_SCOPE_DOES_NOT_EXIST',
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    ObjectScopeTypeDoesNotExist: 'ERROR_OBJECT_SCOPE_TYPE_DOES_NOT_EXIST'
};
const GroupOrderApplications400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ApplicationNotInGroup: 'ERROR_APPLICATION_NOT_IN_GROUP'
};
const GroupPermissions404ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    GroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST'
};
/**
 * * `create_group` - create_group * `delete_group` - delete_group * `update_group` - update_group * `order_groups` - order_groups * `create_application` - create_application * `update_application` - update_application * `delete_application` - delete_application * `order_applications` - order_applications * `duplicate_application` - duplicate_application * `install_template` - install_template * `create_group_invitation` - create_group_invitation * `delete_group_invitation` - delete_group_invitation * `accept_group_invitation` - accept_group_invitation * `reject_group_invitation` - reject_group_invitation * `update_group_invitation_permissions` - update_group_invitation_permissions * `leave_group` - leave_group * `create_initial_workspace` - create_initial_workspace * `create_snapshot` - create_snapshot * `delete_snapshot` - delete_snapshot * `restore_snapshot` - restore_snapshot * `empty_trash` - empty_trash * `restore_from_trash` - restore_from_trash * `create_user` - create_user * `update_user` - update_user * `schedule_user_deletion` - schedule_user_deletion * `cancel_user_deletion` - cancel_user_deletion * `sign_in_user` - sign_in_user * `change_user_password` - change_user_password * `send_reset_user_password` - send_reset_user_password * `reset_user_password` - reset_user_password * `send_verify_email` - send_verify_email * `verify_email` - verify_email * `create_db_token` - create_db_token * `update_db_token_name` - update_db_token_name * `update_db_token_permissions` - update_db_token_permissions * `rotate_db_token_key` - rotate_db_token_key * `delete_db_token_key` - delete_db_token_key * `create_webhook` - create_webhook * `delete_webhook` - delete_webhook * `update_webhook` - update_webhook * `export_table` - export_table * `import_database_from_airtable` - import_database_from_airtable * `create_table` - create_table * `delete_table` - delete_table * `order_tables` - order_tables * `update_table` - update_table * `duplicate_table` - duplicate_table * `create_row` - create_row * `create_rows` - create_rows * `import_rows` - import_rows * `delete_row` - delete_row * `delete_rows` - delete_rows * `move_row` - move_row * `update_row` - update_row * `update_rows` - update_rows * `create_view` - create_view * `duplicate_view` - duplicate_view * `delete_view` - delete_view * `order_views` - order_views * `update_view` - update_view * `create_view_filter` - create_view_filter * `update_view_filter` - update_view_filter * `delete_view_filter` - delete_view_filter * `create_view_sort` - create_view_sort * `update_view_sort` - update_view_sort * `delete_view_sort` - delete_view_sort * `create_view_group` - create_view_group * `update_view_group` - update_view_group * `delete_view_group` - delete_view_group * `rotate_view_slug` - rotate_view_slug * `update_view_field_options` - update_view_field_options * `create_decoration` - create_decoration * `update_decoration` - update_decoration * `delete_decoration` - delete_decoration * `create_view_filter_group` - create_view_filter_group * `update_view_filter_group` - update_view_filter_group * `delete_view_filter_group` - delete_view_filter_group * `create_field` - create_field * `delete_field` - delete_field * `update_field` - update_field * `duplicate_field` - duplicate_field * `change_primary_field` - change_primary_field * `generate_formula_with_ai` - generate_formula_with_ai * `create_row_comment` - create_row_comment * `delete_row_comment` - delete_row_comment * `update_row_comment` - update_row_comment * `rotate_calendar_ical_view_slug` - rotate_calendar_ical_view_slug * `create_team` - create_team * `update_team` - update_team * `delete_team` - delete_team * `create_team_subject` - create_team_subject * `delete_team_subject` - delete_team_subject * `batch_assign_role` - batch_assign_role
 * @export
 * @enum {string}
 */
const IdEnum = {
    CreateGroup: 'create_group',
    DeleteGroup: 'delete_group',
    UpdateGroup: 'update_group',
    OrderGroups: 'order_groups',
    CreateApplication: 'create_application',
    UpdateApplication: 'update_application',
    DeleteApplication: 'delete_application',
    OrderApplications: 'order_applications',
    DuplicateApplication: 'duplicate_application',
    InstallTemplate: 'install_template',
    CreateGroupInvitation: 'create_group_invitation',
    DeleteGroupInvitation: 'delete_group_invitation',
    AcceptGroupInvitation: 'accept_group_invitation',
    RejectGroupInvitation: 'reject_group_invitation',
    UpdateGroupInvitationPermissions: 'update_group_invitation_permissions',
    LeaveGroup: 'leave_group',
    CreateInitialWorkspace: 'create_initial_workspace',
    CreateSnapshot: 'create_snapshot',
    DeleteSnapshot: 'delete_snapshot',
    RestoreSnapshot: 'restore_snapshot',
    EmptyTrash: 'empty_trash',
    RestoreFromTrash: 'restore_from_trash',
    CreateUser: 'create_user',
    UpdateUser: 'update_user',
    ScheduleUserDeletion: 'schedule_user_deletion',
    CancelUserDeletion: 'cancel_user_deletion',
    SignInUser: 'sign_in_user',
    ChangeUserPassword: 'change_user_password',
    SendResetUserPassword: 'send_reset_user_password',
    ResetUserPassword: 'reset_user_password',
    SendVerifyEmail: 'send_verify_email',
    VerifyEmail: 'verify_email',
    CreateDbToken: 'create_db_token',
    UpdateDbTokenName: 'update_db_token_name',
    UpdateDbTokenPermissions: 'update_db_token_permissions',
    RotateDbTokenKey: 'rotate_db_token_key',
    DeleteDbTokenKey: 'delete_db_token_key',
    CreateWebhook: 'create_webhook',
    DeleteWebhook: 'delete_webhook',
    UpdateWebhook: 'update_webhook',
    ExportTable: 'export_table',
    ImportDatabaseFromAirtable: 'import_database_from_airtable',
    CreateTable: 'create_table',
    DeleteTable: 'delete_table',
    OrderTables: 'order_tables',
    UpdateTable: 'update_table',
    DuplicateTable: 'duplicate_table',
    CreateRow: 'create_row',
    CreateRows: 'create_rows',
    ImportRows: 'import_rows',
    DeleteRow: 'delete_row',
    DeleteRows: 'delete_rows',
    MoveRow: 'move_row',
    UpdateRow: 'update_row',
    UpdateRows: 'update_rows',
    CreateView: 'create_view',
    DuplicateView: 'duplicate_view',
    DeleteView: 'delete_view',
    OrderViews: 'order_views',
    UpdateView: 'update_view',
    CreateViewFilter: 'create_view_filter',
    UpdateViewFilter: 'update_view_filter',
    DeleteViewFilter: 'delete_view_filter',
    CreateViewSort: 'create_view_sort',
    UpdateViewSort: 'update_view_sort',
    DeleteViewSort: 'delete_view_sort',
    CreateViewGroup: 'create_view_group',
    UpdateViewGroup: 'update_view_group',
    DeleteViewGroup: 'delete_view_group',
    RotateViewSlug: 'rotate_view_slug',
    UpdateViewFieldOptions: 'update_view_field_options',
    CreateDecoration: 'create_decoration',
    UpdateDecoration: 'update_decoration',
    DeleteDecoration: 'delete_decoration',
    CreateViewFilterGroup: 'create_view_filter_group',
    UpdateViewFilterGroup: 'update_view_filter_group',
    DeleteViewFilterGroup: 'delete_view_filter_group',
    CreateField: 'create_field',
    DeleteField: 'delete_field',
    UpdateField: 'update_field',
    DuplicateField: 'duplicate_field',
    ChangePrimaryField: 'change_primary_field',
    GenerateFormulaWithAi: 'generate_formula_with_ai',
    CreateRowComment: 'create_row_comment',
    DeleteRowComment: 'delete_row_comment',
    UpdateRowComment: 'update_row_comment',
    RotateCalendarIcalViewSlug: 'rotate_calendar_ical_view_slug',
    CreateTeam: 'create_team',
    UpdateTeam: 'update_team',
    DeleteTeam: 'delete_team',
    CreateTeamSubject: 'create_team_subject',
    DeleteTeamSubject: 'delete_team_subject',
    BatchAssignRole: 'batch_assign_role'
};
/**
 * * `cover` - Cover * `contain` - Contain * `full-width` - Full Width
 * @export
 * @enum {string}
 */
const ImageConstraintEnum = {
    Cover: 'cover',
    Contain: 'contain',
    FullWidth: 'full-width'
};
/**
 * * `upload` - Upload * `url` - Url
 * @export
 * @enum {string}
 */
const ImageSourceTypeEnum = {
    Upload: 'upload',
    Url: 'url'
};
/**
 * * `text` - Text * `password` - Password
 * @export
 * @enum {string}
 */
const InputTypeEnum = {
    Text: 'text',
    Password: 'password'
};
const LeaveGroup400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    GroupUserIsLastAdmin: 'ERROR_GROUP_USER_IS_LAST_ADMIN'
};
const ListAllApplications400ResponseErrorEnum = {
    ErrorUserNotInGroup: 'ERROR_USER_NOT_IN_GROUP'
};
const ListApplicationIntegrations404ResponseErrorEnum = {
    ErrorApplicationDoesNotExist: 'ERROR_APPLICATION_DOES_NOT_EXIST'
};
const ListDatabaseTableCalendarViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CalendarViewHasNoDateField: 'ERROR_CALENDAR_VIEW_HAS_NO_DATE_FIELD',
    FeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE'
};
const ListDatabaseTableFields401ResponseErrorEnum = {
    ErrorNoPermissionToTable: 'ERROR_NO_PERMISSION_TO_TABLE'
};
const ListDatabaseTableFields404ResponseErrorEnum = {
    ErrorTableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST'
};
const ListDatabaseTableGalleryViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR',
    OrderByFieldNotFound: 'ERROR_ORDER_BY_FIELD_NOT_FOUND',
    OrderByFieldNotPossible: 'ERROR_ORDER_BY_FIELD_NOT_POSSIBLE'
};
const ListDatabaseTableGalleryViewRows404ResponseErrorEnum = {
    ErrorGalleryDoesNotExist: 'ERROR_GALLERY_DOES_NOT_EXIST'
};
const ListDatabaseTableKanbanViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    KanbanViewHasNoSingleSelectField: 'ERROR_KANBAN_VIEW_HAS_NO_SINGLE_SELECT_FIELD',
    InvalidSelectOptionParameter: 'ERROR_INVALID_SELECT_OPTION_PARAMETER',
    FeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const ListDatabaseTableRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    PageSizeLimit: 'ERROR_PAGE_SIZE_LIMIT',
    InvalidPage: 'ERROR_INVALID_PAGE',
    OrderByFieldNotFound: 'ERROR_ORDER_BY_FIELD_NOT_FOUND',
    OrderByFieldNotPossible: 'ERROR_ORDER_BY_FIELD_NOT_POSSIBLE',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const ListDatabaseTableRows404ResponseErrorEnum = {
    TableDoesNotExist: 'ERROR_TABLE_DOES_NOT_EXIST',
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST',
    ViewDoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST'
};
const ListGroupUsers400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    UserInvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS',
    InvalidSortDirection: 'ERROR_INVALID_SORT_DIRECTION',
    InvalidSortAttribute: 'ERROR_INVALID_SORT_ATTRIBUTE'
};
const ListPublicBuilderPageDataSources404ResponseErrorEnum = {
    ErrorPageDoesNotExist: 'ERROR_PAGE_DOES_NOT_EXIST'
};
/**
 * * `local_baserow_password` - local_baserow_password
 * @export
 * @enum {string}
 */
const LocalBaserowPasswordAppAuthProviderBaseAppAuthProviderTypeEnum = {
    LocalBaserowPassword: 'local_baserow_password'
};
const MarkNotificationAsRead404ResponseErrorEnum = {
    ErrorGroupDoesNotExist: 'ERROR_GROUP_DOES_NOT_EXIST',
    NotificationDoesNotExist: 'NOTIFICATION_DOES_NOT_EXIST'
};
/**
 * * `form` - form * `survey` - survey
 * @export
 * @enum {string}
 */
const Mode51eEnum = {
    Form: 'form',
    Survey: 'survey'
};
/**
 * * `all` - all * `mentions` - mentions
 * @export
 * @enum {string}
 */
const Mode884Enum = {
    All: 'all',
    Mentions: 'mentions'
};
const MoveApplicationIntegration400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    IntegrationNotInSameApplication: 'ERROR_INTEGRATION_NOT_IN_SAME_APPLICATION'
};
const MoveApplicationUserSource400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    UserSourceNotInSameApplication: 'ERROR_USER_SOURCE_NOT_IN_SAME_APPLICATION'
};
const MoveBuilderPageDataSource400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    DataSourceNotInSamePage: 'ERROR_DATA_SOURCE_NOT_IN_SAME_PAGE'
};
const MoveBuilderPageElement400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    ElementNotInSamePage: 'ERROR_ELEMENT_NOT_IN_SAME_PAGE'
};
/**
 * * `page` - Page * `custom` - Custom
 * @export
 * @enum {string}
 */
const NavigationTypeEnum = {
    Page: 'page',
    Custom: 'custom'
};
/**
 *
 * @export
 * @enum {string}
 */
const NullEnum = {
    Null: 'null'
};
/**
 * * `0` - 1 * `1` - 1.0 * `2` - 1.00 * `3` - 1.000 * `4` - 1.0000 * `5` - 1.00000 * `6` - 1.000000 * `7` - 1.0000000 * `8` - 1.00000000 * `9` - 1.000000000 * `10` - 1.0000000000
 * @export
 * @enum {string}
 */
const NumberDecimalPlacesEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10
};
/**
 * * `manual` - Manual * `formulas` - Formulas
 * @export
 * @enum {string}
 */
const OptionTypeEnum = {
    Manual: 'manual',
    Formulas: 'formulas'
};
const OrderBuilderDomains400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    DomainNotInBuilder: 'ERROR_DOMAIN_NOT_IN_BUILDER'
};
const OrderBuilderDomains404ResponseErrorEnum = {
    ApplicationDoesNotExist: 'ERROR_APPLICATION_DOES_NOT_EXIST',
    DomainDoesNotExist: 'ERROR_DOMAIN_DOES_NOT_EXIST'
};
const OrderBuilderPages400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    PageNotInBuilder: 'ERROR_PAGE_NOT_IN_BUILDER'
};
const OrderBuilderPages404ResponseErrorEnum = {
    ApplicationDoesNotExist: 'ERROR_APPLICATION_DOES_NOT_EXIST',
    PageDoesNotExist: 'ERROR_PAGE_DOES_NOT_EXIST'
};
const OrderBuilderWorkflowActions404ResponseErrorEnum = {
    PageDoesNotExist: 'ERROR_PAGE_DOES_NOT_EXIST',
    WorkflowActionDoesNotExist: 'ERROR_WORKFLOW_ACTION_DOES_NOT_EXIST',
    WorkflowActionNotInElement: 'ERROR_WORKFLOW_ACTION_NOT_IN_ELEMENT'
};
/**
 * * `ASC` - Ascending * `DESC` - Descending
 * @export
 * @enum {string}
 */
const OrderByEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
const OrderDatabaseTableViews400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    ViewNotInTable: 'ERROR_VIEW_NOT_IN_TABLE'
};
const OrderDatabaseTables400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TableNotInDatabase: 'ERROR_TABLE_NOT_IN_DATABASE'
};
/**
 * * `ASC` - Ascending * `DESC` - Descending
 * @export
 * @enum {string}
 */
const OrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
/**
 * * `vertical` - Vertical * `horizontal` - Horizontal
 * @export
 * @enum {string}
 */
const OrientationEnum = {
    Vertical: 'vertical',
    Horizontal: 'horizontal'
};
/**
 * * `collaborative` - collaborative * `personal` - personal
 * @export
 * @enum {string}
 */
const OwnershipTypeEnum = {
    Collaborative: 'collaborative',
    Personal: 'personal'
};
/**
 * * `tile` - Tile * `fill` - Fill * `fit` - Fit
 * @export
 * @enum {string}
 */
const PageBackgroundModeEnum = {
    Tile: 'tile',
    Fill: 'fill',
    Fit: 'fit'
};
/**
 * * `text` - text * `numeric` - numeric
 * @export
 * @enum {string}
 */
const PathParamTypeEnum = {
    Text: 'text',
    Numeric: 'numeric'
};
const PremiumViewAttributesUpdate400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    FeatureNotAvailable: 'ERROR_FEATURE_NOT_AVAILABLE',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    CannotUpdatePremiumAttributesOnTemplate: 'ERROR_CANNOT_UPDATE_PREMIUM_ATTRIBUTES_ON_TEMPLATE'
};
const PremiumViewAttributesUpdate404ResponseErrorEnum = {
    ErrorViewDoesNotExist: 'ERROR_VIEW_DOES_NOT_EXIST'
};
const PublicListDatabaseTableGalleryViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const PublicListDatabaseTableGalleryViewRows404ResponseErrorEnum = {
    GalleryDoesNotExist: 'ERROR_GALLERY_DOES_NOT_EXIST',
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST'
};
const PublicListDatabaseTableGridViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    OrderByFieldNotFound: 'ERROR_ORDER_BY_FIELD_NOT_FOUND',
    OrderByFieldNotPossible: 'ERROR_ORDER_BY_FIELD_NOT_POSSIBLE',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const PublicListDatabaseTableGridViewRows404ResponseErrorEnum = {
    GridDoesNotExist: 'ERROR_GRID_DOES_NOT_EXIST',
    FieldDoesNotExist: 'ERROR_FIELD_DOES_NOT_EXIST'
};
const PublicListDatabaseTableKanbanViewRows400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    KanbanViewHasNoSingleSelectField: 'ERROR_KANBAN_VIEW_HAS_NO_SINGLE_SELECT_FIELD',
    ViewFilterTypeDoesNotExist: 'ERROR_VIEW_FILTER_TYPE_DOES_NOT_EXIST',
    ViewFilterTypeUnsupportedField: 'ERROR_VIEW_FILTER_TYPE_UNSUPPORTED_FIELD',
    FilterFieldNotFound: 'ERROR_FILTER_FIELD_NOT_FOUND',
    FiltersParamValidationError: 'ERROR_FILTERS_PARAM_VALIDATION_ERROR'
};
const PublicListDatabaseTableKanbanViewRows404ResponseErrorEnum = {
    ErrorKanbanDoesNotExist: 'ERROR_KANBAN_DOES_NOT_EXIST'
};
/**
 * * `POST` - Post * `GET` - Get * `PUT` - Put * `PATCH` - Patch * `DELETE` - Delete
 * @export
 * @enum {string}
 */
const RequestMethodEnum = {
    Post: 'POST',
    Get: 'GET',
    Put: 'PUT',
    Patch: 'PATCH',
    Delete: 'DELETE'
};
const ResetPassword400ResponseErrorEnum = {
    BadTokenSignature: 'BAD_TOKEN_SIGNATURE',
    ExpiredTokenSignature: 'EXPIRED_TOKEN_SIGNATURE',
    ErrorUserNotFound: 'ERROR_USER_NOT_FOUND',
    ErrorRequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION'
};
const Restore400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TrashItemDoesNotExist: 'ERROR_TRASH_ITEM_DOES_NOT_EXIST',
    CannotRestoreParentBeforeChild: 'ERROR_CANNOT_RESTORE_PARENT_BEFORE_CHILD',
    ParentIdMustNotBeProvided: 'ERROR_PARENT_ID_MUST_NOT_BE_PROVIDED',
    ParentIdMustBeProvided: 'ERROR_PARENT_ID_MUST_BE_PROVIDED',
    CantRestoreAsRelatedTableTrashed: 'ERROR_CANT_RESTORE_AS_RELATED_TABLE_TRASHED',
    CannotRestoreItemNotOwnedByUser: 'ERROR_CANNOT_RESTORE_ITEM_NOT_OWNED_BY_USER'
};
/**
 * * `allow_all` - Allow All * `allow_all_except` - Allow All Except * `disallow_all_except` - Disallow All Except
 * @export
 * @enum {string}
 */
const RoleTypeEnum = {
    AllowAll: 'allow_all',
    AllowAllExcept: 'allow_all_except',
    DisallowAllExcept: 'disallow_all_except'
};
const RotateDatabaseViewSlug400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CannotShareViewType: 'ERROR_CANNOT_SHARE_VIEW_TYPE'
};
/**
 * * `all` - all * `mentions` - mentions
 * @export
 * @enum {string}
 */
const RowCommentsNotificationModeEnum = {
    All: 'all',
    Mentions: 'mentions'
};
/**
 * * `id` - Id * `count` - Count
 * @export
 * @enum {string}
 */
const RowIdentifierTypeEnum = {
    Id: 'id',
    Count: 'count'
};
/**
 * * `core` - core * `application` - application * `workspace` - workspace * `workspace_invitation` - workspace_invitation * `snapshot` - snapshot * `workspace_user` - workspace_user * `integration` - integration * `user_source` - user_source * `database` - database * `database_table` - database_table * `database_field` - database_field * `database_view` - database_view * `database_view_decoration` - database_view_decoration * `database_view_sort` - database_view_sort * `database_view_group` - database_view_group * `database_view_filter` - database_view_filter * `database_view_filter_group` - database_view_filter_group * `token` - token * `builder` - builder * `builder_page` - builder_page * `builder_element` - builder_element * `builder_domain` - builder_domain * `builder_data_source` - builder_data_source * `builder_workflow_action` - builder_workflow_action * `team` - team * `team_subject` - team_subject * `license` - license
 * @export
 * @enum {string}
 */
const ScopeTypeEnum = {
    Core: 'core',
    Application: 'application',
    Workspace: 'workspace',
    WorkspaceInvitation: 'workspace_invitation',
    Snapshot: 'snapshot',
    WorkspaceUser: 'workspace_user',
    Integration: 'integration',
    UserSource: 'user_source',
    Database: 'database',
    DatabaseTable: 'database_table',
    DatabaseField: 'database_field',
    DatabaseView: 'database_view',
    DatabaseViewDecoration: 'database_view_decoration',
    DatabaseViewSort: 'database_view_sort',
    DatabaseViewGroup: 'database_view_group',
    DatabaseViewFilter: 'database_view_filter',
    DatabaseViewFilterGroup: 'database_view_filter_group',
    Token: 'token',
    Builder: 'builder',
    BuilderPage: 'builder_page',
    BuilderElement: 'builder_element',
    BuilderDomain: 'builder_domain',
    BuilderDataSource: 'builder_data_source',
    BuilderWorkflowAction: 'builder_workflow_action',
    Team: 'team',
    TeamSubject: 'team_subject',
    License: 'license'
};
const SecureFileServeDownload403ResponseErrorEnum = {
    ErrorSecureFileServeException: 'ERROR_SECURE_FILE_SERVE_EXCEPTION'
};
const SendPasswordResetEmail400ResponseErrorEnum = {
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    HostnameIsNotAllowed: 'ERROR_HOSTNAME_IS_NOT_ALLOWED'
};
/**
 * * `url` - Url * `embed` - Embed
 * @export
 * @enum {string}
 */
const SourceTypeEnum = {
    Url: 'url',
    Embed: 'embed'
};
/**
 * * `pending` - pending * `exporting` - exporting * `cancelled` - cancelled * `finished` - finished * `failed` - failed * `expired` - expired
 * @export
 * @enum {string}
 */
const StateEnum = {
    Pending: 'pending',
    Exporting: 'exporting',
    Cancelled: 'cancelled',
    Finished: 'finished',
    Failed: 'failed',
    Expired: 'expired'
};
/**
 * * `none` - None * `color` - Color * `image` - Image
 * @export
 * @enum {string}
 */
const StyleBackgroundEnum = {
    None: 'none',
    Color: 'color',
    Image: 'image'
};
/**
 * * `tile` - Tile * `fill` - Fill * `fit` - Fit
 * @export
 * @enum {string}
 */
const StyleBackgroundModeEnum = {
    Tile: 'tile',
    Fill: 'fill',
    Fit: 'fit'
};
/**
 * * `star` - Star * `heart` - Heart * `thumbs-up` - Thumbs-up * `flag` - Flags * `smile` - Smile
 * @export
 * @enum {string}
 */
const StyleEnum = {
    Star: 'star',
    Heart: 'heart',
    ThumbsUp: 'thumbs-up',
    Flag: 'flag',
    Smile: 'smile'
};
/**
 * * `full` - Full * `full-width` - Full Width * `normal` - Normal * `medium` - Medium * `small` - Small
 * @export
 * @enum {string}
 */
const StyleWidthEnum = {
    Full: 'full',
    FullWidth: 'full-width',
    Normal: 'normal',
    Medium: 'medium',
    Small: 'small'
};
/**
 * * `auth.User` - auth.User
 * @export
 * @enum {string}
 */
const SubjectType0b2Enum = {
    AuthUser: 'auth.User'
};
/**
 * * `auth.User` - auth.User * `anonymous` - anonymous * `user_source.user` - user_source.user * `core.Token` - core.Token * `baserow_enterprise.Team` - baserow_enterprise.Team
 * @export
 * @enum {string}
 */
const SubjectType398Enum = {
    AuthUser: 'auth.User',
    Anonymous: 'anonymous',
    UserSourceUser: 'user_source.user',
    CoreToken: 'core.Token',
    BaserowEnterpriseTeam: 'baserow_enterprise.Team'
};
/**
 * * `MESSAGE` - Message * `REDIRECT` - Redirect
 * @export
 * @enum {string}
 */
const SubmitActionEnum = {
    Message: 'MESSAGE',
    Redirect: 'REDIRECT'
};
/**
 * * `left` - Left * `center` - Center * `right` - Right
 * @export
 * @enum {string}
 */
const TableCellAlignmentEnum = {
    Left: 'left',
    Center: 'center',
    Right: 'right'
};
/**
 * * `self` - Self * `blank` - Blank
 * @export
 * @enum {string}
 */
const TargetEnum = {
    Self: 'self',
    Blank: 'blank'
};
const TokenAuth401ResponseErrorEnum = {
    InvalidCredentials: 'ERROR_INVALID_CREDENTIALS',
    DeactivatedUser: 'ERROR_DEACTIVATED_USER',
    AuthProviderDisabled: 'ERROR_AUTH_PROVIDER_DISABLED',
    EmailVerificationRequired: 'ERROR_EMAIL_VERIFICATION_REQUIRED'
};
const TokenRefresh401ResponseErrorEnum = {
    InvalidRefreshToken: 'ERROR_INVALID_REFRESH_TOKEN',
    EmailVerificationRequired: 'ERROR_EMAIL_VERIFICATION_REQUIRED'
};
/**
 * * `workspace` - workspace * `application` - application * `group` - group * `table` - table * `field` - field * `row` - row * `rows` - rows * `view` - view * `builder_domain` - builder_domain * `row_comment` - row_comment * `team` - team
 * @export
 * @enum {string}
 */
const TrashItemTypeEnum = {
    Workspace: 'workspace',
    Application: 'application',
    Group: 'group',
    Table: 'table',
    Field: 'field',
    Row: 'row',
    Rows: 'rows',
    View: 'view',
    BuilderDomain: 'builder_domain',
    RowComment: 'row_comment',
    Team: 'team'
};
/**
 * * `local_baserow` - local_baserow
 * @export
 * @enum {string}
 */
const Type050Enum = {
    LocalBaserow: 'local_baserow'
};
/**
 * * `notification` - notification * `open_page` - open_page * `create_row` - create_row * `update_row` - update_row * `delete_row` - delete_row * `logout` - logout * `refresh_data_source` - refresh_data_source
 * @export
 * @enum {string}
 */
const Type051Enum = {
    Notification: 'notification',
    OpenPage: 'open_page',
    CreateRow: 'create_row',
    UpdateRow: 'update_row',
    DeleteRow: 'delete_row',
    Logout: 'logout',
    RefreshDataSource: 'refresh_data_source'
};
/**
 * * `equal` - equal * `not_equal` - not_equal * `filename_contains` - filename_contains * `files_lower_than` - files_lower_than * `has_file_type` - has_file_type * `contains` - contains * `contains_not` - contains_not * `contains_word` - contains_word * `doesnt_contain_word` - doesnt_contain_word * `length_is_lower_than` - length_is_lower_than * `higher_than` - higher_than * `higher_than_or_equal` - higher_than_or_equal * `lower_than` - lower_than * `lower_than_or_equal` - lower_than_or_equal * `is_even_and_whole` - is_even_and_whole * `date_equal` - date_equal * `date_before` - date_before * `date_before_or_equal` - date_before_or_equal * `date_after_days_ago` - date_after_days_ago * `date_after` - date_after * `date_after_or_equal` - date_after_or_equal * `date_not_equal` - date_not_equal * `date_equals_today` - date_equals_today * `date_before_today` - date_before_today * `date_after_today` - date_after_today * `date_within_days` - date_within_days * `date_within_weeks` - date_within_weeks * `date_within_months` - date_within_months * `date_equals_days_ago` - date_equals_days_ago * `date_equals_months_ago` - date_equals_months_ago * `date_equals_years_ago` - date_equals_years_ago * `date_equals_week` - date_equals_week * `date_equals_month` - date_equals_month * `date_equals_day_of_month` - date_equals_day_of_month * `date_equals_year` - date_equals_year * `date_is` - date_is * `date_is_not` - date_is_not * `date_is_before` - date_is_before * `date_is_on_or_before` - date_is_on_or_before * `date_is_after` - date_is_after * `date_is_on_or_after` - date_is_on_or_after * `date_is_within` - date_is_within * `single_select_equal` - single_select_equal * `single_select_not_equal` - single_select_not_equal * `single_select_is_any_of` - single_select_is_any_of * `single_select_is_none_of` - single_select_is_none_of * `link_row_has` - link_row_has * `link_row_has_not` - link_row_has_not * `link_row_contains` - link_row_contains * `link_row_not_contains` - link_row_not_contains * `boolean` - boolean * `empty` - empty * `not_empty` - not_empty * `multiple_select_has` - multiple_select_has * `multiple_select_has_not` - multiple_select_has_not * `multiple_collaborators_has` - multiple_collaborators_has * `multiple_collaborators_has_not` - multiple_collaborators_has_not * `user_is` - user_is * `user_is_not` - user_is_not * `has_value_equal` - has_value_equal * `has_not_value_equal` - has_not_value_equal * `has_value_contains` - has_value_contains * `has_not_value_contains` - has_not_value_contains * `has_value_contains_word` - has_value_contains_word * `has_not_value_contains_word` - has_not_value_contains_word * `has_value_length_is_lower_than` - has_value_length_is_lower_than * `has_empty_value` - has_empty_value * `has_not_empty_value` - has_not_empty_value
 * @export
 * @enum {string}
 */
const Type083Enum = {
    Equal: 'equal',
    NotEqual: 'not_equal',
    FilenameContains: 'filename_contains',
    FilesLowerThan: 'files_lower_than',
    HasFileType: 'has_file_type',
    Contains: 'contains',
    ContainsNot: 'contains_not',
    ContainsWord: 'contains_word',
    DoesntContainWord: 'doesnt_contain_word',
    LengthIsLowerThan: 'length_is_lower_than',
    HigherThan: 'higher_than',
    HigherThanOrEqual: 'higher_than_or_equal',
    LowerThan: 'lower_than',
    LowerThanOrEqual: 'lower_than_or_equal',
    IsEvenAndWhole: 'is_even_and_whole',
    DateEqual: 'date_equal',
    DateBefore: 'date_before',
    DateBeforeOrEqual: 'date_before_or_equal',
    DateAfterDaysAgo: 'date_after_days_ago',
    DateAfter: 'date_after',
    DateAfterOrEqual: 'date_after_or_equal',
    DateNotEqual: 'date_not_equal',
    DateEqualsToday: 'date_equals_today',
    DateBeforeToday: 'date_before_today',
    DateAfterToday: 'date_after_today',
    DateWithinDays: 'date_within_days',
    DateWithinWeeks: 'date_within_weeks',
    DateWithinMonths: 'date_within_months',
    DateEqualsDaysAgo: 'date_equals_days_ago',
    DateEqualsMonthsAgo: 'date_equals_months_ago',
    DateEqualsYearsAgo: 'date_equals_years_ago',
    DateEqualsWeek: 'date_equals_week',
    DateEqualsMonth: 'date_equals_month',
    DateEqualsDayOfMonth: 'date_equals_day_of_month',
    DateEqualsYear: 'date_equals_year',
    DateIs: 'date_is',
    DateIsNot: 'date_is_not',
    DateIsBefore: 'date_is_before',
    DateIsOnOrBefore: 'date_is_on_or_before',
    DateIsAfter: 'date_is_after',
    DateIsOnOrAfter: 'date_is_on_or_after',
    DateIsWithin: 'date_is_within',
    SingleSelectEqual: 'single_select_equal',
    SingleSelectNotEqual: 'single_select_not_equal',
    SingleSelectIsAnyOf: 'single_select_is_any_of',
    SingleSelectIsNoneOf: 'single_select_is_none_of',
    LinkRowHas: 'link_row_has',
    LinkRowHasNot: 'link_row_has_not',
    LinkRowContains: 'link_row_contains',
    LinkRowNotContains: 'link_row_not_contains',
    Boolean: 'boolean',
    Empty: 'empty',
    NotEmpty: 'not_empty',
    MultipleSelectHas: 'multiple_select_has',
    MultipleSelectHasNot: 'multiple_select_has_not',
    MultipleCollaboratorsHas: 'multiple_collaborators_has',
    MultipleCollaboratorsHasNot: 'multiple_collaborators_has_not',
    UserIs: 'user_is',
    UserIsNot: 'user_is_not',
    HasValueEqual: 'has_value_equal',
    HasNotValueEqual: 'has_not_value_equal',
    HasValueContains: 'has_value_contains',
    HasNotValueContains: 'has_not_value_contains',
    HasValueContainsWord: 'has_value_contains_word',
    HasNotValueContainsWord: 'has_not_value_contains_word',
    HasValueLengthIsLowerThan: 'has_value_length_is_lower_than',
    HasEmptyValue: 'has_empty_value',
    HasNotEmptyValue: 'has_not_empty_value'
};
/**
 * * `custom` - custom * `sub_domain` - sub_domain
 * @export
 * @enum {string}
 */
const Type509Enum = {
    Custom: 'custom',
    SubDomain: 'sub_domain'
};
/**
 * * `text` - text * `long_text` - long_text * `url` - url * `email` - email * `number` - number * `rating` - rating * `boolean` - boolean * `date` - date * `last_modified` - last_modified * `last_modified_by` - last_modified_by * `created_on` - created_on * `created_by` - created_by * `duration` - duration * `link_row` - link_row * `file` - file * `single_select` - single_select * `multiple_select` - multiple_select * `phone_number` - phone_number * `formula` - formula * `count` - count * `rollup` - rollup * `lookup` - lookup * `multiple_collaborators` - multiple_collaborators * `uuid` - uuid * `autonumber` - autonumber * `password` - password * `ai` - ai
 * @export
 * @enum {string}
 */
const Type6ebEnum = {
    Text: 'text',
    LongText: 'long_text',
    Url: 'url',
    Email: 'email',
    Number: 'number',
    Rating: 'rating',
    Boolean: 'boolean',
    Date: 'date',
    LastModified: 'last_modified',
    LastModifiedBy: 'last_modified_by',
    CreatedOn: 'created_on',
    CreatedBy: 'created_by',
    Duration: 'duration',
    LinkRow: 'link_row',
    File: 'file',
    SingleSelect: 'single_select',
    MultipleSelect: 'multiple_select',
    PhoneNumber: 'phone_number',
    Formula: 'formula',
    Count: 'count',
    Rollup: 'rollup',
    Lookup: 'lookup',
    MultipleCollaborators: 'multiple_collaborators',
    Uuid: 'uuid',
    Autonumber: 'autonumber',
    Password: 'password',
    Ai: 'ai'
};
/**
 * * `database` - database * `builder` - builder
 * @export
 * @enum {string}
 */
const Type8b0Enum = {
    Database: 'database',
    Builder: 'builder'
};
/**
 * * `duplicate_application` - duplicate_application * `install_template` - install_template * `create_snapshot` - create_snapshot * `restore_snapshot` - restore_snapshot * `airtable` - airtable * `file_import` - file_import * `duplicate_table` - duplicate_table * `duplicate_field` - duplicate_field * `duplicate_page` - duplicate_page * `publish_domain` - publish_domain * `audit_log_export` - audit_log_export
 * @export
 * @enum {string}
 */
const Type8b6Enum = {
    DuplicateApplication: 'duplicate_application',
    InstallTemplate: 'install_template',
    CreateSnapshot: 'create_snapshot',
    RestoreSnapshot: 'restore_snapshot',
    Airtable: 'airtable',
    FileImport: 'file_import',
    DuplicateTable: 'duplicate_table',
    DuplicateField: 'duplicate_field',
    DuplicatePage: 'duplicate_page',
    PublishDomain: 'publish_domain',
    AuditLogExport: 'audit_log_export'
};
/**
 * * `left_border_color` - left_border_color * `background_color` - background_color
 * @export
 * @enum {string}
 */
const Type9c4Enum = {
    LeftBorderColor: 'left_border_color',
    BackgroundColor: 'background_color'
};
/**
 * * `heading` - heading * `text` - text * `link` - link * `image` - image * `input_text` - input_text * `column` - column * `button` - button * `table` - table * `repeat` - repeat * `form_container` - form_container * `choice` - choice * `checkbox` - checkbox * `iframe` - iframe * `auth_form` - auth_form
 * @export
 * @enum {string}
 */
const TypeB6cEnum = {
    Heading: 'heading',
    Text: 'text',
    Link: 'link',
    Image: 'image',
    InputText: 'input_text',
    Column: 'column',
    Button: 'button',
    Table: 'table',
    Repeat: 'repeat',
    FormContainer: 'form_container',
    Choice: 'choice',
    Checkbox: 'checkbox',
    Iframe: 'iframe',
    AuthForm: 'auth_form'
};
/**
 * * `local_baserow_get_row` - local_baserow_get_row * `local_baserow_list_rows` - local_baserow_list_rows * `local_baserow_upsert_row` - local_baserow_upsert_row * `local_baserow_delete_row` - local_baserow_delete_row
 * @export
 * @enum {string}
 */
const TypeC66Enum = {
    GetRow: 'local_baserow_get_row',
    ListRows: 'local_baserow_list_rows',
    UpsertRow: 'local_baserow_upsert_row',
    DeleteRow: 'local_baserow_delete_row'
};
const TypeFormulaField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    WithFormula: 'ERROR_WITH_FORMULA',
    FieldSelfReference: 'ERROR_FIELD_SELF_REFERENCE'
};
const UpdateBuilderPage404ResponseErrorEnum = {
    PageDoesNotExist: 'ERROR_PAGE_DOES_NOT_EXIST',
    ApplicationDoesNotExist: 'ERROR_APPLICATION_DOES_NOT_EXIST'
};
const UpdateDatabaseTableField400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    CannotChangeFieldType: 'ERROR_CANNOT_CHANGE_FIELD_TYPE',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    ReservedBaserowFieldName: 'ERROR_RESERVED_BASEROW_FIELD_NAME',
    FieldWithSameNameAlreadyExists: 'ERROR_FIELD_WITH_SAME_NAME_ALREADY_EXISTS',
    InvalidBaserowFieldName: 'ERROR_INVALID_BASEROW_FIELD_NAME',
    FieldSelfReference: 'ERROR_FIELD_SELF_REFERENCE',
    FieldCircularReference: 'ERROR_FIELD_CIRCULAR_REFERENCE'
};
const UpdateDatabaseTableView400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE'
};
const UpdateDatabaseTableViewGroup400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    ViewGroupByFieldAlreadyExists: 'ERROR_VIEW_GROUP_BY_FIELD_ALREADY_EXISTS'
};
const UpdateDatabaseTableViewSort400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    FieldNotInTable: 'ERROR_FIELD_NOT_IN_TABLE',
    ViewSortFieldAlreadyExists: 'ERROR_VIEW_SORT_FIELD_ALREADY_EXISTS'
};
const UpdateDatabaseToken400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    DatabaseDoesNotBelongToGroup: 'ERROR_DATABASE_DOES_NOT_BELONG_TO_GROUP',
    TableDoesNotBelongToGroup: 'ERROR_TABLE_DOES_NOT_BELONG_TO_GROUP'
};
const UpdateGroup400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION',
    UserInvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS'
};
const UpdateGroupInvitation400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    UserInvalidGroupPermissions: 'ERROR_USER_INVALID_GROUP_PERMISSIONS',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION'
};
const UpdateGroupUser404ResponseErrorEnum = {
    ErrorGroupUserDoesNotExist: 'ERROR_GROUP_USER_DOES_NOT_EXIST'
};
const UpdateRowComment400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    UserNotCommentAuthor: 'ERROR_USER_NOT_COMMENT_AUTHOR',
    InvalidCommentMention: 'ERROR_INVALID_COMMENT_MENTION',
    BodyValidation: 'ERROR_BODY_VALIDATION'
};
const UpdateTeam400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    TeamNameNotUnique: 'ERROR_TEAM_NAME_NOT_UNIQUE',
    SubjectBadRequest: 'ERROR_SUBJECT_BAD_REQUEST\"'
};
const UpdateTeam404ResponseErrorEnum = {
    TeamDoesNotExist: 'ERROR_TEAM_DOES_NOT_EXIST',
    SubjectDoesNotExist: 'ERROR_SUBJECT_DOES_NOT_EXIST',
    RoleDoesNotExist: 'ERROR_ROLE_DOES_NOT_EXIST'
};
const UploadFile400ResponseErrorEnum = {
    InvalidFile: 'ERROR_INVALID_FILE',
    FileSizeTooLarge: 'ERROR_FILE_SIZE_TOO_LARGE'
};
const UploadFileFormView400ResponseErrorEnum = {
    InvalidFile: 'ERROR_INVALID_FILE',
    FileSizeTooLarge: 'ERROR_FILE_SIZE_TOO_LARGE',
    ViewHasNoPublicFileField: 'ERROR_VIEW_HAS_NO_PUBLIC_FILE_FIELD'
};
const UploadViaUrl400ResponseErrorEnum = {
    InvalidFile: 'ERROR_INVALID_FILE',
    FileSizeTooLarge: 'ERROR_FILE_SIZE_TOO_LARGE',
    FileUrlCouldNotBeReached: 'ERROR_FILE_URL_COULD_NOT_BE_REACHED',
    InvalidFileUrl: 'ERROR_INVALID_FILE_URL'
};
/**
 * * `any` - Any * `email` - Email * `integer` - Integer
 * @export
 * @enum {string}
 */
const ValidationTypeEnum = {
    Any: 'any',
    Email: 'email',
    Integer: 'integer'
};
/**
 * * `` -  * `single_select_color` - single_select_color * `conditional_color` - conditional_color
 * @export
 * @enum {string}
 */
const ValueProviderTypeEnum = {
    SingleSelectColor: 'single_select_color',
    ConditionalColor: 'conditional_color'
};
/**
 * * `link` - Link * `button` - Button
 * @export
 * @enum {string}
 */
const VariantEnum = {
    Link: 'link',
    Button: 'button'
};
const VerifyEmail400ResponseErrorEnum = {
    InvalidVerificationToken: 'ERROR_INVALID_VERIFICATION_TOKEN',
    EmailAlreadyVerified: 'ERROR_EMAIL_ALREADY_VERIFIED'
};
const VerifyEmail401ResponseErrorEnum = {
    DeactivatedUser: 'ERROR_DEACTIVATED_USER',
    AuthProviderDisabled: 'ERROR_AUTH_PROVIDER_DISABLED'
};
/**
 * * `grid` - grid * `gallery` - gallery * `form` - form * `kanban` - kanban * `calendar` - calendar
 * @export
 * @enum {string}
 */
const ViewTypesEnum = {
    Grid: 'grid',
    Gallery: 'gallery',
    Form: 'form',
    Kanban: 'kanban',
    Calendar: 'calendar'
};
/**
 * * `all` - All * `logged-in` - Logged In * `not-logged` - Not Logged
 * @export
 * @enum {string}
 */
const VisibilityEnum = {
    All: 'all',
    LoggedIn: 'logged-in',
    NotLogged: 'not-logged'
};
const WorkspaceGetApplication400ResponseErrorEnum = {
    UserNotInGroup: 'ERROR_USER_NOT_IN_GROUP',
    RequestBodyValidation: 'ERROR_REQUEST_BODY_VALIDATION'
};
/**
 * AdminApi - axios parameter creator
 * @export
 */
const AdminApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Adds the user related to the provided parameter and to the license related to the parameter. This only happens if there are enough seats left on the license and if the user is not already on the license.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} userId The ID of the user that must be added to the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddUserToLicense: (id_1, userId_1, ...args_1) => __awaiter(this, [id_1, userId_1, ...args_1], void 0, function* (id, userId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminAddUserToLicense', 'id', id);
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminAddUserToLicense', 'userId', userId);
            const localVarPath = `/licenses/{id}/{user_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and returns a new user if the requesting user is staff. This works even if new signups are disabled.   This is a **premium** feature.
         * @param {UserAdminCreate} userAdminCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: (userAdminCreate_1, ...args_1) => __awaiter(this, [userAdminCreate_1, ...args_1], void 0, function* (userAdminCreate, options = {}) {
            // verify required parameter 'userAdminCreate' is not null or undefined
            assertParamExists('adminCreateUser', 'userAdminCreate', userAdminCreate);
            const localVarPath = `/admin/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the new and active users for the last 24 hours, 7 days and 30 days. The `previous_` values are the values of the period before, so for example `previous_new_users_last_24_hours` are the new users that signed up from 48 to 24 hours ago. It can be used to calculate an increase or decrease in the amount of signups. A list of the new and active users for every day for the last 30 days is also included.  This is a **premium** feature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDashboard: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/dashboard/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_delete_workspace](#tag/Admin/operation/admin_delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes the specified group and the applications inside that group, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} groupId The id of the group to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminDeleteGroup: (groupId_1, ...args_1) => __awaiter(this, [groupId_1, ...args_1], void 0, function* (groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('adminDeleteGroup', 'groupId', groupId);
            const localVarPath = `/admin/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the specified user, if the requesting user has admin permissions. You cannot delete yourself.   This is a **premium** feature.
         * @param {number} userId The id of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: (userId_1, ...args_1) => __awaiter(this, [userId_1, ...args_1], void 0, function* (userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminDeleteUser', 'userId', userId);
            const localVarPath = `/admin/users/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the specified workspace and the applications inside that workspace, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} workspaceId The id of the workspace to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteWorkspace: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('adminDeleteWorkspace', 'workspaceId', workspaceId);
            const localVarPath = `/admin/workspaces/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates specified user attributes and returns the updated user if the requesting user is staff. You cannot update yourself to no longer be an admin or active.   This is a **premium** feature.
         * @param {number} userId The id of the user to edit
         * @param {PatchedUserAdminUpdate} [patchedUserAdminUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditUser: (userId_1, patchedUserAdminUpdate_1, ...args_1) => __awaiter(this, [userId_1, patchedUserAdminUpdate_1, ...args_1], void 0, function* (userId, patchedUserAdminUpdate, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminEditUser', 'userId', userId);
            const localVarPath = `/admin/users/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserAdminUpdate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fills the remaining empty seats of the license with the first users that are found.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFillRemainingSeatsOfLicense: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminFillRemainingSeatsOfLicense', 'id', id);
            const localVarPath = `/licenses/{id}/fill-seats/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with detailed information about the license related to the provided parameter.
         * @param {number} id The internal identifier of the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetLicense: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetLicense', 'id', id);
            const localVarPath = `/licenses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows staff to impersonate another user by requesting a JWT token and user object. The requesting user must have staff access in order to do this. It\'s not possible to impersonate a superuser or staff.  This is a **premium** feature.
         * @param {BaserowImpersonateAuthToken} baserowImpersonateAuthToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminImpersonateUser: (baserowImpersonateAuthToken_1, ...args_1) => __awaiter(this, [baserowImpersonateAuthToken_1, ...args_1], void 0, function* (baserowImpersonateAuthToken, options = {}) {
            // verify required parameter 'baserowImpersonateAuthToken' is not null or undefined
            assertParamExists('adminImpersonateUser', 'baserowImpersonateAuthToken', baserowImpersonateAuthToken);
            const localVarPath = `/admin/users/impersonate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(baserowImpersonateAuthToken, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint checks with the authority if the license needs to be updated. It also checks if the license is operating within its limits and might take action on that. It could also happen that the license has been deleted because there is an instance id mismatch or because it\'s invalid. In that case a `204` status code is returned.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseCheck: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminLicenseCheck', 'id', id);
            const localVarPath = `/licenses/{id}/check/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint can be used to lookup users that can be added to a  license. Users that are already in the license are not returned here. Optionally a `search` query parameter can be provided to filter the results.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} [page] Defines which page of users should be returned.
         * @param {string} [search] If provided, only users where the name or email contains the value are returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseLookupUsers: (id_1, page_1, search_1, size_1, ...args_1) => __awaiter(this, [id_1, page_1, search_1, size_1, ...args_1], void 0, function* (id, page, search, size, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminLicenseLookupUsers', 'id', id);
            const localVarPath = `/licenses/{id}/lookup-users/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the valid licenses that are registered to this instance. A premium license can be used to unlock the premium features for a fixed amount of users. An enterprise license can similarly be used to unlock enterpise features. More information about self hosted licenses can be found on our pricing page https://baserow.io/pricing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenses: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/licenses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_list_workspaces](#tag/Admin/operation/admin_list_workspaces).**  **Support for this endpoint will end in 2024.**   Returns all groups with detailed information on each group, if the requesting user is staff.  This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only groups with id or name that match the query will be returned.
         * @param {number} [size] Defines how many groups should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, name, application_count, created_on, row_count, storage_usage&#x60;. For example &#x60;sorts&#x3D;-id,-name&#x60; will sort the groups first by descending id and then ascending name. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminListGroups: (page_1, search_1, size_1, sorts_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, sorts_1, ...args_1], void 0, function* (page, search, size, sorts, options = {}) {
            const localVarPath = `/admin/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all users with detailed information on each user, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with id or username or first_name that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, is_active, name, username, date_joined, last_login&#x60;. For example &#x60;sorts&#x3D;-id,-is_active&#x60; will sort the users first by descending id and then ascending is_active. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListUsers: (page_1, search_1, size_1, sorts_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, sorts_1, ...args_1], void 0, function* (page, search, size, sorts, options = {}) {
            const localVarPath = `/admin/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all workspaces with detailed information on each workspace, if the requesting user is staff.  This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with id or name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, name, application_count, created_on, row_count, storage_usage&#x60;. For example &#x60;sorts&#x3D;-id,-name&#x60; will sort the workspaces first by descending id and then ascending name. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListWorkspaces: (page_1, search_1, size_1, sorts_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, sorts_1, ...args_1], void 0, function* (page, search, size, sorts, options = {}) {
            const localVarPath = `/admin/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers a new license. After registering you can assign users to the license that will be able to use the license\'s features while the license is active. If an existing license with the same `license_id` already exists and the provided license has been issued later than that one, the existing one will be upgraded.
         * @param {RegisterLicense} registerLicense
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegisterLicense: (registerLicense_1, ...args_1) => __awaiter(this, [registerLicense_1, ...args_1], void 0, function* (registerLicense, options = {}) {
            // verify required parameter 'registerLicense' is not null or undefined
            assertParamExists('adminRegisterLicense', 'registerLicense', registerLicense);
            const localVarPath = `/licenses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(registerLicense, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes all the users that are on the license. This will empty all the seats.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveAllUsersFromLicense: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminRemoveAllUsersFromLicense', 'id', id);
            const localVarPath = `/licenses/{id}/remove-all-users/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes the existing license related to the provided parameter. If the license is active, then all the users that are using the license will lose access to the features granted by that license.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveLicense: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminRemoveLicense', 'id', id);
            const localVarPath = `/licenses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes the user related to the provided parameter and to the license related to the parameter. This only happens if the user is on the license, otherwise nothing will happen.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} userId The ID of the user that must be removed from the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveUserFromLicense: (id_1, userId_1, ...args_1) => __awaiter(this, [id_1, userId_1, ...args_1], void 0, function* (id, userId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminRemoveUserFromLicense', 'id', id);
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminRemoveUserFromLicense', 'userId', userId);
            const localVarPath = `/licenses/{id}/{user_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AdminApi - functional programming interface
 * @export
 */
const AdminApiFp = function (configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
    return {
        /**
         * Adds the user related to the provided parameter and to the license related to the parameter. This only happens if there are enough seats left on the license and if the user is not already on the license.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} userId The ID of the user that must be added to the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddUserToLicense(id, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminAddUserToLicense(id, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminAddUserToLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates and returns a new user if the requesting user is staff. This works even if new signups are disabled.   This is a **premium** feature.
         * @param {UserAdminCreate} userAdminCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(userAdminCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminCreateUser(userAdminCreate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminCreateUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the new and active users for the last 24 hours, 7 days and 30 days. The `previous_` values are the values of the period before, so for example `previous_new_users_last_24_hours` are the new users that signed up from 48 to 24 hours ago. It can be used to calculate an increase or decrease in the amount of signups. A list of the new and active users for every day for the last 30 days is also included.  This is a **premium** feature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDashboard(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminDashboard(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminDashboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_delete_workspace](#tag/Admin/operation/admin_delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes the specified group and the applications inside that group, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} groupId The id of the group to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminDeleteGroup(groupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminDeleteGroup(groupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminDeleteGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the specified user, if the requesting user has admin permissions. You cannot delete yourself.   This is a **premium** feature.
         * @param {number} userId The id of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminDeleteUser(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminDeleteUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the specified workspace and the applications inside that workspace, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} workspaceId The id of the workspace to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteWorkspace(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminDeleteWorkspace(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminDeleteWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates specified user attributes and returns the updated user if the requesting user is staff. You cannot update yourself to no longer be an admin or active.   This is a **premium** feature.
         * @param {number} userId The id of the user to edit
         * @param {PatchedUserAdminUpdate} [patchedUserAdminUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditUser(userId, patchedUserAdminUpdate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminEditUser(userId, patchedUserAdminUpdate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminEditUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fills the remaining empty seats of the license with the first users that are found.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFillRemainingSeatsOfLicense(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminFillRemainingSeatsOfLicense(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminFillRemainingSeatsOfLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with detailed information about the license related to the provided parameter.
         * @param {number} id The internal identifier of the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetLicense(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminGetLicense(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminGetLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows staff to impersonate another user by requesting a JWT token and user object. The requesting user must have staff access in order to do this. It\'s not possible to impersonate a superuser or staff.  This is a **premium** feature.
         * @param {BaserowImpersonateAuthToken} baserowImpersonateAuthToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminImpersonateUser(baserowImpersonateAuthToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminImpersonateUser(baserowImpersonateAuthToken, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminImpersonateUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint checks with the authority if the license needs to be updated. It also checks if the license is operating within its limits and might take action on that. It could also happen that the license has been deleted because there is an instance id mismatch or because it\'s invalid. In that case a `204` status code is returned.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseCheck(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminLicenseCheck(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminLicenseCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint can be used to lookup users that can be added to a  license. Users that are already in the license are not returned here. Optionally a `search` query parameter can be provided to filter the results.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} [page] Defines which page of users should be returned.
         * @param {string} [search] If provided, only users where the name or email contains the value are returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseLookupUsers(id, page, search, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminLicenseLookupUsers(id, page, search, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminLicenseLookupUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the valid licenses that are registered to this instance. A premium license can be used to unlock the premium features for a fixed amount of users. An enterprise license can similarly be used to unlock enterpise features. More information about self hosted licenses can be found on our pricing page https://baserow.io/pricing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenses(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminLicenses(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminLicenses']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_list_workspaces](#tag/Admin/operation/admin_list_workspaces).**  **Support for this endpoint will end in 2024.**   Returns all groups with detailed information on each group, if the requesting user is staff.  This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only groups with id or name that match the query will be returned.
         * @param {number} [size] Defines how many groups should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, name, application_count, created_on, row_count, storage_usage&#x60;. For example &#x60;sorts&#x3D;-id,-name&#x60; will sort the groups first by descending id and then ascending name. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminListGroups(page, search, size, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminListGroups(page, search, size, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminListGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all users with detailed information on each user, if the requesting user is staff.   This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with id or username or first_name that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, is_active, name, username, date_joined, last_login&#x60;. For example &#x60;sorts&#x3D;-id,-is_active&#x60; will sort the users first by descending id and then ascending is_active. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListUsers(page, search, size, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminListUsers(page, search, size, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminListUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all workspaces with detailed information on each workspace, if the requesting user is staff.  This is a **premium** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with id or name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;id, name, application_count, created_on, row_count, storage_usage&#x60;. For example &#x60;sorts&#x3D;-id,-name&#x60; will sort the workspaces first by descending id and then ascending name. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListWorkspaces(page, search, size, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminListWorkspaces(page, search, size, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminListWorkspaces']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Registers a new license. After registering you can assign users to the license that will be able to use the license\'s features while the license is active. If an existing license with the same `license_id` already exists and the provided license has been issued later than that one, the existing one will be upgraded.
         * @param {RegisterLicense} registerLicense
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegisterLicense(registerLicense, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminRegisterLicense(registerLicense, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminRegisterLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes all the users that are on the license. This will empty all the seats.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveAllUsersFromLicense(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminRemoveAllUsersFromLicense(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminRemoveAllUsersFromLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes the existing license related to the provided parameter. If the license is active, then all the users that are using the license will lose access to the features granted by that license.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveLicense(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminRemoveLicense(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminRemoveLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes the user related to the provided parameter and to the license related to the parameter. This only happens if the user is on the license, otherwise nothing will happen.
         * @param {number} id The internal identifier of the license, this is &#x60;id&#x60; and not &#x60;license_id&#x60;.
         * @param {number} userId The ID of the user that must be removed from the license.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveUserFromLicense(id, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminRemoveUserFromLicense(id, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AdminApi.adminRemoveUserFromLicense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AdminApi - factory interface
 * @export
 */
const AdminApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AdminApiFp(configuration);
    return {
        /**
         * Adds the user related to the provided parameter and to the license related to the parameter. This only happens if there are enough seats left on the license and if the user is not already on the license.
         * @param {AdminApiAdminAddUserToLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddUserToLicense(requestParameters, options) {
            return localVarFp.adminAddUserToLicense(requestParameters.id, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and returns a new user if the requesting user is staff. This works even if new signups are disabled.   This is a **premium** feature.
         * @param {AdminApiAdminCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(requestParameters, options) {
            return localVarFp.adminCreateUser(requestParameters.userAdminCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the new and active users for the last 24 hours, 7 days and 30 days. The `previous_` values are the values of the period before, so for example `previous_new_users_last_24_hours` are the new users that signed up from 48 to 24 hours ago. It can be used to calculate an increase or decrease in the amount of signups. A list of the new and active users for every day for the last 30 days is also included.  This is a **premium** feature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDashboard(options) {
            return localVarFp.adminDashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_delete_workspace](#tag/Admin/operation/admin_delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes the specified group and the applications inside that group, if the requesting user is staff.   This is a **premium** feature.
         * @param {AdminApiAdminDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminDeleteGroup(requestParameters, options) {
            return localVarFp.adminDeleteGroup(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified user, if the requesting user has admin permissions. You cannot delete yourself.   This is a **premium** feature.
         * @param {AdminApiAdminDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(requestParameters, options) {
            return localVarFp.adminDeleteUser(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified workspace and the applications inside that workspace, if the requesting user is staff.   This is a **premium** feature.
         * @param {AdminApiAdminDeleteWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteWorkspace(requestParameters, options) {
            return localVarFp.adminDeleteWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates specified user attributes and returns the updated user if the requesting user is staff. You cannot update yourself to no longer be an admin or active.   This is a **premium** feature.
         * @param {AdminApiAdminEditUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEditUser(requestParameters, options) {
            return localVarFp.adminEditUser(requestParameters.userId, requestParameters.patchedUserAdminUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Fills the remaining empty seats of the license with the first users that are found.
         * @param {AdminApiAdminFillRemainingSeatsOfLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminFillRemainingSeatsOfLicense(requestParameters, options) {
            return localVarFp.adminFillRemainingSeatsOfLicense(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with detailed information about the license related to the provided parameter.
         * @param {AdminApiAdminGetLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetLicense(requestParameters, options) {
            return localVarFp.adminGetLicense(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows staff to impersonate another user by requesting a JWT token and user object. The requesting user must have staff access in order to do this. It\'s not possible to impersonate a superuser or staff.  This is a **premium** feature.
         * @param {AdminApiAdminImpersonateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminImpersonateUser(requestParameters, options) {
            return localVarFp.adminImpersonateUser(requestParameters.baserowImpersonateAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint checks with the authority if the license needs to be updated. It also checks if the license is operating within its limits and might take action on that. It could also happen that the license has been deleted because there is an instance id mismatch or because it\'s invalid. In that case a `204` status code is returned.
         * @param {AdminApiAdminLicenseCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseCheck(requestParameters, options) {
            return localVarFp.adminLicenseCheck(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to lookup users that can be added to a  license. Users that are already in the license are not returned here. Optionally a `search` query parameter can be provided to filter the results.
         * @param {AdminApiAdminLicenseLookupUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenseLookupUsers(requestParameters, options) {
            return localVarFp.adminLicenseLookupUsers(requestParameters.id, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the valid licenses that are registered to this instance. A premium license can be used to unlock the premium features for a fixed amount of users. An enterprise license can similarly be used to unlock enterpise features. More information about self hosted licenses can be found on our pricing page https://baserow.io/pricing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLicenses(options) {
            return localVarFp.adminLicenses(options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [admin_list_workspaces](#tag/Admin/operation/admin_list_workspaces).**  **Support for this endpoint will end in 2024.**   Returns all groups with detailed information on each group, if the requesting user is staff.  This is a **premium** feature.
         * @param {AdminApiAdminListGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        adminListGroups(requestParameters = {}, options) {
            return localVarFp.adminListGroups(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all users with detailed information on each user, if the requesting user is staff.   This is a **premium** feature.
         * @param {AdminApiAdminListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListUsers(requestParameters = {}, options) {
            return localVarFp.adminListUsers(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all workspaces with detailed information on each workspace, if the requesting user is staff.  This is a **premium** feature.
         * @param {AdminApiAdminListWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListWorkspaces(requestParameters = {}, options) {
            return localVarFp.adminListWorkspaces(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a new license. After registering you can assign users to the license that will be able to use the license\'s features while the license is active. If an existing license with the same `license_id` already exists and the provided license has been issued later than that one, the existing one will be upgraded.
         * @param {AdminApiAdminRegisterLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegisterLicense(requestParameters, options) {
            return localVarFp.adminRegisterLicense(requestParameters.registerLicense, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes all the users that are on the license. This will empty all the seats.
         * @param {AdminApiAdminRemoveAllUsersFromLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveAllUsersFromLicense(requestParameters, options) {
            return localVarFp.adminRemoveAllUsersFromLicense(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the existing license related to the provided parameter. If the license is active, then all the users that are using the license will lose access to the features granted by that license.
         * @param {AdminApiAdminRemoveLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveLicense(requestParameters, options) {
            return localVarFp.adminRemoveLicense(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the user related to the provided parameter and to the license related to the parameter. This only happens if the user is on the license, otherwise nothing will happen.
         * @param {AdminApiAdminRemoveUserFromLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRemoveUserFromLicense(requestParameters, options) {
            return localVarFp.adminRemoveUserFromLicense(requestParameters.id, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
class AdminApi extends BaseAPI {
    /**
     * Adds the user related to the provided parameter and to the license related to the parameter. This only happens if there are enough seats left on the license and if the user is not already on the license.
     * @param {AdminApiAdminAddUserToLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminAddUserToLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminAddUserToLicense(requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and returns a new user if the requesting user is staff. This works even if new signups are disabled.   This is a **premium** feature.
     * @param {AdminApiAdminCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminCreateUser(requestParameters, options) {
        return AdminApiFp(this.configuration).adminCreateUser(requestParameters.userAdminCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the new and active users for the last 24 hours, 7 days and 30 days. The `previous_` values are the values of the period before, so for example `previous_new_users_last_24_hours` are the new users that signed up from 48 to 24 hours ago. It can be used to calculate an increase or decrease in the amount of signups. A list of the new and active users for every day for the last 30 days is also included.  This is a **premium** feature.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminDashboard(options) {
        return AdminApiFp(this.configuration).adminDashboard(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [admin_delete_workspace](#tag/Admin/operation/admin_delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes the specified group and the applications inside that group, if the requesting user is staff.   This is a **premium** feature.
     * @param {AdminApiAdminDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminDeleteGroup(requestParameters, options) {
        return AdminApiFp(this.configuration).adminDeleteGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the specified user, if the requesting user has admin permissions. You cannot delete yourself.   This is a **premium** feature.
     * @param {AdminApiAdminDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminDeleteUser(requestParameters, options) {
        return AdminApiFp(this.configuration).adminDeleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the specified workspace and the applications inside that workspace, if the requesting user is staff.   This is a **premium** feature.
     * @param {AdminApiAdminDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminDeleteWorkspace(requestParameters, options) {
        return AdminApiFp(this.configuration).adminDeleteWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates specified user attributes and returns the updated user if the requesting user is staff. You cannot update yourself to no longer be an admin or active.   This is a **premium** feature.
     * @param {AdminApiAdminEditUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminEditUser(requestParameters, options) {
        return AdminApiFp(this.configuration).adminEditUser(requestParameters.userId, requestParameters.patchedUserAdminUpdate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fills the remaining empty seats of the license with the first users that are found.
     * @param {AdminApiAdminFillRemainingSeatsOfLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminFillRemainingSeatsOfLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminFillRemainingSeatsOfLicense(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with detailed information about the license related to the provided parameter.
     * @param {AdminApiAdminGetLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminGetLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminGetLicense(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows staff to impersonate another user by requesting a JWT token and user object. The requesting user must have staff access in order to do this. It\'s not possible to impersonate a superuser or staff.  This is a **premium** feature.
     * @param {AdminApiAdminImpersonateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminImpersonateUser(requestParameters, options) {
        return AdminApiFp(this.configuration).adminImpersonateUser(requestParameters.baserowImpersonateAuthToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint checks with the authority if the license needs to be updated. It also checks if the license is operating within its limits and might take action on that. It could also happen that the license has been deleted because there is an instance id mismatch or because it\'s invalid. In that case a `204` status code is returned.
     * @param {AdminApiAdminLicenseCheckRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminLicenseCheck(requestParameters, options) {
        return AdminApiFp(this.configuration).adminLicenseCheck(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint can be used to lookup users that can be added to a  license. Users that are already in the license are not returned here. Optionally a `search` query parameter can be provided to filter the results.
     * @param {AdminApiAdminLicenseLookupUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminLicenseLookupUsers(requestParameters, options) {
        return AdminApiFp(this.configuration).adminLicenseLookupUsers(requestParameters.id, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the valid licenses that are registered to this instance. A premium license can be used to unlock the premium features for a fixed amount of users. An enterprise license can similarly be used to unlock enterpise features. More information about self hosted licenses can be found on our pricing page https://baserow.io/pricing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminLicenses(options) {
        return AdminApiFp(this.configuration).adminLicenses(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [admin_list_workspaces](#tag/Admin/operation/admin_list_workspaces).**  **Support for this endpoint will end in 2024.**   Returns all groups with detailed information on each group, if the requesting user is staff.  This is a **premium** feature.
     * @param {AdminApiAdminListGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminListGroups(requestParameters = {}, options) {
        return AdminApiFp(this.configuration).adminListGroups(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all users with detailed information on each user, if the requesting user is staff.   This is a **premium** feature.
     * @param {AdminApiAdminListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminListUsers(requestParameters = {}, options) {
        return AdminApiFp(this.configuration).adminListUsers(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all workspaces with detailed information on each workspace, if the requesting user is staff.  This is a **premium** feature.
     * @param {AdminApiAdminListWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminListWorkspaces(requestParameters = {}, options) {
        return AdminApiFp(this.configuration).adminListWorkspaces(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers a new license. After registering you can assign users to the license that will be able to use the license\'s features while the license is active. If an existing license with the same `license_id` already exists and the provided license has been issued later than that one, the existing one will be upgraded.
     * @param {AdminApiAdminRegisterLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminRegisterLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminRegisterLicense(requestParameters.registerLicense, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes all the users that are on the license. This will empty all the seats.
     * @param {AdminApiAdminRemoveAllUsersFromLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminRemoveAllUsersFromLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminRemoveAllUsersFromLicense(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes the existing license related to the provided parameter. If the license is active, then all the users that are using the license will lose access to the features granted by that license.
     * @param {AdminApiAdminRemoveLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminRemoveLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminRemoveLicense(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes the user related to the provided parameter and to the license related to the parameter. This only happens if the user is on the license, otherwise nothing will happen.
     * @param {AdminApiAdminRemoveUserFromLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    adminRemoveUserFromLicense(requestParameters, options) {
        return AdminApiFp(this.configuration).adminRemoveUserFromLicense(requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
const ApplicationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes an application if the authorized user is in the application\'s workspace. All the related children are also going to be deleted. For example in case of a database application all the underlying tables, fields, views and rows are going to be deleted.
         * @param {number} applicationId Deletes the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: (applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (applicationId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId);
            const localVarPath = `/applications/{application_id}/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicate an application if the authorized user is in the application\'s workspace. All the related children are also going to be duplicated. For example in case of a database application all the underlying tables, fields, views and rows are going to be duplicated.
         * @param {number} applicationId The id of the application to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateApplicationAsync: (applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (applicationId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('duplicateApplicationAsync', 'applicationId', applicationId);
            const localVarPath = `/applications/{application_id}/duplicate/async/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_application](#tag/Applications/operation/workspace_create_application).**  **Support for this endpoint will end in 2024.**   Creates a new application based on the provided type. The newly created application is going to be added to the group related to the provided `group_id` parameter. If the authorized user does not belong to the group an error will be returned.
         * @param {number} groupId Creates an application for the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {ApplicationBaseApplicationCreatePolymorphic} [applicationBaseApplicationCreatePolymorphic]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateApplication: (groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, applicationBaseApplicationCreatePolymorphic_1, ...args_1) => __awaiter(this, [groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, applicationBaseApplicationCreatePolymorphic_1, ...args_1], void 0, function* (groupId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupCreateApplication', 'groupId', groupId);
            const localVarPath = `/applications/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(applicationBaseApplicationCreatePolymorphic, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_applications](#tag/Applications/operation/workspace_list_applications).**  **Support for this endpoint will end in 2024.**   Lists all the applications of the group related to the provided `group_id` parameter if the authorized user is in that group. If the group is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single group.
         * @param {number} groupId Returns only applications that are in the group related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListApplications: (groupId_1, ...args_1) => __awaiter(this, [groupId_1, ...args_1], void 0, function* (groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupListApplications', 'groupId', groupId);
            const localVarPath = `/applications/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_order_applications](#tag/Applications/operation/workspace_order_applications).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} groupId Updates the order of the applications in the group related to the provided value.
         * @param {OrderApplications} orderApplications
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupOrderApplications: (groupId_1, orderApplications_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [groupId_1, orderApplications_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (groupId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupOrderApplications', 'groupId', groupId);
            // verify required parameter 'orderApplications' is not null or undefined
            assertParamExists('groupOrderApplications', 'orderApplications', orderApplications);
            const localVarPath = `/applications/group/{group_id}/order/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderApplications, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the applications that the authorized user has access to. The properties that belong to the application can differ per type. An application always belongs to a single workspace. All the applications of the workspaces that the user has access to are going to be listed here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllApplications: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/applications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing application related to the provided `application_id` param if the authorized user is in the application\'s workspace. It is not possible to change the type, but properties like the name can be changed.
         * @param {number} applicationId Updates the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedApplicationBaseApplicationUpdatePolymorphic} [patchedApplicationBaseApplicationUpdatePolymorphic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: (applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedApplicationBaseApplicationUpdatePolymorphic_1, ...args_1) => __awaiter(this, [applicationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedApplicationBaseApplicationUpdatePolymorphic_1, ...args_1], void 0, function* (applicationId, clientSessionId, clientUndoRedoActionGroupId, patchedApplicationBaseApplicationUpdatePolymorphic, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId);
            const localVarPath = `/applications/{application_id}/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedApplicationBaseApplicationUpdatePolymorphic, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new application based on the provided type. The newly created application is going to be added to the workspace related to the provided `workspace_id` parameter. If the authorized user does not belong to the workspace an error will be returned.
         * @param {number} workspaceId Creates an application for the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {ApplicationBaseApplicationCreatePolymorphic} [applicationBaseApplicationCreatePolymorphic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateApplication: (workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, applicationBaseApplicationCreatePolymorphic_1, ...args_1) => __awaiter(this, [workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, applicationBaseApplicationCreatePolymorphic_1, ...args_1], void 0, function* (workspaceId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceCreateApplication', 'workspaceId', workspaceId);
            const localVarPath = `/applications/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(applicationBaseApplicationCreatePolymorphic, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the requested application if the authorized user is in the application\'s workspace. The properties that belong to the application can differ per type.
         * @param {number} applicationId Returns the application related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetApplication: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('workspaceGetApplication', 'applicationId', applicationId);
            const localVarPath = `/applications/{application_id}/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the applications of the workspace related to the provided `workspace_id` parameter if the authorized user is in that workspace. If theworkspace is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single workspace.
         * @param {number} workspaceId Returns only applications that are in the workspace related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListApplications: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceListApplications', 'workspaceId', workspaceId);
            const localVarPath = `/applications/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} workspaceId Updates the order of the applications in the workspace related to the provided value.
         * @param {OrderApplications} orderApplications
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceOrderApplications: (workspaceId_1, orderApplications_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [workspaceId_1, orderApplications_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (workspaceId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceOrderApplications', 'workspaceId', workspaceId);
            // verify required parameter 'orderApplications' is not null or undefined
            assertParamExists('workspaceOrderApplications', 'orderApplications', orderApplications);
            const localVarPath = `/applications/workspace/{workspace_id}/order/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderApplications, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ApplicationsApi - functional programming interface
 * @export
 */
const ApplicationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Deletes an application if the authorized user is in the application\'s workspace. All the related children are also going to be deleted. For example in case of a database application all the underlying tables, fields, views and rows are going to be deleted.
         * @param {number} applicationId Deletes the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplication(applicationId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.deleteApplication']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Duplicate an application if the authorized user is in the application\'s workspace. All the related children are also going to be duplicated. For example in case of a database application all the underlying tables, fields, views and rows are going to be duplicated.
         * @param {number} applicationId The id of the application to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateApplicationAsync(applicationId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateApplicationAsync(applicationId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.duplicateApplicationAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_application](#tag/Applications/operation/workspace_create_application).**  **Support for this endpoint will end in 2024.**   Creates a new application based on the provided type. The newly created application is going to be added to the group related to the provided `group_id` parameter. If the authorized user does not belong to the group an error will be returned.
         * @param {number} groupId Creates an application for the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {ApplicationBaseApplicationCreatePolymorphic} [applicationBaseApplicationCreatePolymorphic]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateApplication(groupId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupCreateApplication(groupId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.groupCreateApplication']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_applications](#tag/Applications/operation/workspace_list_applications).**  **Support for this endpoint will end in 2024.**   Lists all the applications of the group related to the provided `group_id` parameter if the authorized user is in that group. If the group is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single group.
         * @param {number} groupId Returns only applications that are in the group related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListApplications(groupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupListApplications(groupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.groupListApplications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_order_applications](#tag/Applications/operation/workspace_order_applications).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} groupId Updates the order of the applications in the group related to the provided value.
         * @param {OrderApplications} orderApplications
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupOrderApplications(groupId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupOrderApplications(groupId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.groupOrderApplications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the applications that the authorized user has access to. The properties that belong to the application can differ per type. An application always belongs to a single workspace. All the applications of the workspaces that the user has access to are going to be listed here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllApplications(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAllApplications(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.listAllApplications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing application related to the provided `application_id` param if the authorized user is in the application\'s workspace. It is not possible to change the type, but properties like the name can be changed.
         * @param {number} applicationId Updates the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedApplicationBaseApplicationUpdatePolymorphic} [patchedApplicationBaseApplicationUpdatePolymorphic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId, clientSessionId, clientUndoRedoActionGroupId, patchedApplicationBaseApplicationUpdatePolymorphic, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplication(applicationId, clientSessionId, clientUndoRedoActionGroupId, patchedApplicationBaseApplicationUpdatePolymorphic, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.updateApplication']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new application based on the provided type. The newly created application is going to be added to the workspace related to the provided `workspace_id` parameter. If the authorized user does not belong to the workspace an error will be returned.
         * @param {number} workspaceId Creates an application for the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {ApplicationBaseApplicationCreatePolymorphic} [applicationBaseApplicationCreatePolymorphic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateApplication(workspaceId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceCreateApplication(workspaceId, clientSessionId, clientUndoRedoActionGroupId, applicationBaseApplicationCreatePolymorphic, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.workspaceCreateApplication']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the requested application if the authorized user is in the application\'s workspace. The properties that belong to the application can differ per type.
         * @param {number} applicationId Returns the application related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetApplication(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceGetApplication(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.workspaceGetApplication']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the applications of the workspace related to the provided `workspace_id` parameter if the authorized user is in that workspace. If theworkspace is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single workspace.
         * @param {number} workspaceId Returns only applications that are in the workspace related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListApplications(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceListApplications(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.workspaceListApplications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} workspaceId Updates the order of the applications in the workspace related to the provided value.
         * @param {OrderApplications} orderApplications
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceOrderApplications(workspaceId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceOrderApplications(workspaceId, orderApplications, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['ApplicationsApi.workspaceOrderApplications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ApplicationsApi - factory interface
 * @export
 */
const ApplicationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ApplicationsApiFp(configuration);
    return {
        /**
         * Deletes an application if the authorized user is in the application\'s workspace. All the related children are also going to be deleted. For example in case of a database application all the underlying tables, fields, views and rows are going to be deleted.
         * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(requestParameters, options) {
            return localVarFp.deleteApplication(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicate an application if the authorized user is in the application\'s workspace. All the related children are also going to be duplicated. For example in case of a database application all the underlying tables, fields, views and rows are going to be duplicated.
         * @param {ApplicationsApiDuplicateApplicationAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateApplicationAsync(requestParameters, options) {
            return localVarFp.duplicateApplicationAsync(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_application](#tag/Applications/operation/workspace_create_application).**  **Support for this endpoint will end in 2024.**   Creates a new application based on the provided type. The newly created application is going to be added to the group related to the provided `group_id` parameter. If the authorized user does not belong to the group an error will be returned.
         * @param {ApplicationsApiGroupCreateApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateApplication(requestParameters, options) {
            return localVarFp.groupCreateApplication(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.applicationBaseApplicationCreatePolymorphic, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_applications](#tag/Applications/operation/workspace_list_applications).**  **Support for this endpoint will end in 2024.**   Lists all the applications of the group related to the provided `group_id` parameter if the authorized user is in that group. If the group is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single group.
         * @param {ApplicationsApiGroupListApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListApplications(requestParameters, options) {
            return localVarFp.groupListApplications(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_order_applications](#tag/Applications/operation/workspace_order_applications).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {ApplicationsApiGroupOrderApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupOrderApplications(requestParameters, options) {
            return localVarFp.groupOrderApplications(requestParameters.groupId, requestParameters.orderApplications, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the applications that the authorized user has access to. The properties that belong to the application can differ per type. An application always belongs to a single workspace. All the applications of the workspaces that the user has access to are going to be listed here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllApplications(options) {
            return localVarFp.listAllApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing application related to the provided `application_id` param if the authorized user is in the application\'s workspace. It is not possible to change the type, but properties like the name can be changed.
         * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(requestParameters, options) {
            return localVarFp.updateApplication(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedApplicationBaseApplicationUpdatePolymorphic, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new application based on the provided type. The newly created application is going to be added to the workspace related to the provided `workspace_id` parameter. If the authorized user does not belong to the workspace an error will be returned.
         * @param {ApplicationsApiWorkspaceCreateApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateApplication(requestParameters, options) {
            return localVarFp.workspaceCreateApplication(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.applicationBaseApplicationCreatePolymorphic, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested application if the authorized user is in the application\'s workspace. The properties that belong to the application can differ per type.
         * @param {ApplicationsApiWorkspaceGetApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetApplication(requestParameters, options) {
            return localVarFp.workspaceGetApplication(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the applications of the workspace related to the provided `workspace_id` parameter if the authorized user is in that workspace. If theworkspace is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single workspace.
         * @param {ApplicationsApiWorkspaceListApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListApplications(requestParameters, options) {
            return localVarFp.workspaceListApplications(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {ApplicationsApiWorkspaceOrderApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceOrderApplications(requestParameters, options) {
            return localVarFp.workspaceOrderApplications(requestParameters.workspaceId, requestParameters.orderApplications, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
class ApplicationsApi extends BaseAPI {
    /**
     * Deletes an application if the authorized user is in the application\'s workspace. All the related children are also going to be deleted. For example in case of a database application all the underlying tables, fields, views and rows are going to be deleted.
     * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    deleteApplication(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).deleteApplication(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicate an application if the authorized user is in the application\'s workspace. All the related children are also going to be duplicated. For example in case of a database application all the underlying tables, fields, views and rows are going to be duplicated.
     * @param {ApplicationsApiDuplicateApplicationAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    duplicateApplicationAsync(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).duplicateApplicationAsync(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_application](#tag/Applications/operation/workspace_create_application).**  **Support for this endpoint will end in 2024.**   Creates a new application based on the provided type. The newly created application is going to be added to the group related to the provided `group_id` parameter. If the authorized user does not belong to the group an error will be returned.
     * @param {ApplicationsApiGroupCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    groupCreateApplication(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).groupCreateApplication(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.applicationBaseApplicationCreatePolymorphic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_applications](#tag/Applications/operation/workspace_list_applications).**  **Support for this endpoint will end in 2024.**   Lists all the applications of the group related to the provided `group_id` parameter if the authorized user is in that group. If the group is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single group.
     * @param {ApplicationsApiGroupListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    groupListApplications(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).groupListApplications(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_order_applications](#tag/Applications/operation/workspace_order_applications).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order of the not provided tables will be set to `0`.
     * @param {ApplicationsApiGroupOrderApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    groupOrderApplications(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).groupOrderApplications(requestParameters.groupId, requestParameters.orderApplications, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the applications that the authorized user has access to. The properties that belong to the application can differ per type. An application always belongs to a single workspace. All the applications of the workspaces that the user has access to are going to be listed here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    listAllApplications(options) {
        return ApplicationsApiFp(this.configuration).listAllApplications(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing application related to the provided `application_id` param if the authorized user is in the application\'s workspace. It is not possible to change the type, but properties like the name can be changed.
     * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    updateApplication(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).updateApplication(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedApplicationBaseApplicationUpdatePolymorphic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new application based on the provided type. The newly created application is going to be added to the workspace related to the provided `workspace_id` parameter. If the authorized user does not belong to the workspace an error will be returned.
     * @param {ApplicationsApiWorkspaceCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    workspaceCreateApplication(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).workspaceCreateApplication(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.applicationBaseApplicationCreatePolymorphic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the requested application if the authorized user is in the application\'s workspace. The properties that belong to the application can differ per type.
     * @param {ApplicationsApiWorkspaceGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    workspaceGetApplication(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).workspaceGetApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the applications of the workspace related to the provided `workspace_id` parameter if the authorized user is in that workspace. If theworkspace is related to a template, then this endpoint will be publicly accessible. The properties that belong to the application can differ per type. An application always belongs to a single workspace.
     * @param {ApplicationsApiWorkspaceListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    workspaceListApplications(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).workspaceListApplications(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the order of the provided application ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
     * @param {ApplicationsApiWorkspaceOrderApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    workspaceOrderApplications(requestParameters, options) {
        return ApplicationsApiFp(this.configuration).workspaceOrderApplications(requestParameters.workspaceId, requestParameters.orderApplications, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AuditLogApi - axios parameter creator
 * @export
 */
const AuditLogApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {SingleAuditLogExportJobRequest} [singleAuditLogExportJobRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport: (clientSessionId_1, singleAuditLogExportJobRequest_1, ...args_1) => __awaiter(this, [clientSessionId_1, singleAuditLogExportJobRequest_1, ...args_1], void 0, function* (clientSessionId, singleAuditLogExportJobRequest, options = {}) {
            const localVarPath = `/admin/audit-log/export/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(singleAuditLogExportJobRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {SingleAuditLogExportJobRequest} [singleAuditLogExportJobRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport2: (clientSessionId_1, singleAuditLogExportJobRequest_1, ...args_1) => __awaiter(this, [clientSessionId_1, singleAuditLogExportJobRequest_1, ...args_1], void 0, function* (clientSessionId, singleAuditLogExportJobRequest, options = {}) {
            const localVarPath = `/audit-log/export/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(singleAuditLogExportJobRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {string} [search] If provided only action_types with name that match the query will be returned.
         * @param {number} [workspaceId] Return action types related to the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes: (search_1, workspaceId_1, ...args_1) => __awaiter(this, [search_1, workspaceId_1, ...args_1], void 0, function* (search, workspaceId, options = {}) {
            const localVarPath = `/admin/audit-log/action-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {string} [search] If provided only action_types with name that match the query will be returned.
         * @param {number} [workspaceId] Return action types related to the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes2: (search_1, workspaceId_1, ...args_1) => __awaiter(this, [search_1, workspaceId_1, ...args_1], void 0, function* (search, workspaceId, options = {}) {
            const localVarPath = `/audit-log/action-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {string} [actionType] Filter the audit log entries by action type.
         * @param {string} [fromTimestamp] The ISO timestamp to filter the audit log entries from.
         * @param {number} [page] Defines which page should be returned.
         * @param {number} [size] Defines how many audit log entries should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;user, workspace, type, timestamp, ip_address&#x60;. For example &#x60;sorts&#x3D;-user,-workspace&#x60; will sort the audit log entries first by descending user and then ascending workspace. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {string} [toTimestamp] The ISO timestamp to filter the audit log entries to.
         * @param {number} [userId] Filter the audit log entries by user id.
         * @param {number} [workspaceId] Filter the audit log entries by workspace id. This filter works only for the admin audit log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList: (actionType_1, fromTimestamp_1, page_1, size_1, sorts_1, toTimestamp_1, userId_1, workspaceId_1, ...args_1) => __awaiter(this, [actionType_1, fromTimestamp_1, page_1, size_1, sorts_1, toTimestamp_1, userId_1, workspaceId_1, ...args_1], void 0, function* (actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options = {}) {
            const localVarPath = `/admin/audit-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }
            if (fromTimestamp !== undefined) {
                localVarQueryParameter['from_timestamp'] = fromTimestamp;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            if (toTimestamp !== undefined) {
                localVarQueryParameter['to_timestamp'] = toTimestamp;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {string} [actionType] Filter the audit log entries by action type.
         * @param {string} [fromTimestamp] The ISO timestamp to filter the audit log entries from.
         * @param {number} [page] Defines which page should be returned.
         * @param {number} [size] Defines how many audit log entries should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;user, workspace, type, timestamp, ip_address&#x60;. For example &#x60;sorts&#x3D;-user,-workspace&#x60; will sort the audit log entries first by descending user and then ascending workspace. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {string} [toTimestamp] The ISO timestamp to filter the audit log entries to.
         * @param {number} [userId] Filter the audit log entries by user id.
         * @param {number} [workspaceId] Filter the audit log entries by workspace id. This filter works only for the admin audit log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList2: (actionType_1, fromTimestamp_1, page_1, size_1, sorts_1, toTimestamp_1, userId_1, workspaceId_1, ...args_1) => __awaiter(this, [actionType_1, fromTimestamp_1, page_1, size_1, sorts_1, toTimestamp_1, userId_1, workspaceId_1, ...args_1], void 0, function* (actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options = {}) {
            const localVarPath = `/audit-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }
            if (fromTimestamp !== undefined) {
                localVarQueryParameter['from_timestamp'] = fromTimestamp;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            if (toTimestamp !== undefined) {
                localVarQueryParameter['to_timestamp'] = toTimestamp;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with email that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {number} [workspaceId] Return users belonging to the given workspace_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers: (page_1, search_1, size_1, workspaceId_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, workspaceId_1, ...args_1], void 0, function* (page, search, size, workspaceId, options = {}) {
            const localVarPath = `/admin/audit-log/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with email that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {number} [workspaceId] Return users belonging to the given workspace_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers2: (page_1, search_1, size_1, workspaceId_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, workspaceId_1, ...args_1], void 0, function* (page, search, size, workspaceId, options = {}) {
            const localVarPath = `/audit-log/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces: (page_1, search_1, size_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, ...args_1], void 0, function* (page, search, size, options = {}) {
            const localVarPath = `/admin/audit-log/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces2: (page_1, search_1, size_1, ...args_1) => __awaiter(this, [page_1, search_1, size_1, ...args_1], void 0, function* (page, search, size, options = {}) {
            const localVarPath = `/audit-log/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AuditLogApi - functional programming interface
 * @export
 */
const AuditLogApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuditLogApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {SingleAuditLogExportJobRequest} [singleAuditLogExportJobRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport(clientSessionId, singleAuditLogExportJobRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.asyncAuditLogExport(clientSessionId, singleAuditLogExportJobRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.asyncAuditLogExport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {SingleAuditLogExportJobRequest} [singleAuditLogExportJobRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport2(clientSessionId, singleAuditLogExportJobRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.asyncAuditLogExport2(clientSessionId, singleAuditLogExportJobRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.asyncAuditLogExport2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {string} [search] If provided only action_types with name that match the query will be returned.
         * @param {number} [workspaceId] Return action types related to the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes(search, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogActionTypes(search, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogActionTypes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {string} [search] If provided only action_types with name that match the query will be returned.
         * @param {number} [workspaceId] Return action types related to the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes2(search, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogActionTypes2(search, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogActionTypes2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {string} [actionType] Filter the audit log entries by action type.
         * @param {string} [fromTimestamp] The ISO timestamp to filter the audit log entries from.
         * @param {number} [page] Defines which page should be returned.
         * @param {number} [size] Defines how many audit log entries should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;user, workspace, type, timestamp, ip_address&#x60;. For example &#x60;sorts&#x3D;-user,-workspace&#x60; will sort the audit log entries first by descending user and then ascending workspace. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {string} [toTimestamp] The ISO timestamp to filter the audit log entries to.
         * @param {number} [userId] Filter the audit log entries by user id.
         * @param {number} [workspaceId] Filter the audit log entries by workspace id. This filter works only for the admin audit log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList(actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogList(actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {string} [actionType] Filter the audit log entries by action type.
         * @param {string} [fromTimestamp] The ISO timestamp to filter the audit log entries from.
         * @param {number} [page] Defines which page should be returned.
         * @param {number} [size] Defines how many audit log entries should be returned per page.
         * @param {string} [sorts] A comma separated string of attributes to sort by, each attribute must be prefixed with &#x60;+&#x60; for a descending sort or a &#x60;-&#x60; for an ascending sort. The accepted attribute names are: &#x60;user, workspace, type, timestamp, ip_address&#x60;. For example &#x60;sorts&#x3D;-user,-workspace&#x60; will sort the audit log entries first by descending user and then ascending workspace. A sortparameter with multiple instances of the same sort attribute will respond with the ERROR_INVALID_SORT_ATTRIBUTE error.
         * @param {string} [toTimestamp] The ISO timestamp to filter the audit log entries to.
         * @param {number} [userId] Filter the audit log entries by user id.
         * @param {number} [workspaceId] Filter the audit log entries by workspace id. This filter works only for the admin audit log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList2(actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogList2(actionType, fromTimestamp, page, size, sorts, toTimestamp, userId, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogList2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with email that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {number} [workspaceId] Return users belonging to the given workspace_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers(page, search, size, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogUsers(page, search, size, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only users with email that match the query will be returned.
         * @param {number} [size] Defines how many users should be returned per page.
         * @param {number} [workspaceId] Return users belonging to the given workspace_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers2(page, search, size, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogUsers2(page, search, size, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogUsers2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces(page, search, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogWorkspaces(page, search, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogWorkspaces']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {number} [page] Defines which page should be returned.
         * @param {string} [search] If provided only workspaces with name that match the query will be returned.
         * @param {number} [size] Defines how many workspaces should be returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces2(page, search, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.auditLogWorkspaces2(page, search, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuditLogApi.auditLogWorkspaces2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AuditLogApi - factory interface
 * @export
 */
const AuditLogApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuditLogApiFp(configuration);
    return {
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {AuditLogApiAsyncAuditLogExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport(requestParameters = {}, options) {
            return localVarFp.asyncAuditLogExport(requestParameters.clientSessionId, requestParameters.singleAuditLogExportJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
         * @param {AuditLogApiAsyncAuditLogExport2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncAuditLogExport2(requestParameters = {}, options) {
            return localVarFp.asyncAuditLogExport2(requestParameters.clientSessionId, requestParameters.singleAuditLogExportJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogActionTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes(requestParameters = {}, options) {
            return localVarFp.auditLogActionTypes(requestParameters.search, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogActionTypes2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogActionTypes2(requestParameters = {}, options) {
            return localVarFp.auditLogActionTypes2(requestParameters.search, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList(requestParameters = {}, options) {
            return localVarFp.auditLogList(requestParameters.actionType, requestParameters.fromTimestamp, requestParameters.page, requestParameters.size, requestParameters.sorts, requestParameters.toTimestamp, requestParameters.userId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogList2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogList2(requestParameters = {}, options) {
            return localVarFp.auditLogList2(requestParameters.actionType, requestParameters.fromTimestamp, requestParameters.page, requestParameters.size, requestParameters.sorts, requestParameters.toTimestamp, requestParameters.userId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers(requestParameters = {}, options) {
            return localVarFp.auditLogUsers(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogUsers2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogUsers2(requestParameters = {}, options) {
            return localVarFp.auditLogUsers2(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces(requestParameters = {}, options) {
            return localVarFp.auditLogWorkspaces(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
         * @param {AuditLogApiAuditLogWorkspaces2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogWorkspaces2(requestParameters = {}, options) {
            return localVarFp.auditLogWorkspaces2(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
class AuditLogApi extends BaseAPI {
    /**
     * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
     * @param {AuditLogApiAsyncAuditLogExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    asyncAuditLogExport(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).asyncAuditLogExport(requestParameters.clientSessionId, requestParameters.singleAuditLogExportJobRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a job to export the filtered audit log to a CSV file.  This is a **enterprise** feature.
     * @param {AuditLogApiAsyncAuditLogExport2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    asyncAuditLogExport2(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).asyncAuditLogExport2(requestParameters.clientSessionId, requestParameters.singleAuditLogExportJobRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogActionTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogActionTypes(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogActionTypes(requestParameters.search, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all distinct action types related to an audit log entry.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogActionTypes2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogActionTypes2(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogActionTypes2(requestParameters.search, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogList(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogList(requestParameters.actionType, requestParameters.fromTimestamp, requestParameters.page, requestParameters.size, requestParameters.sorts, requestParameters.toTimestamp, requestParameters.userId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all audit log entries for the given workspace id.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogList2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogList2(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogList2(requestParameters.actionType, requestParameters.fromTimestamp, requestParameters.page, requestParameters.size, requestParameters.sorts, requestParameters.toTimestamp, requestParameters.userId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogUsers(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogUsers(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all users that have performed an action in the audit log.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogUsers2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogUsers2(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogUsers2(requestParameters.page, requestParameters.search, requestParameters.size, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogWorkspaces(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogWorkspaces(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all distinct workspace names related to an audit log entry.  This is a **enterprise** feature.
     * @param {AuditLogApiAuditLogWorkspaces2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    auditLogWorkspaces2(requestParameters = {}, options) {
        return AuditLogApiFp(this.configuration).auditLogWorkspaces2(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Return the correct redirect_url to initiate the SSO SAML login. It needs an email address if multiple SAML providers are configured otherwise the only configured SAML provider signup URL will be returned.
         * @param {string} [email] The email address of the user that want to sign in using SAML.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future.
         * @param {string} [language] An ISO 639 language code (with optional variant) selected by the user. Ex: en-GB.
         * @param {string} [original] The url to which the user should be redirected after a successful login.
         * @param {string} [workspaceInvitationToken] If provided and valid, the user accepts the workspace invitation and will have access to the workspace after login or signing up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderLoginUrl: (email_1, groupInvitationToken_1, language_1, original_1, workspaceInvitationToken_1, ...args_1) => __awaiter(this, [email_1, groupInvitationToken_1, language_1, original_1, workspaceInvitationToken_1, ...args_1], void 0, function* (email, groupInvitationToken, language, original, workspaceInvitationToken, options = {}) {
            const localVarPath = `/sso/saml/login-url/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (groupInvitationToken !== undefined) {
                localVarQueryParameter['group_invitation_token'] = groupInvitationToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }
            if (workspaceInvitationToken !== undefined) {
                localVarQueryParameter['workspace_invitation_token'] = workspaceInvitationToken;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Complete the SAML authentication flow by validating the SAML response. Sign in the user if already exists in Baserow or create a new one otherwise. Once authenticated, the user will be redirected to the original URL they were trying to access. If the response is invalid, the user will be redirected to an error page with a specific error message.It accepts the language code and the workspace invitation token as query parameters if provided.
         * @param {SAMLResponse} sAMLResponse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlAcsUrl: (sAMLResponse_1, ...args_1) => __awaiter(this, [sAMLResponse_1, ...args_1], void 0, function* (sAMLResponse, options = {}) {
            // verify required parameter 'sAMLResponse' is not null or undefined
            assertParamExists('authProviderSamlAcsUrl', 'sAMLResponse', sAMLResponse);
            const localVarPath = `/sso/saml/acs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(sAMLResponse, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is the endpoint that is called when the user wants to initiate a SSO SAML login from Baserow (the service provider). The user will be redirected to the SAML identity provider (IdP) where the user can authenticate. Once logged in in the IdP, the user will be redirected back to the assertion consumer service endpoint (ACS) where the SAML response will be validated and a new JWT session token will be provided to work with Baserow APIs.
         * @param {string} [email] The email address of the user that want to sign in using SAML.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future
         * @param {string} [language] An ISO 639 language code (with optional variant) selected by the user. Ex: en-GB.
         * @param {string} [original] The url to which the user should be redirected after a successful login or sign up.
         * @param {string} [workspaceInvitationToken] If provided and valid, the user accepts the workspace invitation and will have access to the workspace after login or signing up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlSpLogin: (email_1, groupInvitationToken_1, language_1, original_1, workspaceInvitationToken_1, ...args_1) => __awaiter(this, [email_1, groupInvitationToken_1, language_1, original_1, workspaceInvitationToken_1, ...args_1], void 0, function* (email, groupInvitationToken, language, original, workspaceInvitationToken, options = {}) {
            const localVarPath = `/sso/saml/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (groupInvitationToken !== undefined) {
                localVarQueryParameter['group_invitation_token'] = groupInvitationToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }
            if (workspaceInvitationToken !== undefined) {
                localVarQueryParameter['workspace_invitation_token'] = workspaceInvitationToken;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthProvider: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/auth-provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete an authentication provider.
         * @param {number} authProviderId The authentication provider id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthProvider: (authProviderId_1, ...args_1) => __awaiter(this, [authProviderId_1, ...args_1], void 0, function* (authProviderId, options = {}) {
            // verify required parameter 'authProviderId' is not null or undefined
            assertParamExists('deleteAuthProvider', 'authProviderId', authProviderId);
            const localVarPath = `/admin/auth-provider/{auth_provider_id}/`
                .replace(`{${"auth_provider_id"}}`, encodeURIComponent(String(authProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get an authentication provider.
         * @param {number} authProviderId The authentication provider id to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProvider: (authProviderId_1, ...args_1) => __awaiter(this, [authProviderId_1, ...args_1], void 0, function* (authProviderId, options = {}) {
            // verify required parameter 'authProviderId' is not null or undefined
            assertParamExists('getAuthProvider', 'authProviderId', authProviderId);
            const localVarPath = `/admin/auth-provider/{auth_provider_id}/`
                .replace(`{${"auth_provider_id"}}`, encodeURIComponent(String(authProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the available authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProviders: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/auth-provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the available login options for the configured authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProvidersLoginOptions: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth-provider/login-options/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Processes callback from OAuth2 provider and logs the user in if successful.
         * @param {number} providerId The id of the provider for which to process the callback.
         * @param {number} [code] The id of the provider for which to process the callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginCallback: (providerId_1, code_1, ...args_1) => __awaiter(this, [providerId_1, code_1, ...args_1], void 0, function* (providerId, code, options = {}) {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('oauthProviderLoginCallback', 'providerId', providerId);
            const localVarPath = `/sso/oauth2/callback/{provider_id}/`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Redirects to the OAuth2 provider\'s authentication URL based on the provided auth provider\'s id.
         * @param {number} providerId The id of the provider for redirect.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future.
         * @param {number} [original] The relative part of URL that the user wanted to access.
         * @param {string} [workspaceInvitationToken] The invitation token sent to the user to join a specific workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginRedirect: (providerId_1, groupInvitationToken_1, original_1, workspaceInvitationToken_1, ...args_1) => __awaiter(this, [providerId_1, groupInvitationToken_1, original_1, workspaceInvitationToken_1, ...args_1], void 0, function* (providerId, groupInvitationToken, original, workspaceInvitationToken, options = {}) {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('oauthProviderLoginRedirect', 'providerId', providerId);
            const localVarPath = `/sso/oauth2/login/{provider_id}/`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (groupInvitationToken !== undefined) {
                localVarQueryParameter['group_invitation_token'] = groupInvitationToken;
            }
            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }
            if (workspaceInvitationToken !== undefined) {
                localVarQueryParameter['workspace_invitation_token'] = workspaceInvitationToken;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {number} authProviderId The authentication provider id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthProvider: (authProviderId_1, ...args_1) => __awaiter(this, [authProviderId_1, ...args_1], void 0, function* (authProviderId, options = {}) {
            // verify required parameter 'authProviderId' is not null or undefined
            assertParamExists('updateAuthProvider', 'authProviderId', authProviderId);
            const localVarPath = `/admin/auth-provider/{auth_provider_id}/`
                .replace(`{${"auth_provider_id"}}`, encodeURIComponent(String(authProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         * Return the correct redirect_url to initiate the SSO SAML login. It needs an email address if multiple SAML providers are configured otherwise the only configured SAML provider signup URL will be returned.
         * @param {string} [email] The email address of the user that want to sign in using SAML.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future.
         * @param {string} [language] An ISO 639 language code (with optional variant) selected by the user. Ex: en-GB.
         * @param {string} [original] The url to which the user should be redirected after a successful login.
         * @param {string} [workspaceInvitationToken] If provided and valid, the user accepts the workspace invitation and will have access to the workspace after login or signing up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderLoginUrl(email, groupInvitationToken, language, original, workspaceInvitationToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authProviderLoginUrl(email, groupInvitationToken, language, original, workspaceInvitationToken, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.authProviderLoginUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Complete the SAML authentication flow by validating the SAML response. Sign in the user if already exists in Baserow or create a new one otherwise. Once authenticated, the user will be redirected to the original URL they were trying to access. If the response is invalid, the user will be redirected to an error page with a specific error message.It accepts the language code and the workspace invitation token as query parameters if provided.
         * @param {SAMLResponse} sAMLResponse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlAcsUrl(sAMLResponse, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authProviderSamlAcsUrl(sAMLResponse, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.authProviderSamlAcsUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This is the endpoint that is called when the user wants to initiate a SSO SAML login from Baserow (the service provider). The user will be redirected to the SAML identity provider (IdP) where the user can authenticate. Once logged in in the IdP, the user will be redirected back to the assertion consumer service endpoint (ACS) where the SAML response will be validated and a new JWT session token will be provided to work with Baserow APIs.
         * @param {string} [email] The email address of the user that want to sign in using SAML.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future
         * @param {string} [language] An ISO 639 language code (with optional variant) selected by the user. Ex: en-GB.
         * @param {string} [original] The url to which the user should be redirected after a successful login or sign up.
         * @param {string} [workspaceInvitationToken] If provided and valid, the user accepts the workspace invitation and will have access to the workspace after login or signing up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlSpLogin(email, groupInvitationToken, language, original, workspaceInvitationToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authProviderSamlSpLogin(email, groupInvitationToken, language, original, workspaceInvitationToken, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.authProviderSamlSpLogin']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthProvider(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAuthProvider(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.createAuthProvider']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete an authentication provider.
         * @param {number} authProviderId The authentication provider id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthProvider(authProviderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAuthProvider(authProviderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.deleteAuthProvider']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get an authentication provider.
         * @param {number} authProviderId The authentication provider id to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProvider(authProviderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAuthProvider(authProviderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.getAuthProvider']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the available authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProviders(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAuthProviders(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.listAuthProviders']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the available login options for the configured authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProvidersLoginOptions(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAuthProvidersLoginOptions(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.listAuthProvidersLoginOptions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Processes callback from OAuth2 provider and logs the user in if successful.
         * @param {number} providerId The id of the provider for which to process the callback.
         * @param {number} [code] The id of the provider for which to process the callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginCallback(providerId, code, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.oauthProviderLoginCallback(providerId, code, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.oauthProviderLoginCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Redirects to the OAuth2 provider\'s authentication URL based on the provided auth provider\'s id.
         * @param {number} providerId The id of the provider for redirect.
         * @param {string} [groupInvitationToken] Please use the functionally identical &#x60;workspace_invitation_token&#x60; instead as this querystring is being removed in the future.
         * @param {number} [original] The relative part of URL that the user wanted to access.
         * @param {string} [workspaceInvitationToken] The invitation token sent to the user to join a specific workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginRedirect(providerId, groupInvitationToken, original, workspaceInvitationToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.oauthProviderLoginRedirect(providerId, groupInvitationToken, original, workspaceInvitationToken, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.oauthProviderLoginRedirect']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {number} authProviderId The authentication provider id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthProvider(authProviderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAuthProvider(authProviderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.updateAuthProvider']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         * Return the correct redirect_url to initiate the SSO SAML login. It needs an email address if multiple SAML providers are configured otherwise the only configured SAML provider signup URL will be returned.
         * @param {AuthApiAuthProviderLoginUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderLoginUrl(requestParameters = {}, options) {
            return localVarFp.authProviderLoginUrl(requestParameters.email, requestParameters.groupInvitationToken, requestParameters.language, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete the SAML authentication flow by validating the SAML response. Sign in the user if already exists in Baserow or create a new one otherwise. Once authenticated, the user will be redirected to the original URL they were trying to access. If the response is invalid, the user will be redirected to an error page with a specific error message.It accepts the language code and the workspace invitation token as query parameters if provided.
         * @param {AuthApiAuthProviderSamlAcsUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlAcsUrl(requestParameters, options) {
            return localVarFp.authProviderSamlAcsUrl(requestParameters.sAMLResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the endpoint that is called when the user wants to initiate a SSO SAML login from Baserow (the service provider). The user will be redirected to the SAML identity provider (IdP) where the user can authenticate. Once logged in in the IdP, the user will be redirected back to the assertion consumer service endpoint (ACS) where the SAML response will be validated and a new JWT session token will be provided to work with Baserow APIs.
         * @param {AuthApiAuthProviderSamlSpLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderSamlSpLogin(requestParameters = {}, options) {
            return localVarFp.authProviderSamlSpLogin(requestParameters.email, requestParameters.groupInvitationToken, requestParameters.language, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthProvider(options) {
            return localVarFp.createAuthProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an authentication provider.
         * @param {AuthApiDeleteAuthProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthProvider(requestParameters, options) {
            return localVarFp.deleteAuthProvider(requestParameters.authProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an authentication provider.
         * @param {AuthApiGetAuthProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProvider(requestParameters, options) {
            return localVarFp.getAuthProvider(requestParameters.authProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the available authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProviders(options) {
            return localVarFp.listAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the available login options for the configured authentication providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthProvidersLoginOptions(options) {
            return localVarFp.listAuthProvidersLoginOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Processes callback from OAuth2 provider and logs the user in if successful.
         * @param {AuthApiOauthProviderLoginCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginCallback(requestParameters, options) {
            return localVarFp.oauthProviderLoginCallback(requestParameters.providerId, requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the OAuth2 provider\'s authentication URL based on the provided auth provider\'s id.
         * @param {AuthApiOauthProviderLoginRedirectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderLoginRedirect(requestParameters, options) {
            return localVarFp.oauthProviderLoginRedirect(requestParameters.providerId, requestParameters.groupInvitationToken, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
         * @param {AuthApiUpdateAuthProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthProvider(requestParameters, options) {
            return localVarFp.updateAuthProvider(requestParameters.authProviderId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends BaseAPI {
    /**
     * Return the correct redirect_url to initiate the SSO SAML login. It needs an email address if multiple SAML providers are configured otherwise the only configured SAML provider signup URL will be returned.
     * @param {AuthApiAuthProviderLoginUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    authProviderLoginUrl(requestParameters = {}, options) {
        return AuthApiFp(this.configuration).authProviderLoginUrl(requestParameters.email, requestParameters.groupInvitationToken, requestParameters.language, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Complete the SAML authentication flow by validating the SAML response. Sign in the user if already exists in Baserow or create a new one otherwise. Once authenticated, the user will be redirected to the original URL they were trying to access. If the response is invalid, the user will be redirected to an error page with a specific error message.It accepts the language code and the workspace invitation token as query parameters if provided.
     * @param {AuthApiAuthProviderSamlAcsUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    authProviderSamlAcsUrl(requestParameters, options) {
        return AuthApiFp(this.configuration).authProviderSamlAcsUrl(requestParameters.sAMLResponse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is the endpoint that is called when the user wants to initiate a SSO SAML login from Baserow (the service provider). The user will be redirected to the SAML identity provider (IdP) where the user can authenticate. Once logged in in the IdP, the user will be redirected back to the assertion consumer service endpoint (ACS) where the SAML response will be validated and a new JWT session token will be provided to work with Baserow APIs.
     * @param {AuthApiAuthProviderSamlSpLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    authProviderSamlSpLogin(requestParameters = {}, options) {
        return AuthApiFp(this.configuration).authProviderSamlSpLogin(requestParameters.email, requestParameters.groupInvitationToken, requestParameters.language, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    createAuthProvider(options) {
        return AuthApiFp(this.configuration).createAuthProvider(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an authentication provider.
     * @param {AuthApiDeleteAuthProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    deleteAuthProvider(requestParameters, options) {
        return AuthApiFp(this.configuration).deleteAuthProvider(requestParameters.authProviderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an authentication provider.
     * @param {AuthApiGetAuthProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    getAuthProvider(requestParameters, options) {
        return AuthApiFp(this.configuration).getAuthProvider(requestParameters.authProviderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the available authentication providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    listAuthProviders(options) {
        return AuthApiFp(this.configuration).listAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the available login options for the configured authentication providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    listAuthProvidersLoginOptions(options) {
        return AuthApiFp(this.configuration).listAuthProvidersLoginOptions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Processes callback from OAuth2 provider and logs the user in if successful.
     * @param {AuthApiOauthProviderLoginCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    oauthProviderLoginCallback(requestParameters, options) {
        return AuthApiFp(this.configuration).oauthProviderLoginCallback(requestParameters.providerId, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Redirects to the OAuth2 provider\'s authentication URL based on the provided auth provider\'s id.
     * @param {AuthApiOauthProviderLoginRedirectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    oauthProviderLoginRedirect(requestParameters, options) {
        return AuthApiFp(this.configuration).oauthProviderLoginRedirect(requestParameters.providerId, requestParameters.groupInvitationToken, requestParameters.original, requestParameters.workspaceInvitationToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a new authentication provider. This can be used to enable authentication with a third party service like Google or Facebook.
     * @param {AuthApiUpdateAuthProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    updateAuthProvider(requestParameters, options) {
        return AuthApiFp(this.configuration).updateAuthProvider(requestParameters.authProviderId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderDataSourcesApi - axios parameter creator
 * @export
 */
const BuilderDataSourcesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new builder data_source
         * @param {number} pageId Creates a data_source for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {IntegrationServiceCreateDataSource} [integrationServiceCreateDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageDataSource: (pageId_1, clientSessionId_1, integrationServiceCreateDataSource_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, integrationServiceCreateDataSource_1, ...args_1], void 0, function* (pageId, clientSessionId, integrationServiceCreateDataSource, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('createBuilderPageDataSource', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/data-sources/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(integrationServiceCreateDataSource, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the data_source related by the given id.
         * @param {number} dataSourceId The id of the data_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageDataSource: (dataSourceId_1, clientSessionId_1, ...args_1) => __awaiter(this, [dataSourceId_1, clientSessionId_1, ...args_1], void 0, function* (dataSourceId, clientSessionId, options = {}) {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('deleteBuilderPageDataSource', 'dataSourceId', dataSourceId);
            const localVarPath = `/builder/data-source/{data_source_id}/`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Dispatches the service of the related data_source and returns the result.
         * @param {number} dataSourceId The id of the data_source you want to call the dispatch for
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSource: (dataSourceId_1, clientSessionId_1, ...args_1) => __awaiter(this, [dataSourceId_1, clientSessionId_1, ...args_1], void 0, function* (dataSourceId, clientSessionId, options = {}) {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dispatchBuilderPageDataSource', 'dataSourceId', dataSourceId);
            const localVarPath = `/builder/data-source/{data_source_id}/dispatch/`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Dispatches the service of the related page data_sources
         * @param {number} pageId The page we want to dispatch the data source for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSources: (pageId_1, clientSessionId_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, ...args_1], void 0, function* (pageId, clientSessionId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('dispatchBuilderPageDataSources', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/dispatch-data-sources/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the data_sources of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the data_sources of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageDataSources: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listBuilderPageDataSources', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/data-sources/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the data_sources of the page related to the provided parameter if the builder is public.
         * @param {number} pageId Returns only the data_sources of the page related to the provided Id if the related builder is public.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageDataSources: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listPublicBuilderPageDataSources', 'pageId', pageId);
            const localVarPath = `/builder/domains/published/page/{page_id}/data_sources/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Moves the data_source in the page before another data_source or at the end of the page if no before data_source is given. The data_sources must belong to the same page.
         * @param {number} dataSourceId The id of the data_source to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveDataSource} [patchedMoveDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageDataSource: (dataSourceId_1, clientSessionId_1, patchedMoveDataSource_1, ...args_1) => __awaiter(this, [dataSourceId_1, clientSessionId_1, patchedMoveDataSource_1, ...args_1], void 0, function* (dataSourceId, clientSessionId, patchedMoveDataSource, options = {}) {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('moveBuilderPageDataSource', 'dataSourceId', dataSourceId);
            const localVarPath = `/builder/data_source/{data_source_id}/move/`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMoveDataSource, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing builder data_source.
         * @param {number} dataSourceId The id of the data_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedIntegrationServiceUpdateDataSource} [patchedIntegrationServiceUpdateDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageDataSource: (dataSourceId_1, clientSessionId_1, patchedIntegrationServiceUpdateDataSource_1, ...args_1) => __awaiter(this, [dataSourceId_1, clientSessionId_1, patchedIntegrationServiceUpdateDataSource_1, ...args_1], void 0, function* (dataSourceId, clientSessionId, patchedIntegrationServiceUpdateDataSource, options = {}) {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('updateBuilderPageDataSource', 'dataSourceId', dataSourceId);
            const localVarPath = `/builder/data-source/{data_source_id}/`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIntegrationServiceUpdateDataSource, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderDataSourcesApi - functional programming interface
 * @export
 */
const BuilderDataSourcesApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderDataSourcesApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new builder data_source
         * @param {number} pageId Creates a data_source for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {IntegrationServiceCreateDataSource} [integrationServiceCreateDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageDataSource(pageId, clientSessionId, integrationServiceCreateDataSource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBuilderPageDataSource(pageId, clientSessionId, integrationServiceCreateDataSource, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.createBuilderPageDataSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the data_source related by the given id.
         * @param {number} dataSourceId The id of the data_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageDataSource(dataSourceId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBuilderPageDataSource(dataSourceId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.deleteBuilderPageDataSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Dispatches the service of the related data_source and returns the result.
         * @param {number} dataSourceId The id of the data_source you want to call the dispatch for
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSource(dataSourceId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.dispatchBuilderPageDataSource(dataSourceId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.dispatchBuilderPageDataSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Dispatches the service of the related page data_sources
         * @param {number} pageId The page we want to dispatch the data source for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSources(pageId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.dispatchBuilderPageDataSources(pageId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.dispatchBuilderPageDataSources']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the data_sources of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the data_sources of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageDataSources(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBuilderPageDataSources(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.listBuilderPageDataSources']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the data_sources of the page related to the provided parameter if the builder is public.
         * @param {number} pageId Returns only the data_sources of the page related to the provided Id if the related builder is public.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageDataSources(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicBuilderPageDataSources(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.listPublicBuilderPageDataSources']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Moves the data_source in the page before another data_source or at the end of the page if no before data_source is given. The data_sources must belong to the same page.
         * @param {number} dataSourceId The id of the data_source to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveDataSource} [patchedMoveDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageDataSource(dataSourceId, clientSessionId, patchedMoveDataSource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.moveBuilderPageDataSource(dataSourceId, clientSessionId, patchedMoveDataSource, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.moveBuilderPageDataSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing builder data_source.
         * @param {number} dataSourceId The id of the data_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedIntegrationServiceUpdateDataSource} [patchedIntegrationServiceUpdateDataSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageDataSource(dataSourceId, clientSessionId, patchedIntegrationServiceUpdateDataSource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderPageDataSource(dataSourceId, clientSessionId, patchedIntegrationServiceUpdateDataSource, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDataSourcesApi.updateBuilderPageDataSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderDataSourcesApi - factory interface
 * @export
 */
const BuilderDataSourcesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderDataSourcesApiFp(configuration);
    return {
        /**
         * Creates a new builder data_source
         * @param {BuilderDataSourcesApiCreateBuilderPageDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageDataSource(requestParameters, options) {
            return localVarFp.createBuilderPageDataSource(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.integrationServiceCreateDataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the data_source related by the given id.
         * @param {BuilderDataSourcesApiDeleteBuilderPageDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageDataSource(requestParameters, options) {
            return localVarFp.deleteBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatches the service of the related data_source and returns the result.
         * @param {BuilderDataSourcesApiDispatchBuilderPageDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSource(requestParameters, options) {
            return localVarFp.dispatchBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatches the service of the related page data_sources
         * @param {BuilderDataSourcesApiDispatchBuilderPageDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageDataSources(requestParameters, options) {
            return localVarFp.dispatchBuilderPageDataSources(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the data_sources of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {BuilderDataSourcesApiListBuilderPageDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageDataSources(requestParameters, options) {
            return localVarFp.listBuilderPageDataSources(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the data_sources of the page related to the provided parameter if the builder is public.
         * @param {BuilderDataSourcesApiListPublicBuilderPageDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageDataSources(requestParameters, options) {
            return localVarFp.listPublicBuilderPageDataSources(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves the data_source in the page before another data_source or at the end of the page if no before data_source is given. The data_sources must belong to the same page.
         * @param {BuilderDataSourcesApiMoveBuilderPageDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageDataSource(requestParameters, options) {
            return localVarFp.moveBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, requestParameters.patchedMoveDataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing builder data_source.
         * @param {BuilderDataSourcesApiUpdateBuilderPageDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageDataSource(requestParameters, options) {
            return localVarFp.updateBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, requestParameters.patchedIntegrationServiceUpdateDataSource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderDataSourcesApi - object-oriented interface
 * @export
 * @class BuilderDataSourcesApi
 * @extends {BaseAPI}
 */
class BuilderDataSourcesApi extends BaseAPI {
    /**
     * Creates a new builder data_source
     * @param {BuilderDataSourcesApiCreateBuilderPageDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    createBuilderPageDataSource(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).createBuilderPageDataSource(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.integrationServiceCreateDataSource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the data_source related by the given id.
     * @param {BuilderDataSourcesApiDeleteBuilderPageDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    deleteBuilderPageDataSource(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).deleteBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Dispatches the service of the related data_source and returns the result.
     * @param {BuilderDataSourcesApiDispatchBuilderPageDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    dispatchBuilderPageDataSource(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).dispatchBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Dispatches the service of the related page data_sources
     * @param {BuilderDataSourcesApiDispatchBuilderPageDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    dispatchBuilderPageDataSources(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).dispatchBuilderPageDataSources(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the data_sources of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {BuilderDataSourcesApiListBuilderPageDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    listBuilderPageDataSources(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).listBuilderPageDataSources(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the data_sources of the page related to the provided parameter if the builder is public.
     * @param {BuilderDataSourcesApiListPublicBuilderPageDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    listPublicBuilderPageDataSources(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).listPublicBuilderPageDataSources(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Moves the data_source in the page before another data_source or at the end of the page if no before data_source is given. The data_sources must belong to the same page.
     * @param {BuilderDataSourcesApiMoveBuilderPageDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    moveBuilderPageDataSource(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).moveBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, requestParameters.patchedMoveDataSource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing builder data_source.
     * @param {BuilderDataSourcesApiUpdateBuilderPageDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDataSourcesApi
     */
    updateBuilderPageDataSource(requestParameters, options) {
        return BuilderDataSourcesApiFp(this.configuration).updateBuilderPageDataSource(requestParameters.dataSourceId, requestParameters.clientSessionId, requestParameters.patchedIntegrationServiceUpdateDataSource, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderDomainsApi - axios parameter creator
 * @export
 */
const BuilderDomainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint can be used to check whether a domain exists for SSL certificate purposes. It\'s compatible with the Caddy on_demand TLS as described here: https://caddyserver.com/docs/json/apps/tls/automation/on_demand/ask/. It will respond with a 200 status code if it exists or a 404 if it doesn\'t exist.
         * @param {number} [domain] The domain name for which
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        askPublicBuilderDomainExists: (domain_1, ...args_1) => __awaiter(this, [domain_1, ...args_1], void 0, function* (domain, options = {}) {
            const localVarPath = `/builder/domains/ask-public-domain-exists/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new domain for an application builder
         * @param {number} builderId Creates a domain for the application builder related tothe provided value
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {DomainTypeCreateDomain} [domainTypeCreateDomain]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderDomain: (builderId_1, clientSessionId_1, domainTypeCreateDomain_1, ...args_1) => __awaiter(this, [builderId_1, clientSessionId_1, domainTypeCreateDomain_1, ...args_1], void 0, function* (builderId, clientSessionId, domainTypeCreateDomain, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('createBuilderDomain', 'builderId', builderId);
            const localVarPath = `/builder/{builder_id}/domains/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(domainTypeCreateDomain, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an existing domain of an application builder
         * @param {number} domainId The id of the domain
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderDomain: (domainId_1, clientSessionId_1, ...args_1) => __awaiter(this, [domainId_1, clientSessionId_1, ...args_1], void 0, function* (domainId, clientSessionId, options = {}) {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('deleteBuilderDomain', 'domainId', domainId);
            const localVarPath = `/builder/domains/{domain_id}/`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets all the domains of a builder
         * @param {number} builderId Gets all the domains for the specified builder
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuilderDomains: (builderId_1, clientSessionId_1, ...args_1) => __awaiter(this, [builderId_1, clientSessionId_1, ...args_1], void 0, function* (builderId, clientSessionId, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('getBuilderDomains', 'builderId', builderId);
            const localVarPath = `/builder/{builder_id}/domains/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Apply a new order to the domains of a builder
         * @param {number} builderId The builder the domain belongs to
         * @param {OrderDomains} orderDomains
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderDomains: (builderId_1, orderDomains_1, clientSessionId_1, ...args_1) => __awaiter(this, [builderId_1, orderDomains_1, clientSessionId_1, ...args_1], void 0, function* (builderId, orderDomains, clientSessionId, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('orderBuilderDomains', 'builderId', builderId);
            // verify required parameter 'orderDomains' is not null or undefined
            assertParamExists('orderBuilderDomains', 'orderDomains', orderDomains);
            const localVarPath = `/builder/{builder_id}/domains/order/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderDomains, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint starts an asynchronous job to publish the builder. The job clones the current version of the given builder and publish it for the given domain.
         * @param {number} domainId The builder application id the user wants to publish.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishBuilderDomain: (domainId_1, clientSessionId_1, ...args_1) => __awaiter(this, [domainId_1, clientSessionId_1, ...args_1], void 0, function* (domainId, clientSessionId, options = {}) {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('publishBuilderDomain', 'domainId', domainId);
            const localVarPath = `/builder/domains/{domain_id}/publish/async/`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing domain of an application builder
         * @param {number} domainId The id of the domain
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedUpdateDomain} [patchedUpdateDomain]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderDomain: (domainId_1, clientSessionId_1, patchedUpdateDomain_1, ...args_1) => __awaiter(this, [domainId_1, clientSessionId_1, patchedUpdateDomain_1, ...args_1], void 0, function* (domainId, clientSessionId, patchedUpdateDomain, options = {}) {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('updateBuilderDomain', 'domainId', domainId);
            const localVarPath = `/builder/domains/{domain_id}/`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateDomain, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderDomainsApi - functional programming interface
 * @export
 */
const BuilderDomainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderDomainsApiAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint can be used to check whether a domain exists for SSL certificate purposes. It\'s compatible with the Caddy on_demand TLS as described here: https://caddyserver.com/docs/json/apps/tls/automation/on_demand/ask/. It will respond with a 200 status code if it exists or a 404 if it doesn\'t exist.
         * @param {number} [domain] The domain name for which
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        askPublicBuilderDomainExists(domain, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.askPublicBuilderDomainExists(domain, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.askPublicBuilderDomainExists']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new domain for an application builder
         * @param {number} builderId Creates a domain for the application builder related tothe provided value
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {DomainTypeCreateDomain} [domainTypeCreateDomain]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderDomain(builderId, clientSessionId, domainTypeCreateDomain, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBuilderDomain(builderId, clientSessionId, domainTypeCreateDomain, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.createBuilderDomain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an existing domain of an application builder
         * @param {number} domainId The id of the domain
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderDomain(domainId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBuilderDomain(domainId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.deleteBuilderDomain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Gets all the domains of a builder
         * @param {number} builderId Gets all the domains for the specified builder
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuilderDomains(builderId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBuilderDomains(builderId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.getBuilderDomains']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Apply a new order to the domains of a builder
         * @param {number} builderId The builder the domain belongs to
         * @param {OrderDomains} orderDomains
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderDomains(builderId, orderDomains, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderBuilderDomains(builderId, orderDomains, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.orderBuilderDomains']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint starts an asynchronous job to publish the builder. The job clones the current version of the given builder and publish it for the given domain.
         * @param {number} domainId The builder application id the user wants to publish.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishBuilderDomain(domainId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publishBuilderDomain(domainId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.publishBuilderDomain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing domain of an application builder
         * @param {number} domainId The id of the domain
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedUpdateDomain} [patchedUpdateDomain]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderDomain(domainId, clientSessionId, patchedUpdateDomain, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderDomain(domainId, clientSessionId, patchedUpdateDomain, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderDomainsApi.updateBuilderDomain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderDomainsApi - factory interface
 * @export
 */
const BuilderDomainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderDomainsApiFp(configuration);
    return {
        /**
         * This endpoint can be used to check whether a domain exists for SSL certificate purposes. It\'s compatible with the Caddy on_demand TLS as described here: https://caddyserver.com/docs/json/apps/tls/automation/on_demand/ask/. It will respond with a 200 status code if it exists or a 404 if it doesn\'t exist.
         * @param {BuilderDomainsApiAskPublicBuilderDomainExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        askPublicBuilderDomainExists(requestParameters = {}, options) {
            return localVarFp.askPublicBuilderDomainExists(requestParameters.domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new domain for an application builder
         * @param {BuilderDomainsApiCreateBuilderDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderDomain(requestParameters, options) {
            return localVarFp.createBuilderDomain(requestParameters.builderId, requestParameters.clientSessionId, requestParameters.domainTypeCreateDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing domain of an application builder
         * @param {BuilderDomainsApiDeleteBuilderDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderDomain(requestParameters, options) {
            return localVarFp.deleteBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the domains of a builder
         * @param {BuilderDomainsApiGetBuilderDomainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuilderDomains(requestParameters, options) {
            return localVarFp.getBuilderDomains(requestParameters.builderId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply a new order to the domains of a builder
         * @param {BuilderDomainsApiOrderBuilderDomainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderDomains(requestParameters, options) {
            return localVarFp.orderBuilderDomains(requestParameters.builderId, requestParameters.orderDomains, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint starts an asynchronous job to publish the builder. The job clones the current version of the given builder and publish it for the given domain.
         * @param {BuilderDomainsApiPublishBuilderDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishBuilderDomain(requestParameters, options) {
            return localVarFp.publishBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing domain of an application builder
         * @param {BuilderDomainsApiUpdateBuilderDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderDomain(requestParameters, options) {
            return localVarFp.updateBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, requestParameters.patchedUpdateDomain, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderDomainsApi - object-oriented interface
 * @export
 * @class BuilderDomainsApi
 * @extends {BaseAPI}
 */
class BuilderDomainsApi extends BaseAPI {
    /**
     * This endpoint can be used to check whether a domain exists for SSL certificate purposes. It\'s compatible with the Caddy on_demand TLS as described here: https://caddyserver.com/docs/json/apps/tls/automation/on_demand/ask/. It will respond with a 200 status code if it exists or a 404 if it doesn\'t exist.
     * @param {BuilderDomainsApiAskPublicBuilderDomainExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    askPublicBuilderDomainExists(requestParameters = {}, options) {
        return BuilderDomainsApiFp(this.configuration).askPublicBuilderDomainExists(requestParameters.domain, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new domain for an application builder
     * @param {BuilderDomainsApiCreateBuilderDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    createBuilderDomain(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).createBuilderDomain(requestParameters.builderId, requestParameters.clientSessionId, requestParameters.domainTypeCreateDomain, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an existing domain of an application builder
     * @param {BuilderDomainsApiDeleteBuilderDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    deleteBuilderDomain(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).deleteBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets all the domains of a builder
     * @param {BuilderDomainsApiGetBuilderDomainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    getBuilderDomains(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).getBuilderDomains(requestParameters.builderId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply a new order to the domains of a builder
     * @param {BuilderDomainsApiOrderBuilderDomainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    orderBuilderDomains(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).orderBuilderDomains(requestParameters.builderId, requestParameters.orderDomains, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint starts an asynchronous job to publish the builder. The job clones the current version of the given builder and publish it for the given domain.
     * @param {BuilderDomainsApiPublishBuilderDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    publishBuilderDomain(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).publishBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing domain of an application builder
     * @param {BuilderDomainsApiUpdateBuilderDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderDomainsApi
     */
    updateBuilderDomain(requestParameters, options) {
        return BuilderDomainsApiFp(this.configuration).updateBuilderDomain(requestParameters.domainId, requestParameters.clientSessionId, requestParameters.patchedUpdateDomain, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderElementsApi - axios parameter creator
 * @export
 */
const BuilderElementsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new builder element
         * @param {number} pageId Creates an element for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {ElementTypeCreateElement} [elementTypeCreateElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageElement: (pageId_1, clientSessionId_1, elementTypeCreateElement_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, elementTypeCreateElement_1, ...args_1], void 0, function* (pageId, clientSessionId, elementTypeCreateElement, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('createBuilderPageElement', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/elements/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(elementTypeCreateElement, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the element related by the given id.
         * @param {number} elementId The id of the element
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageElement: (elementId_1, clientSessionId_1, ...args_1) => __awaiter(this, [elementId_1, clientSessionId_1, ...args_1], void 0, function* (elementId, clientSessionId, options = {}) {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('deleteBuilderPageElement', 'elementId', elementId);
            const localVarPath = `/builder/element/{element_id}/`
                .replace(`{${"element_id"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates an element and all of the elements children and the associated workflow actions as well.
         * @param {number} elementId The id of the element to duplicate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageElement: (elementId_1, clientSessionId_1, ...args_1) => __awaiter(this, [elementId_1, clientSessionId_1, ...args_1], void 0, function* (elementId, clientSessionId, options = {}) {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('duplicateBuilderPageElement', 'elementId', elementId);
            const localVarPath = `/builder/element/{element_id}/duplicate/`
                .replace(`{${"element_id"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the elements of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the elements of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageElements: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listBuilderPageElements', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/elements/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the elements of the page related to the provided parameter. If the user is Anonymous, the page must belong to a published builder instance to being accessible.
         * @param {number} pageId Returns the elements of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageElements: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listPublicBuilderPageElements', 'pageId', pageId);
            const localVarPath = `/builder/domains/published/page/{page_id}/elements/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Moves the element in the page before another element or at the end of the page if no before element is given. The elements must belong to the same page.
         * @param {number} elementId The id of the element to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveElement} [patchedMoveElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageElement: (elementId_1, clientSessionId_1, patchedMoveElement_1, ...args_1) => __awaiter(this, [elementId_1, clientSessionId_1, patchedMoveElement_1, ...args_1], void 0, function* (elementId, clientSessionId, patchedMoveElement, options = {}) {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('moveBuilderPageElement', 'elementId', elementId);
            const localVarPath = `/builder/element/{element_id}/move/`
                .replace(`{${"element_id"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMoveElement, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing builder element.
         * @param {number} elementId The id of the element
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedElementTypeUpdateElement} [patchedElementTypeUpdateElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageElement: (elementId_1, clientSessionId_1, patchedElementTypeUpdateElement_1, ...args_1) => __awaiter(this, [elementId_1, clientSessionId_1, patchedElementTypeUpdateElement_1, ...args_1], void 0, function* (elementId, clientSessionId, patchedElementTypeUpdateElement, options = {}) {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('updateBuilderPageElement', 'elementId', elementId);
            const localVarPath = `/builder/element/{element_id}/`
                .replace(`{${"element_id"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedElementTypeUpdateElement, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderElementsApi - functional programming interface
 * @export
 */
const BuilderElementsApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderElementsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new builder element
         * @param {number} pageId Creates an element for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {ElementTypeCreateElement} [elementTypeCreateElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageElement(pageId, clientSessionId, elementTypeCreateElement, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBuilderPageElement(pageId, clientSessionId, elementTypeCreateElement, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.createBuilderPageElement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the element related by the given id.
         * @param {number} elementId The id of the element
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageElement(elementId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBuilderPageElement(elementId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.deleteBuilderPageElement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Duplicates an element and all of the elements children and the associated workflow actions as well.
         * @param {number} elementId The id of the element to duplicate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageElement(elementId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateBuilderPageElement(elementId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.duplicateBuilderPageElement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the elements of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the elements of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageElements(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBuilderPageElements(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.listBuilderPageElements']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the elements of the page related to the provided parameter. If the user is Anonymous, the page must belong to a published builder instance to being accessible.
         * @param {number} pageId Returns the elements of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageElements(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicBuilderPageElements(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.listPublicBuilderPageElements']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Moves the element in the page before another element or at the end of the page if no before element is given. The elements must belong to the same page.
         * @param {number} elementId The id of the element to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveElement} [patchedMoveElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageElement(elementId, clientSessionId, patchedMoveElement, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.moveBuilderPageElement(elementId, clientSessionId, patchedMoveElement, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.moveBuilderPageElement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing builder element.
         * @param {number} elementId The id of the element
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedElementTypeUpdateElement} [patchedElementTypeUpdateElement]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageElement(elementId, clientSessionId, patchedElementTypeUpdateElement, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderPageElement(elementId, clientSessionId, patchedElementTypeUpdateElement, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderElementsApi.updateBuilderPageElement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderElementsApi - factory interface
 * @export
 */
const BuilderElementsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderElementsApiFp(configuration);
    return {
        /**
         * Creates a new builder element
         * @param {BuilderElementsApiCreateBuilderPageElementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageElement(requestParameters, options) {
            return localVarFp.createBuilderPageElement(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.elementTypeCreateElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the element related by the given id.
         * @param {BuilderElementsApiDeleteBuilderPageElementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageElement(requestParameters, options) {
            return localVarFp.deleteBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates an element and all of the elements children and the associated workflow actions as well.
         * @param {BuilderElementsApiDuplicateBuilderPageElementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageElement(requestParameters, options) {
            return localVarFp.duplicateBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the elements of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {BuilderElementsApiListBuilderPageElementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageElements(requestParameters, options) {
            return localVarFp.listBuilderPageElements(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the elements of the page related to the provided parameter. If the user is Anonymous, the page must belong to a published builder instance to being accessible.
         * @param {BuilderElementsApiListPublicBuilderPageElementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageElements(requestParameters, options) {
            return localVarFp.listPublicBuilderPageElements(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves the element in the page before another element or at the end of the page if no before element is given. The elements must belong to the same page.
         * @param {BuilderElementsApiMoveBuilderPageElementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBuilderPageElement(requestParameters, options) {
            return localVarFp.moveBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, requestParameters.patchedMoveElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing builder element.
         * @param {BuilderElementsApiUpdateBuilderPageElementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageElement(requestParameters, options) {
            return localVarFp.updateBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, requestParameters.patchedElementTypeUpdateElement, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderElementsApi - object-oriented interface
 * @export
 * @class BuilderElementsApi
 * @extends {BaseAPI}
 */
class BuilderElementsApi extends BaseAPI {
    /**
     * Creates a new builder element
     * @param {BuilderElementsApiCreateBuilderPageElementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    createBuilderPageElement(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).createBuilderPageElement(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.elementTypeCreateElement, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the element related by the given id.
     * @param {BuilderElementsApiDeleteBuilderPageElementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    deleteBuilderPageElement(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).deleteBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates an element and all of the elements children and the associated workflow actions as well.
     * @param {BuilderElementsApiDuplicateBuilderPageElementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    duplicateBuilderPageElement(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).duplicateBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the elements of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {BuilderElementsApiListBuilderPageElementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    listBuilderPageElements(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).listBuilderPageElements(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the elements of the page related to the provided parameter. If the user is Anonymous, the page must belong to a published builder instance to being accessible.
     * @param {BuilderElementsApiListPublicBuilderPageElementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    listPublicBuilderPageElements(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).listPublicBuilderPageElements(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Moves the element in the page before another element or at the end of the page if no before element is given. The elements must belong to the same page.
     * @param {BuilderElementsApiMoveBuilderPageElementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    moveBuilderPageElement(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).moveBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, requestParameters.patchedMoveElement, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing builder element.
     * @param {BuilderElementsApiUpdateBuilderPageElementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderElementsApi
     */
    updateBuilderPageElement(requestParameters, options) {
        return BuilderElementsApiFp(this.configuration).updateBuilderPageElement(requestParameters.elementId, requestParameters.clientSessionId, requestParameters.patchedElementTypeUpdateElement, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderPagesApi - axios parameter creator
 * @export
 */
const BuilderPagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new page for an application builder
         * @param {number} builderId Creates a page for the application builder related to the provided value.
         * @param {CreatePage} createPage
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPage: (builderId_1, createPage_1, clientSessionId_1, ...args_1) => __awaiter(this, [builderId_1, createPage_1, clientSessionId_1, ...args_1], void 0, function* (builderId, createPage, clientSessionId, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('createBuilderPage', 'builderId', builderId);
            // verify required parameter 'createPage' is not null or undefined
            assertParamExists('createBuilderPage', 'createPage', createPage);
            const localVarPath = `/builder/{builder_id}/pages/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createPage, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an existing page of an application builder
         * @param {number} pageId The id of the page
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPage: (pageId_1, clientSessionId_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, ...args_1], void 0, function* (pageId, clientSessionId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('deleteBuilderPage', 'pageId', pageId);
            const localVarPath = `/builder/pages/{page_id}/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Start a job to duplicate the page with the provided `page_id` parameter if the authorized user has access to the builder\'s workspace.
         * @param {number} pageId The page to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageAsync: (pageId_1, clientSessionId_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, ...args_1], void 0, function* (pageId, clientSessionId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('duplicateBuilderPageAsync', 'pageId', pageId);
            const localVarPath = `/builder/pages/{page_id}/duplicate/async/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Apply a new order to the pages of a builder
         * @param {number} builderId The builder the page belongs to
         * @param {OrderPages} orderPages
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderPages: (builderId_1, orderPages_1, clientSessionId_1, ...args_1) => __awaiter(this, [builderId_1, orderPages_1, clientSessionId_1, ...args_1], void 0, function* (builderId, orderPages, clientSessionId, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('orderBuilderPages', 'builderId', builderId);
            // verify required parameter 'orderPages' is not null or undefined
            assertParamExists('orderBuilderPages', 'orderPages', orderPages);
            const localVarPath = `/builder/{builder_id}/pages/order/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderPages, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing page of an application builder
         * @param {number} pageId The id of the page
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedUpdatePage} [patchedUpdatePage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPage: (pageId_1, clientSessionId_1, patchedUpdatePage_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, patchedUpdatePage_1, ...args_1], void 0, function* (pageId, clientSessionId, patchedUpdatePage, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('updateBuilderPage', 'pageId', pageId);
            const localVarPath = `/builder/pages/{page_id}/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdatePage, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderPagesApi - functional programming interface
 * @export
 */
const BuilderPagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderPagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new page for an application builder
         * @param {number} builderId Creates a page for the application builder related to the provided value.
         * @param {CreatePage} createPage
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPage(builderId, createPage, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBuilderPage(builderId, createPage, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPagesApi.createBuilderPage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an existing page of an application builder
         * @param {number} pageId The id of the page
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPage(pageId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBuilderPage(pageId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPagesApi.deleteBuilderPage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Start a job to duplicate the page with the provided `page_id` parameter if the authorized user has access to the builder\'s workspace.
         * @param {number} pageId The page to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageAsync(pageId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateBuilderPageAsync(pageId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPagesApi.duplicateBuilderPageAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Apply a new order to the pages of a builder
         * @param {number} builderId The builder the page belongs to
         * @param {OrderPages} orderPages
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderPages(builderId, orderPages, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderBuilderPages(builderId, orderPages, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPagesApi.orderBuilderPages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing page of an application builder
         * @param {number} pageId The id of the page
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedUpdatePage} [patchedUpdatePage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPage(pageId, clientSessionId, patchedUpdatePage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderPage(pageId, clientSessionId, patchedUpdatePage, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPagesApi.updateBuilderPage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderPagesApi - factory interface
 * @export
 */
const BuilderPagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderPagesApiFp(configuration);
    return {
        /**
         * Creates a new page for an application builder
         * @param {BuilderPagesApiCreateBuilderPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPage(requestParameters, options) {
            return localVarFp.createBuilderPage(requestParameters.builderId, requestParameters.createPage, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing page of an application builder
         * @param {BuilderPagesApiDeleteBuilderPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPage(requestParameters, options) {
            return localVarFp.deleteBuilderPage(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a job to duplicate the page with the provided `page_id` parameter if the authorized user has access to the builder\'s workspace.
         * @param {BuilderPagesApiDuplicateBuilderPageAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBuilderPageAsync(requestParameters, options) {
            return localVarFp.duplicateBuilderPageAsync(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply a new order to the pages of a builder
         * @param {BuilderPagesApiOrderBuilderPagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderPages(requestParameters, options) {
            return localVarFp.orderBuilderPages(requestParameters.builderId, requestParameters.orderPages, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing page of an application builder
         * @param {BuilderPagesApiUpdateBuilderPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPage(requestParameters, options) {
            return localVarFp.updateBuilderPage(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.patchedUpdatePage, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderPagesApi - object-oriented interface
 * @export
 * @class BuilderPagesApi
 * @extends {BaseAPI}
 */
class BuilderPagesApi extends BaseAPI {
    /**
     * Creates a new page for an application builder
     * @param {BuilderPagesApiCreateBuilderPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPagesApi
     */
    createBuilderPage(requestParameters, options) {
        return BuilderPagesApiFp(this.configuration).createBuilderPage(requestParameters.builderId, requestParameters.createPage, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an existing page of an application builder
     * @param {BuilderPagesApiDeleteBuilderPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPagesApi
     */
    deleteBuilderPage(requestParameters, options) {
        return BuilderPagesApiFp(this.configuration).deleteBuilderPage(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Start a job to duplicate the page with the provided `page_id` parameter if the authorized user has access to the builder\'s workspace.
     * @param {BuilderPagesApiDuplicateBuilderPageAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPagesApi
     */
    duplicateBuilderPageAsync(requestParameters, options) {
        return BuilderPagesApiFp(this.configuration).duplicateBuilderPageAsync(requestParameters.pageId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply a new order to the pages of a builder
     * @param {BuilderPagesApiOrderBuilderPagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPagesApi
     */
    orderBuilderPages(requestParameters, options) {
        return BuilderPagesApiFp(this.configuration).orderBuilderPages(requestParameters.builderId, requestParameters.orderPages, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing page of an application builder
     * @param {BuilderPagesApiUpdateBuilderPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPagesApi
     */
    updateBuilderPage(requestParameters, options) {
        return BuilderPagesApiFp(this.configuration).updateBuilderPage(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.patchedUpdatePage, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderPublicApi - axios parameter creator
 * @export
 */
const BuilderPublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the public serialized version of the builder for the given domain name and its pages .
         * @param {string} domainName Returns the builder published for the given domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderByDomainName: (domainName_1, ...args_1) => __awaiter(this, [domainName_1, ...args_1], void 0, function* (domainName, options = {}) {
            // verify required parameter 'domainName' is not null or undefined
            assertParamExists('getPublicBuilderByDomainName', 'domainName', domainName);
            const localVarPath = `/builder/domains/published/by_name/{domain_name}/`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the public serialized version of the builder and its pages for the given builder id.
         * @param {number} builderId Returns the builder related to the provided Id and its pages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderById: (builderId_1, ...args_1) => __awaiter(this, [builderId_1, ...args_1], void 0, function* (builderId, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('getPublicBuilderById', 'builderId', builderId);
            const localVarPath = `/builder/domains/published/by_id/{builder_id}/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderPublicApi - functional programming interface
 * @export
 */
const BuilderPublicApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderPublicApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the public serialized version of the builder for the given domain name and its pages .
         * @param {string} domainName Returns the builder published for the given domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderByDomainName(domainName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicBuilderByDomainName(domainName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPublicApi.getPublicBuilderByDomainName']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the public serialized version of the builder and its pages for the given builder id.
         * @param {number} builderId Returns the builder related to the provided Id and its pages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderById(builderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicBuilderById(builderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderPublicApi.getPublicBuilderById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderPublicApi - factory interface
 * @export
 */
const BuilderPublicApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderPublicApiFp(configuration);
    return {
        /**
         * Returns the public serialized version of the builder for the given domain name and its pages .
         * @param {BuilderPublicApiGetPublicBuilderByDomainNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderByDomainName(requestParameters, options) {
            return localVarFp.getPublicBuilderByDomainName(requestParameters.domainName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the public serialized version of the builder and its pages for the given builder id.
         * @param {BuilderPublicApiGetPublicBuilderByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBuilderById(requestParameters, options) {
            return localVarFp.getPublicBuilderById(requestParameters.builderId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderPublicApi - object-oriented interface
 * @export
 * @class BuilderPublicApi
 * @extends {BaseAPI}
 */
class BuilderPublicApi extends BaseAPI {
    /**
     * Returns the public serialized version of the builder for the given domain name and its pages .
     * @param {BuilderPublicApiGetPublicBuilderByDomainNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPublicApi
     */
    getPublicBuilderByDomainName(requestParameters, options) {
        return BuilderPublicApiFp(this.configuration).getPublicBuilderByDomainName(requestParameters.domainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the public serialized version of the builder and its pages for the given builder id.
     * @param {BuilderPublicApiGetPublicBuilderByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderPublicApi
     */
    getPublicBuilderById(requestParameters, options) {
        return BuilderPublicApiFp(this.configuration).getPublicBuilderById(requestParameters.builderId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderThemeApi - axios parameter creator
 * @export
 */
const BuilderThemeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Updates the theme properties for the provided id.
         * @param {number} builderId Updates the theme for the application builder related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedCombinedThemeConfigBlocks} [patchedCombinedThemeConfigBlocks]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderTheme: (builderId_1, clientSessionId_1, patchedCombinedThemeConfigBlocks_1, ...args_1) => __awaiter(this, [builderId_1, clientSessionId_1, patchedCombinedThemeConfigBlocks_1, ...args_1], void 0, function* (builderId, clientSessionId, patchedCombinedThemeConfigBlocks, options = {}) {
            // verify required parameter 'builderId' is not null or undefined
            assertParamExists('updateBuilderTheme', 'builderId', builderId);
            const localVarPath = `/builder/{builder_id}/theme/`
                .replace(`{${"builder_id"}}`, encodeURIComponent(String(builderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCombinedThemeConfigBlocks, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderThemeApi - functional programming interface
 * @export
 */
const BuilderThemeApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderThemeApiAxiosParamCreator(configuration);
    return {
        /**
         * Updates the theme properties for the provided id.
         * @param {number} builderId Updates the theme for the application builder related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedCombinedThemeConfigBlocks} [patchedCombinedThemeConfigBlocks]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderTheme(builderId, clientSessionId, patchedCombinedThemeConfigBlocks, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderTheme(builderId, clientSessionId, patchedCombinedThemeConfigBlocks, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderThemeApi.updateBuilderTheme']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderThemeApi - factory interface
 * @export
 */
const BuilderThemeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderThemeApiFp(configuration);
    return {
        /**
         * Updates the theme properties for the provided id.
         * @param {BuilderThemeApiUpdateBuilderThemeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderTheme(requestParameters, options) {
            return localVarFp.updateBuilderTheme(requestParameters.builderId, requestParameters.clientSessionId, requestParameters.patchedCombinedThemeConfigBlocks, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderThemeApi - object-oriented interface
 * @export
 * @class BuilderThemeApi
 * @extends {BaseAPI}
 */
class BuilderThemeApi extends BaseAPI {
    /**
     * Updates the theme properties for the provided id.
     * @param {BuilderThemeApiUpdateBuilderThemeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderThemeApi
     */
    updateBuilderTheme(requestParameters, options) {
        return BuilderThemeApiFp(this.configuration).updateBuilderTheme(requestParameters.builderId, requestParameters.clientSessionId, requestParameters.patchedCombinedThemeConfigBlocks, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BuilderWorkflowActionsApi - axios parameter creator
 * @export
 */
const BuilderWorkflowActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new builder workflow action
         * @param {number} pageId Creates a workflow action for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {BuilderWorkflowActionTypeCreateBuilderWorkflowAction} [builderWorkflowActionTypeCreateBuilderWorkflowAction]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageWorkflowAction: (pageId_1, clientSessionId_1, builderWorkflowActionTypeCreateBuilderWorkflowAction_1, ...args_1) => __awaiter(this, [pageId_1, clientSessionId_1, builderWorkflowActionTypeCreateBuilderWorkflowAction_1, ...args_1], void 0, function* (pageId, clientSessionId, builderWorkflowActionTypeCreateBuilderWorkflowAction, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('createBuilderPageWorkflowAction', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/workflow_actions/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(builderWorkflowActionTypeCreateBuilderWorkflowAction, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the workflow action related by the given id.
         * @param {number} workflowActionId The id of the workflow action
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageWorkflowAction: (workflowActionId_1, clientSessionId_1, ...args_1) => __awaiter(this, [workflowActionId_1, clientSessionId_1, ...args_1], void 0, function* (workflowActionId, clientSessionId, options = {}) {
            // verify required parameter 'workflowActionId' is not null or undefined
            assertParamExists('deleteBuilderPageWorkflowAction', 'workflowActionId', workflowActionId);
            const localVarPath = `/builder/workflow_action/{workflow_action_id}/`
                .replace(`{${"workflow_action_id"}}`, encodeURIComponent(String(workflowActionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Dispatches the service of the related workflow_action and returns the result.
         * @param {number} workflowActionId The id of the workflow_action you want to call the dispatch for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageWorkflowAction: (workflowActionId_1, clientSessionId_1, ...args_1) => __awaiter(this, [workflowActionId_1, clientSessionId_1, ...args_1], void 0, function* (workflowActionId, clientSessionId, options = {}) {
            // verify required parameter 'workflowActionId' is not null or undefined
            assertParamExists('dispatchBuilderPageWorkflowAction', 'workflowActionId', workflowActionId);
            const localVarPath = `/builder/workflow_action/{workflow_action_id}/dispatch/`
                .replace(`{${"workflow_action_id"}}`, encodeURIComponent(String(workflowActionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the workflow actions of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the workflow actions of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageWorkflowActions: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listBuilderPageWorkflowActions', 'pageId', pageId);
            const localVarPath = `/builder/page/{page_id}/workflow_actions/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the workflow actions with their public accessible data. Some configuration might be omitted for security reasons such as passwords or PII.
         * @param {number} pageId Returns only the public workflow actions of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageWorkflowActions: (pageId_1, ...args_1) => __awaiter(this, [pageId_1, ...args_1], void 0, function* (pageId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('listPublicBuilderPageWorkflowActions', 'pageId', pageId);
            const localVarPath = `/builder/domains/published/page/{page_id}/workflow_actions/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Apply a new order to the workflow actions of a page
         * @param {number} pageId The page the workflow actions belong to
         * @param {OrderWorkflowActions} orderWorkflowActions
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderWorkflowActions: (pageId_1, orderWorkflowActions_1, clientSessionId_1, ...args_1) => __awaiter(this, [pageId_1, orderWorkflowActions_1, clientSessionId_1, ...args_1], void 0, function* (pageId, orderWorkflowActions, clientSessionId, options = {}) {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('orderBuilderWorkflowActions', 'pageId', pageId);
            // verify required parameter 'orderWorkflowActions' is not null or undefined
            assertParamExists('orderBuilderWorkflowActions', 'orderWorkflowActions', orderWorkflowActions);
            const localVarPath = `/builder/page/{page_id}/workflow_actions/order/`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderWorkflowActions, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing builder workflow action.
         * @param {number} workflowActionId The id of the workflow action
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions} [patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageWorkflowAction: (workflowActionId_1, clientSessionId_1, patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions_1, ...args_1) => __awaiter(this, [workflowActionId_1, clientSessionId_1, patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions_1, ...args_1], void 0, function* (workflowActionId, clientSessionId, patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, options = {}) {
            // verify required parameter 'workflowActionId' is not null or undefined
            assertParamExists('updateBuilderPageWorkflowAction', 'workflowActionId', workflowActionId);
            const localVarPath = `/builder/workflow_action/{workflow_action_id}/`
                .replace(`{${"workflow_action_id"}}`, encodeURIComponent(String(workflowActionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BuilderWorkflowActionsApi - functional programming interface
 * @export
 */
const BuilderWorkflowActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = BuilderWorkflowActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new builder workflow action
         * @param {number} pageId Creates a workflow action for the builder page related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {BuilderWorkflowActionTypeCreateBuilderWorkflowAction} [builderWorkflowActionTypeCreateBuilderWorkflowAction]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageWorkflowAction(pageId, clientSessionId, builderWorkflowActionTypeCreateBuilderWorkflowAction, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBuilderPageWorkflowAction(pageId, clientSessionId, builderWorkflowActionTypeCreateBuilderWorkflowAction, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.createBuilderPageWorkflowAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the workflow action related by the given id.
         * @param {number} workflowActionId The id of the workflow action
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageWorkflowAction(workflowActionId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBuilderPageWorkflowAction(workflowActionId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.deleteBuilderPageWorkflowAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Dispatches the service of the related workflow_action and returns the result.
         * @param {number} workflowActionId The id of the workflow_action you want to call the dispatch for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageWorkflowAction(workflowActionId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.dispatchBuilderPageWorkflowAction(workflowActionId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.dispatchBuilderPageWorkflowAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the workflow actions of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} pageId Returns only the workflow actions of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageWorkflowActions(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBuilderPageWorkflowActions(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.listBuilderPageWorkflowActions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the workflow actions with their public accessible data. Some configuration might be omitted for security reasons such as passwords or PII.
         * @param {number} pageId Returns only the public workflow actions of the page related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageWorkflowActions(pageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicBuilderPageWorkflowActions(pageId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.listPublicBuilderPageWorkflowActions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Apply a new order to the workflow actions of a page
         * @param {number} pageId The page the workflow actions belong to
         * @param {OrderWorkflowActions} orderWorkflowActions
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderWorkflowActions(pageId, orderWorkflowActions, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderBuilderWorkflowActions(pageId, orderWorkflowActions, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.orderBuilderWorkflowActions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing builder workflow action.
         * @param {number} workflowActionId The id of the workflow action
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions} [patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageWorkflowAction(workflowActionId, clientSessionId, patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBuilderPageWorkflowAction(workflowActionId, clientSessionId, patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['BuilderWorkflowActionsApi.updateBuilderPageWorkflowAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BuilderWorkflowActionsApi - factory interface
 * @export
 */
const BuilderWorkflowActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BuilderWorkflowActionsApiFp(configuration);
    return {
        /**
         * Creates a new builder workflow action
         * @param {BuilderWorkflowActionsApiCreateBuilderPageWorkflowActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuilderPageWorkflowAction(requestParameters, options) {
            return localVarFp.createBuilderPageWorkflowAction(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.builderWorkflowActionTypeCreateBuilderWorkflowAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the workflow action related by the given id.
         * @param {BuilderWorkflowActionsApiDeleteBuilderPageWorkflowActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilderPageWorkflowAction(requestParameters, options) {
            return localVarFp.deleteBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatches the service of the related workflow_action and returns the result.
         * @param {BuilderWorkflowActionsApiDispatchBuilderPageWorkflowActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchBuilderPageWorkflowAction(requestParameters, options) {
            return localVarFp.dispatchBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the workflow actions of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {BuilderWorkflowActionsApiListBuilderPageWorkflowActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilderPageWorkflowActions(requestParameters, options) {
            return localVarFp.listBuilderPageWorkflowActions(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the workflow actions with their public accessible data. Some configuration might be omitted for security reasons such as passwords or PII.
         * @param {BuilderWorkflowActionsApiListPublicBuilderPageWorkflowActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicBuilderPageWorkflowActions(requestParameters, options) {
            return localVarFp.listPublicBuilderPageWorkflowActions(requestParameters.pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply a new order to the workflow actions of a page
         * @param {BuilderWorkflowActionsApiOrderBuilderWorkflowActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuilderWorkflowActions(requestParameters, options) {
            return localVarFp.orderBuilderWorkflowActions(requestParameters.pageId, requestParameters.orderWorkflowActions, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing builder workflow action.
         * @param {BuilderWorkflowActionsApiUpdateBuilderPageWorkflowActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuilderPageWorkflowAction(requestParameters, options) {
            return localVarFp.updateBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, requestParameters.patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BuilderWorkflowActionsApi - object-oriented interface
 * @export
 * @class BuilderWorkflowActionsApi
 * @extends {BaseAPI}
 */
class BuilderWorkflowActionsApi extends BaseAPI {
    /**
     * Creates a new builder workflow action
     * @param {BuilderWorkflowActionsApiCreateBuilderPageWorkflowActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    createBuilderPageWorkflowAction(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).createBuilderPageWorkflowAction(requestParameters.pageId, requestParameters.clientSessionId, requestParameters.builderWorkflowActionTypeCreateBuilderWorkflowAction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the workflow action related by the given id.
     * @param {BuilderWorkflowActionsApiDeleteBuilderPageWorkflowActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    deleteBuilderPageWorkflowAction(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).deleteBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Dispatches the service of the related workflow_action and returns the result.
     * @param {BuilderWorkflowActionsApiDispatchBuilderPageWorkflowActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    dispatchBuilderPageWorkflowAction(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).dispatchBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the workflow actions of the page related to the provided parameter if the user has access to the related builder\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {BuilderWorkflowActionsApiListBuilderPageWorkflowActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    listBuilderPageWorkflowActions(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).listBuilderPageWorkflowActions(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the workflow actions with their public accessible data. Some configuration might be omitted for security reasons such as passwords or PII.
     * @param {BuilderWorkflowActionsApiListPublicBuilderPageWorkflowActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    listPublicBuilderPageWorkflowActions(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).listPublicBuilderPageWorkflowActions(requestParameters.pageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply a new order to the workflow actions of a page
     * @param {BuilderWorkflowActionsApiOrderBuilderWorkflowActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    orderBuilderWorkflowActions(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).orderBuilderWorkflowActions(requestParameters.pageId, requestParameters.orderWorkflowActions, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing builder workflow action.
     * @param {BuilderWorkflowActionsApiUpdateBuilderPageWorkflowActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuilderWorkflowActionsApi
     */
    updateBuilderPageWorkflowAction(requestParameters, options) {
        return BuilderWorkflowActionsApiFp(this.configuration).updateBuilderPageWorkflowAction(requestParameters.workflowActionId, requestParameters.clientSessionId, requestParameters.patchedBuilderWorkflowActionTypeUpdateBuilderWorkflowActions, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableCalendarViewApi - axios parameter creator
 * @export
 */
const DatabaseTableCalendarViewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Responds with serialized rows grouped by date regarding view\'s date fieldif the user is authenticated and has access to the related workspace.  This is a **premium** feature.
         * @param {string} fromTimestamp Restricts results based on the calendar date field.
         * @param {string} toTimestamp Restricts results based on the calendar date field.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned by default.
         * @param {number} [offset] Defines from which offset the rows should be returned.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {string} [userTimezone] User\&#39;s timezone will be taken into account for date fieldtypes that have a time and don\&#39;t enforce a timezone. The timezone will be used for aggregating the dates. For date fields without a time this will be ignored and UTC will be forced.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableCalendarViewRows: (fromTimestamp_1, toTimestamp_1, viewId_1, include_1, limit_1, offset_1, search_1, searchMode_1, userTimezone_1, ...args_1) => __awaiter(this, [fromTimestamp_1, toTimestamp_1, viewId_1, include_1, limit_1, offset_1, search_1, searchMode_1, userTimezone_1, ...args_1], void 0, function* (fromTimestamp, toTimestamp, viewId, include, limit, offset, search, searchMode, userTimezone, options = {}) {
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('listDatabaseTableCalendarViewRows', 'fromTimestamp', fromTimestamp);
            // verify required parameter 'toTimestamp' is not null or undefined
            assertParamExists('listDatabaseTableCalendarViewRows', 'toTimestamp', toTimestamp);
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableCalendarViewRows', 'viewId', viewId);
            const localVarPath = `/database/views/calendar/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (fromTimestamp !== undefined) {
                localVarQueryParameter['from_timestamp'] = (fromTimestamp instanceof Date) ?
                    fromTimestamp.toISOString() :
                    fromTimestamp;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (toTimestamp !== undefined) {
                localVarQueryParameter['to_timestamp'] = (toTimestamp instanceof Date) ?
                    toTimestamp.toISOString() :
                    toTimestamp;
            }
            if (userTimezone !== undefined) {
                localVarQueryParameter['user_timezone'] = userTimezone;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with serialized rows grouped by the view\'s date field options related to the `slug` if the calendar view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {string} fromTimestamp Restricts results based on the calendar date field.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {string} toTimestamp Restricts results based on the calendar date field.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [userTimezone] User\&#39;s timezone will be taken into account for date fieldtypes that have a time and don\&#39;t enforce a timezone. The timezone will be used for aggregating the dates. For date fields without a time this will be ignored and UTC will be forced.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableCalendarViewRows: (fromTimestamp_1, slug_1, toTimestamp_1, limit_1, offset_1, userTimezone_1, ...args_1) => __awaiter(this, [fromTimestamp_1, slug_1, toTimestamp_1, limit_1, offset_1, userTimezone_1, ...args_1], void 0, function* (fromTimestamp, slug, toTimestamp, limit, offset, userTimezone, options = {}) {
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('publicListDatabaseTableCalendarViewRows', 'fromTimestamp', fromTimestamp);
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publicListDatabaseTableCalendarViewRows', 'slug', slug);
            // verify required parameter 'toTimestamp' is not null or undefined
            assertParamExists('publicListDatabaseTableCalendarViewRows', 'toTimestamp', toTimestamp);
            const localVarPath = `/database/views/calendar/{slug}/public/rows/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (fromTimestamp !== undefined) {
                localVarQueryParameter['from_timestamp'] = (fromTimestamp instanceof Date) ?
                    fromTimestamp.toISOString() :
                    fromTimestamp;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (toTimestamp !== undefined) {
                localVarQueryParameter['to_timestamp'] = (toTimestamp instanceof Date) ?
                    toTimestamp.toISOString() :
                    toTimestamp;
            }
            if (userTimezone !== undefined) {
                localVarQueryParameter['user_timezone'] = userTimezone;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableCalendarViewApi - functional programming interface
 * @export
 */
const DatabaseTableCalendarViewApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableCalendarViewApiAxiosParamCreator(configuration);
    return {
        /**
         * Responds with serialized rows grouped by date regarding view\'s date fieldif the user is authenticated and has access to the related workspace.  This is a **premium** feature.
         * @param {string} fromTimestamp Restricts results based on the calendar date field.
         * @param {string} toTimestamp Restricts results based on the calendar date field.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned by default.
         * @param {number} [offset] Defines from which offset the rows should be returned.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {string} [userTimezone] User\&#39;s timezone will be taken into account for date fieldtypes that have a time and don\&#39;t enforce a timezone. The timezone will be used for aggregating the dates. For date fields without a time this will be ignored and UTC will be forced.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableCalendarViewRows(fromTimestamp, toTimestamp, viewId, include, limit, offset, search, searchMode, userTimezone, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableCalendarViewRows(fromTimestamp, toTimestamp, viewId, include, limit, offset, search, searchMode, userTimezone, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableCalendarViewApi.listDatabaseTableCalendarViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with serialized rows grouped by the view\'s date field options related to the `slug` if the calendar view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {string} fromTimestamp Restricts results based on the calendar date field.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {string} toTimestamp Restricts results based on the calendar date field.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [userTimezone] User\&#39;s timezone will be taken into account for date fieldtypes that have a time and don\&#39;t enforce a timezone. The timezone will be used for aggregating the dates. For date fields without a time this will be ignored and UTC will be forced.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableCalendarViewRows(fromTimestamp, slug, toTimestamp, limit, offset, userTimezone, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publicListDatabaseTableCalendarViewRows(fromTimestamp, slug, toTimestamp, limit, offset, userTimezone, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableCalendarViewApi.publicListDatabaseTableCalendarViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableCalendarViewApi - factory interface
 * @export
 */
const DatabaseTableCalendarViewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableCalendarViewApiFp(configuration);
    return {
        /**
         * Responds with serialized rows grouped by date regarding view\'s date fieldif the user is authenticated and has access to the related workspace.  This is a **premium** feature.
         * @param {DatabaseTableCalendarViewApiListDatabaseTableCalendarViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableCalendarViewRows(requestParameters, options) {
            return localVarFp.listDatabaseTableCalendarViewRows(requestParameters.fromTimestamp, requestParameters.toTimestamp, requestParameters.viewId, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.search, requestParameters.searchMode, requestParameters.userTimezone, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with serialized rows grouped by the view\'s date field options related to the `slug` if the calendar view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {DatabaseTableCalendarViewApiPublicListDatabaseTableCalendarViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableCalendarViewRows(requestParameters, options) {
            return localVarFp.publicListDatabaseTableCalendarViewRows(requestParameters.fromTimestamp, requestParameters.slug, requestParameters.toTimestamp, requestParameters.limit, requestParameters.offset, requestParameters.userTimezone, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableCalendarViewApi - object-oriented interface
 * @export
 * @class DatabaseTableCalendarViewApi
 * @extends {BaseAPI}
 */
class DatabaseTableCalendarViewApi extends BaseAPI {
    /**
     * Responds with serialized rows grouped by date regarding view\'s date fieldif the user is authenticated and has access to the related workspace.  This is a **premium** feature.
     * @param {DatabaseTableCalendarViewApiListDatabaseTableCalendarViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableCalendarViewApi
     */
    listDatabaseTableCalendarViewRows(requestParameters, options) {
        return DatabaseTableCalendarViewApiFp(this.configuration).listDatabaseTableCalendarViewRows(requestParameters.fromTimestamp, requestParameters.toTimestamp, requestParameters.viewId, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.search, requestParameters.searchMode, requestParameters.userTimezone, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with serialized rows grouped by the view\'s date field options related to the `slug` if the calendar view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
     * @param {DatabaseTableCalendarViewApiPublicListDatabaseTableCalendarViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableCalendarViewApi
     */
    publicListDatabaseTableCalendarViewRows(requestParameters, options) {
        return DatabaseTableCalendarViewApiFp(this.configuration).publicListDatabaseTableCalendarViewRows(requestParameters.fromTimestamp, requestParameters.slug, requestParameters.toTimestamp, requestParameters.limit, requestParameters.offset, requestParameters.userTimezone, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableExportApi - axios parameter creator
 * @export
 */
const DatabaseTableExportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates and starts a new export job for a table given some exporter options. Returns an error if the requesting user does not have permissionsto view the table.
         * @param {number} tableId The table id to create and start an export job for
         * @param {Export} [_export]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTable: (tableId_1, _export_1, ...args_1) => __awaiter(this, [tableId_1, _export_1, ...args_1], void 0, function* (tableId, _export, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('exportTable', 'tableId', tableId);
            const localVarPath = `/database/export/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(_export, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information such as export progress and state or the url of the exported file for the specified export job, only if the requesting user has access.
         * @param {number} jobId The job id to lookup information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportJob: (jobId_1, ...args_1) => __awaiter(this, [jobId_1, ...args_1], void 0, function* (jobId, options = {}) {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getExportJob', 'jobId', jobId);
            const localVarPath = `/database/export/{job_id}/`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableExportApi - functional programming interface
 * @export
 */
const DatabaseTableExportApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableExportApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates and starts a new export job for a table given some exporter options. Returns an error if the requesting user does not have permissionsto view the table.
         * @param {number} tableId The table id to create and start an export job for
         * @param {Export} [_export]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTable(tableId, _export, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportTable(tableId, _export, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableExportApi.exportTable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns information such as export progress and state or the url of the exported file for the specified export job, only if the requesting user has access.
         * @param {number} jobId The job id to lookup information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportJob(jobId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExportJob(jobId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableExportApi.getExportJob']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableExportApi - factory interface
 * @export
 */
const DatabaseTableExportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableExportApiFp(configuration);
    return {
        /**
         * Creates and starts a new export job for a table given some exporter options. Returns an error if the requesting user does not have permissionsto view the table.
         * @param {DatabaseTableExportApiExportTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTable(requestParameters, options) {
            return localVarFp.exportTable(requestParameters.tableId, requestParameters._export, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information such as export progress and state or the url of the exported file for the specified export job, only if the requesting user has access.
         * @param {DatabaseTableExportApiGetExportJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportJob(requestParameters, options) {
            return localVarFp.getExportJob(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableExportApi - object-oriented interface
 * @export
 * @class DatabaseTableExportApi
 * @extends {BaseAPI}
 */
class DatabaseTableExportApi extends BaseAPI {
    /**
     * Creates and starts a new export job for a table given some exporter options. Returns an error if the requesting user does not have permissionsto view the table.
     * @param {DatabaseTableExportApiExportTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableExportApi
     */
    exportTable(requestParameters, options) {
        return DatabaseTableExportApiFp(this.configuration).exportTable(requestParameters.tableId, requestParameters._export, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns information such as export progress and state or the url of the exported file for the specified export job, only if the requesting user has access.
     * @param {DatabaseTableExportApiGetExportJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableExportApi
     */
    getExportJob(requestParameters, options) {
        return DatabaseTableExportApiFp(this.configuration).getExportJob(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableFieldsApi - axios parameter creator
 * @export
 */
const DatabaseTableFieldsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Changes the primary field of a table to the one provided in the body payload.
         * @param {number} tableId The table where to update the primary field in.
         * @param {ChangePrimaryFieldParams} changePrimaryFieldParams
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePrimaryField: (tableId_1, changePrimaryFieldParams_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [tableId_1, changePrimaryFieldParams_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (tableId, changePrimaryFieldParams, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('changePrimaryField', 'tableId', tableId);
            // verify required parameter 'changePrimaryFieldParams' is not null or undefined
            assertParamExists('changePrimaryField', 'changePrimaryFieldParams', changePrimaryFieldParams);
            const localVarPath = `/database/fields/table/{table_id}/change-primary-field/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(changePrimaryFieldParams, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new field for the table related to the provided `table_id` parameter if the authorized user has access to the related database\'s workspace. Depending on the type, different properties can optionally be set.If creating the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} tableId Creates a new field for the provided table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {FieldCreateField} [fieldCreateField]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableField: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, fieldCreateField_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, fieldCreateField_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, fieldCreateField, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('createDatabaseTableField', 'tableId', tableId);
            const localVarPath = `/database/fields/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(fieldCreateField, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing field if the authorized user has access to the related database\'s workspace. Note that all the related data to that field is also deleted. Primary fields cannot be deleted because their value represents the row. If deleting the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} fieldId Deletes the field related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableField: (fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (fieldId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('deleteDatabaseTableField', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {number} fieldId The field to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTableField: (fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (fieldId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('duplicateTableField', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/duplicate/async/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint generates a Baserow formula for the table related to the provided id, based on the human readable input provided in the request body. This is a **premium** feature.
         * @param {number} tableId The table to generate the formula for.
         * @param {GenerateFormulaWithAIRequest} generateFormulaWithAIRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFormulaWithAi: (tableId_1, generateFormulaWithAIRequest_1, ...args_1) => __awaiter(this, [tableId_1, generateFormulaWithAIRequest_1, ...args_1], void 0, function* (tableId, generateFormulaWithAIRequest, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('generateFormulaWithAi', 'tableId', tableId);
            // verify required parameter 'generateFormulaWithAIRequest' is not null or undefined
            assertParamExists('generateFormulaWithAi', 'generateFormulaWithAIRequest', generateFormulaWithAIRequest);
            const localVarPath = `/database/fields/table/{table_id}/generate-ai-formula/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(generateFormulaWithAIRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Endpoint that\'s used by the AI field to start an sync task that will update the cell value of the provided row IDs based on the dynamically constructed prompt configured in the field settings.  This is a **premium** feature.
         * @param {number} fieldId The field to generate the value for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTableAiFieldValue: (fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (fieldId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('generateTableAiFieldValue', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/generate-ai-field-values/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all the unique row values for an existing field, sorted in order of frequency.
         * @param {number} fieldId Returns the values related to the provided field.
         * @param {number} [limit] Defines how many values should be returned.
         * @param {boolean} [splitCommaSeparated] Indicates whether the original column values must be splitted by comma.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseFieldUniqueRowValues: (fieldId_1, limit_1, splitCommaSeparated_1, ...args_1) => __awaiter(this, [fieldId_1, limit_1, splitCommaSeparated_1, ...args_1], void 0, function* (fieldId, limit, splitCommaSeparated, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('getDatabaseFieldUniqueRowValues', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/unique_row_values/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (splitCommaSeparated !== undefined) {
                localVarQueryParameter['split_comma_separated'] = splitCommaSeparated;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing field if the authorized user has access to the related database\'s workspace. Depending on the type different properties could be returned.
         * @param {number} fieldId Returns the field related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableField: (fieldId_1, ...args_1) => __awaiter(this, [fieldId_1, ...args_1], void 0, function* (fieldId, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('getDatabaseTableField', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the fields of the table related to the provided parameter if the user has access to the related database\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible. A table consists of fields and each field can have a different type. Each type can have different properties. A field is comparable with a regular table\'s column.
         * @param {number} tableId Returns only the fields of the table related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableFields: (tableId_1, ...args_1) => __awaiter(this, [tableId_1, ...args_1], void 0, function* (tableId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('listDatabaseTableFields', 'tableId', tableId);
            const localVarPath = `/database/fields/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Calculates and returns the type of the specified formula value. Does not change the state of the field in any way.
         * @param {number} tableId The table id of the formula field to type.
         * @param {TypeFormulaRequest} typeFormulaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeFormulaField: (tableId_1, typeFormulaRequest_1, ...args_1) => __awaiter(this, [tableId_1, typeFormulaRequest_1, ...args_1], void 0, function* (tableId, typeFormulaRequest, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('typeFormulaField', 'tableId', tableId);
            // verify required parameter 'typeFormulaRequest' is not null or undefined
            assertParamExists('typeFormulaField', 'typeFormulaRequest', typeFormulaRequest);
            const localVarPath = `/database/formula/{table_id}/type/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(typeFormulaRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing field if the authorized user has access to the related database\'s workspace. The type can also be changed and depending on that type, different additional properties can optionally be set. If you change the field type it could happen that the data conversion fails, in that case the `ERROR_CANNOT_CHANGE_FIELD_TYPE` is returned, but this rarely happens. If a data value cannot be converted it is set to `null` so data might go lost.If updated the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} fieldId Updates the field related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedFieldUpdateField} [patchedFieldUpdateField]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableField: (fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedFieldUpdateField_1, ...args_1) => __awaiter(this, [fieldId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedFieldUpdateField_1, ...args_1], void 0, function* (fieldId, clientSessionId, clientUndoRedoActionGroupId, patchedFieldUpdateField, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('updateDatabaseTableField', 'fieldId', fieldId);
            const localVarPath = `/database/fields/{field_id}/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFieldUpdateField, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableFieldsApi - functional programming interface
 * @export
 */
const DatabaseTableFieldsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableFieldsApiAxiosParamCreator(configuration);
    return {
        /**
         * Changes the primary field of a table to the one provided in the body payload.
         * @param {number} tableId The table where to update the primary field in.
         * @param {ChangePrimaryFieldParams} changePrimaryFieldParams
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePrimaryField(tableId, changePrimaryFieldParams, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changePrimaryField(tableId, changePrimaryFieldParams, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.changePrimaryField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new field for the table related to the provided `table_id` parameter if the authorized user has access to the related database\'s workspace. Depending on the type, different properties can optionally be set.If creating the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} tableId Creates a new field for the provided table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {FieldCreateField} [fieldCreateField]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableField(tableId, clientSessionId, clientUndoRedoActionGroupId, fieldCreateField, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableField(tableId, clientSessionId, clientUndoRedoActionGroupId, fieldCreateField, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.createDatabaseTableField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing field if the authorized user has access to the related database\'s workspace. Note that all the related data to that field is also deleted. Primary fields cannot be deleted because their value represents the row. If deleting the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} fieldId Deletes the field related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.deleteDatabaseTableField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Duplicates the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {number} fieldId The field to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.duplicateTableField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint generates a Baserow formula for the table related to the provided id, based on the human readable input provided in the request body. This is a **premium** feature.
         * @param {number} tableId The table to generate the formula for.
         * @param {GenerateFormulaWithAIRequest} generateFormulaWithAIRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFormulaWithAi(tableId, generateFormulaWithAIRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateFormulaWithAi(tableId, generateFormulaWithAIRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.generateFormulaWithAi']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Endpoint that\'s used by the AI field to start an sync task that will update the cell value of the provided row IDs based on the dynamically constructed prompt configured in the field settings.  This is a **premium** feature.
         * @param {number} fieldId The field to generate the value for.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTableAiFieldValue(fieldId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateTableAiFieldValue(fieldId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.generateTableAiFieldValue']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of all the unique row values for an existing field, sorted in order of frequency.
         * @param {number} fieldId Returns the values related to the provided field.
         * @param {number} [limit] Defines how many values should be returned.
         * @param {boolean} [splitCommaSeparated] Indicates whether the original column values must be splitted by comma.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseFieldUniqueRowValues(fieldId, limit, splitCommaSeparated, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseFieldUniqueRowValues(fieldId, limit, splitCommaSeparated, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.getDatabaseFieldUniqueRowValues']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing field if the authorized user has access to the related database\'s workspace. Depending on the type different properties could be returned.
         * @param {number} fieldId Returns the field related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableField(fieldId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableField(fieldId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.getDatabaseTableField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the fields of the table related to the provided parameter if the user has access to the related database\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible. A table consists of fields and each field can have a different type. Each type can have different properties. A field is comparable with a regular table\'s column.
         * @param {number} tableId Returns only the fields of the table related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableFields(tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableFields(tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.listDatabaseTableFields']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Calculates and returns the type of the specified formula value. Does not change the state of the field in any way.
         * @param {number} tableId The table id of the formula field to type.
         * @param {TypeFormulaRequest} typeFormulaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeFormulaField(tableId, typeFormulaRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.typeFormulaField(tableId, typeFormulaRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.typeFormulaField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing field if the authorized user has access to the related database\'s workspace. The type can also be changed and depending on that type, different additional properties can optionally be set. If you change the field type it could happen that the data conversion fails, in that case the `ERROR_CANNOT_CHANGE_FIELD_TYPE` is returned, but this rarely happens. If a data value cannot be converted it is set to `null` so data might go lost.If updated the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {number} fieldId Updates the field related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedFieldUpdateField} [patchedFieldUpdateField]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, patchedFieldUpdateField, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableField(fieldId, clientSessionId, clientUndoRedoActionGroupId, patchedFieldUpdateField, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFieldsApi.updateDatabaseTableField']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableFieldsApi - factory interface
 * @export
 */
const DatabaseTableFieldsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableFieldsApiFp(configuration);
    return {
        /**
         * Changes the primary field of a table to the one provided in the body payload.
         * @param {DatabaseTableFieldsApiChangePrimaryFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePrimaryField(requestParameters, options) {
            return localVarFp.changePrimaryField(requestParameters.tableId, requestParameters.changePrimaryFieldParams, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new field for the table related to the provided `table_id` parameter if the authorized user has access to the related database\'s workspace. Depending on the type, different properties can optionally be set.If creating the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {DatabaseTableFieldsApiCreateDatabaseTableFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableField(requestParameters, options) {
            return localVarFp.createDatabaseTableField(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.fieldCreateField, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing field if the authorized user has access to the related database\'s workspace. Note that all the related data to that field is also deleted. Primary fields cannot be deleted because their value represents the row. If deleting the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {DatabaseTableFieldsApiDeleteDatabaseTableFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableField(requestParameters, options) {
            return localVarFp.deleteDatabaseTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {DatabaseTableFieldsApiDuplicateTableFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTableField(requestParameters, options) {
            return localVarFp.duplicateTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint generates a Baserow formula for the table related to the provided id, based on the human readable input provided in the request body. This is a **premium** feature.
         * @param {DatabaseTableFieldsApiGenerateFormulaWithAiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFormulaWithAi(requestParameters, options) {
            return localVarFp.generateFormulaWithAi(requestParameters.tableId, requestParameters.generateFormulaWithAIRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint that\'s used by the AI field to start an sync task that will update the cell value of the provided row IDs based on the dynamically constructed prompt configured in the field settings.  This is a **premium** feature.
         * @param {DatabaseTableFieldsApiGenerateTableAiFieldValueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTableAiFieldValue(requestParameters, options) {
            return localVarFp.generateTableAiFieldValue(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the unique row values for an existing field, sorted in order of frequency.
         * @param {DatabaseTableFieldsApiGetDatabaseFieldUniqueRowValuesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseFieldUniqueRowValues(requestParameters, options) {
            return localVarFp.getDatabaseFieldUniqueRowValues(requestParameters.fieldId, requestParameters.limit, requestParameters.splitCommaSeparated, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing field if the authorized user has access to the related database\'s workspace. Depending on the type different properties could be returned.
         * @param {DatabaseTableFieldsApiGetDatabaseTableFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableField(requestParameters, options) {
            return localVarFp.getDatabaseTableField(requestParameters.fieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the fields of the table related to the provided parameter if the user has access to the related database\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible. A table consists of fields and each field can have a different type. Each type can have different properties. A field is comparable with a regular table\'s column.
         * @param {DatabaseTableFieldsApiListDatabaseTableFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableFields(requestParameters, options) {
            return localVarFp.listDatabaseTableFields(requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates and returns the type of the specified formula value. Does not change the state of the field in any way.
         * @param {DatabaseTableFieldsApiTypeFormulaFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeFormulaField(requestParameters, options) {
            return localVarFp.typeFormulaField(requestParameters.tableId, requestParameters.typeFormulaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing field if the authorized user has access to the related database\'s workspace. The type can also be changed and depending on that type, different additional properties can optionally be set. If you change the field type it could happen that the data conversion fails, in that case the `ERROR_CANNOT_CHANGE_FIELD_TYPE` is returned, but this rarely happens. If a data value cannot be converted it is set to `null` so data might go lost.If updated the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
         * @param {DatabaseTableFieldsApiUpdateDatabaseTableFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableField(requestParameters, options) {
            return localVarFp.updateDatabaseTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedFieldUpdateField, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableFieldsApi - object-oriented interface
 * @export
 * @class DatabaseTableFieldsApi
 * @extends {BaseAPI}
 */
class DatabaseTableFieldsApi extends BaseAPI {
    /**
     * Changes the primary field of a table to the one provided in the body payload.
     * @param {DatabaseTableFieldsApiChangePrimaryFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    changePrimaryField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).changePrimaryField(requestParameters.tableId, requestParameters.changePrimaryFieldParams, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new field for the table related to the provided `table_id` parameter if the authorized user has access to the related database\'s workspace. Depending on the type, different properties can optionally be set.If creating the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
     * @param {DatabaseTableFieldsApiCreateDatabaseTableFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    createDatabaseTableField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).createDatabaseTableField(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.fieldCreateField, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing field if the authorized user has access to the related database\'s workspace. Note that all the related data to that field is also deleted. Primary fields cannot be deleted because their value represents the row. If deleting the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
     * @param {DatabaseTableFieldsApiDeleteDatabaseTableFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    deleteDatabaseTableField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).deleteDatabaseTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
     * @param {DatabaseTableFieldsApiDuplicateTableFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    duplicateTableField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).duplicateTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint generates a Baserow formula for the table related to the provided id, based on the human readable input provided in the request body. This is a **premium** feature.
     * @param {DatabaseTableFieldsApiGenerateFormulaWithAiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    generateFormulaWithAi(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).generateFormulaWithAi(requestParameters.tableId, requestParameters.generateFormulaWithAIRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Endpoint that\'s used by the AI field to start an sync task that will update the cell value of the provided row IDs based on the dynamically constructed prompt configured in the field settings.  This is a **premium** feature.
     * @param {DatabaseTableFieldsApiGenerateTableAiFieldValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    generateTableAiFieldValue(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).generateTableAiFieldValue(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all the unique row values for an existing field, sorted in order of frequency.
     * @param {DatabaseTableFieldsApiGetDatabaseFieldUniqueRowValuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    getDatabaseFieldUniqueRowValues(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).getDatabaseFieldUniqueRowValues(requestParameters.fieldId, requestParameters.limit, requestParameters.splitCommaSeparated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing field if the authorized user has access to the related database\'s workspace. Depending on the type different properties could be returned.
     * @param {DatabaseTableFieldsApiGetDatabaseTableFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    getDatabaseTableField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).getDatabaseTableField(requestParameters.fieldId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the fields of the table related to the provided parameter if the user has access to the related database\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible. A table consists of fields and each field can have a different type. Each type can have different properties. A field is comparable with a regular table\'s column.
     * @param {DatabaseTableFieldsApiListDatabaseTableFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    listDatabaseTableFields(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).listDatabaseTableFields(requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Calculates and returns the type of the specified formula value. Does not change the state of the field in any way.
     * @param {DatabaseTableFieldsApiTypeFormulaFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    typeFormulaField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).typeFormulaField(requestParameters.tableId, requestParameters.typeFormulaRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing field if the authorized user has access to the related database\'s workspace. The type can also be changed and depending on that type, different additional properties can optionally be set. If you change the field type it could happen that the data conversion fails, in that case the `ERROR_CANNOT_CHANGE_FIELD_TYPE` is returned, but this rarely happens. If a data value cannot be converted it is set to `null` so data might go lost.If updated the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.
     * @param {DatabaseTableFieldsApiUpdateDatabaseTableFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFieldsApi
     */
    updateDatabaseTableField(requestParameters, options) {
        return DatabaseTableFieldsApiFp(this.configuration).updateDatabaseTableField(requestParameters.fieldId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedFieldUpdateField, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableFormViewApi - axios parameter creator
 * @export
 */
const DatabaseTableFormViewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the metadata related to the form view if the form is publicly shared or if the user has access to the related workspace. This data can be used to construct a form with the right fields.
         * @param {string} slug The slug related to the form form.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaDatabaseTableFormView: (slug_1, ...args_1) => __awaiter(this, [slug_1, ...args_1], void 0, function* (slug, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getMetaDatabaseTableFormView', 'slug', slug);
            const localVarPath = `/database/views/form/{slug}/submit/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submits the form if the form is publicly shared or if the user has access to the related workspace. The provided data will be validated based on the fields that are in the form and the rules per field. If valid, a new row will be created in the table.
         * @param {string} slug The slug related to the form.
         * @param {ExampleRowRequest} [exampleRowRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDatabaseTableFormView: (slug_1, exampleRowRequest_1, ...args_1) => __awaiter(this, [slug_1, exampleRowRequest_1, ...args_1], void 0, function* (slug, exampleRowRequest, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('submitDatabaseTableFormView', 'slug', slug);
            const localVarPath = `/database/views/form/{slug}/submit/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(exampleRowRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads a file anonymously to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {string} slug Submits files only if the view with the provided slughas a public file field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileFormView: (slug_1, ...args_1) => __awaiter(this, [slug_1, ...args_1], void 0, function* (slug, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('uploadFileFormView', 'slug', slug);
            const localVarPath = `/database/views/form/{slug}/upload-file/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableFormViewApi - functional programming interface
 * @export
 */
const DatabaseTableFormViewApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableFormViewApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the metadata related to the form view if the form is publicly shared or if the user has access to the related workspace. This data can be used to construct a form with the right fields.
         * @param {string} slug The slug related to the form form.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaDatabaseTableFormView(slug, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMetaDatabaseTableFormView(slug, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFormViewApi.getMetaDatabaseTableFormView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Submits the form if the form is publicly shared or if the user has access to the related workspace. The provided data will be validated based on the fields that are in the form and the rules per field. If valid, a new row will be created in the table.
         * @param {string} slug The slug related to the form.
         * @param {ExampleRowRequest} [exampleRowRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDatabaseTableFormView(slug, exampleRowRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitDatabaseTableFormView(slug, exampleRowRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFormViewApi.submitDatabaseTableFormView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads a file anonymously to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {string} slug Submits files only if the view with the provided slughas a public file field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileFormView(slug, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadFileFormView(slug, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableFormViewApi.uploadFileFormView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableFormViewApi - factory interface
 * @export
 */
const DatabaseTableFormViewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableFormViewApiFp(configuration);
    return {
        /**
         * Returns the metadata related to the form view if the form is publicly shared or if the user has access to the related workspace. This data can be used to construct a form with the right fields.
         * @param {DatabaseTableFormViewApiGetMetaDatabaseTableFormViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaDatabaseTableFormView(requestParameters, options) {
            return localVarFp.getMetaDatabaseTableFormView(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits the form if the form is publicly shared or if the user has access to the related workspace. The provided data will be validated based on the fields that are in the form and the rules per field. If valid, a new row will be created in the table.
         * @param {DatabaseTableFormViewApiSubmitDatabaseTableFormViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDatabaseTableFormView(requestParameters, options) {
            return localVarFp.submitDatabaseTableFormView(requestParameters.slug, requestParameters.exampleRowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file anonymously to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {DatabaseTableFormViewApiUploadFileFormViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileFormView(requestParameters, options) {
            return localVarFp.uploadFileFormView(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableFormViewApi - object-oriented interface
 * @export
 * @class DatabaseTableFormViewApi
 * @extends {BaseAPI}
 */
class DatabaseTableFormViewApi extends BaseAPI {
    /**
     * Returns the metadata related to the form view if the form is publicly shared or if the user has access to the related workspace. This data can be used to construct a form with the right fields.
     * @param {DatabaseTableFormViewApiGetMetaDatabaseTableFormViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFormViewApi
     */
    getMetaDatabaseTableFormView(requestParameters, options) {
        return DatabaseTableFormViewApiFp(this.configuration).getMetaDatabaseTableFormView(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits the form if the form is publicly shared or if the user has access to the related workspace. The provided data will be validated based on the fields that are in the form and the rules per field. If valid, a new row will be created in the table.
     * @param {DatabaseTableFormViewApiSubmitDatabaseTableFormViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFormViewApi
     */
    submitDatabaseTableFormView(requestParameters, options) {
        return DatabaseTableFormViewApiFp(this.configuration).submitDatabaseTableFormView(requestParameters.slug, requestParameters.exampleRowRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads a file anonymously to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
     * @param {DatabaseTableFormViewApiUploadFileFormViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableFormViewApi
     */
    uploadFileFormView(requestParameters, options) {
        return DatabaseTableFormViewApiFp(this.configuration).uploadFileFormView(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableGalleryViewApi - axios parameter creator
 * @export
 */
const DatabaseTableGalleryViewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated by a limit/offset style.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGalleryViewRows: (viewId_1, count_1, filterFieldFilter_1, filterType_1, filters_1, include_1, limit_1, offset_1, orderBy_1, search_1, searchMode_1, ...args_1) => __awaiter(this, [viewId_1, count_1, filterFieldFilter_1, filterType_1, filters_1, include_1, limit_1, offset_1, orderBy_1, search_1, searchMode_1, ...args_1], void 0, function* (viewId, count, filterFieldFilter, filterType, filters, include, limit, offset, orderBy, search, searchMode, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableGalleryViewRows', 'viewId', viewId);
            const localVarPath = `/database/views/gallery/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the gallery view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGalleryViewRows: (slug_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1) => __awaiter(this, [slug_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1], void 0, function* (slug, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publicListDatabaseTableGalleryViewRows', 'slug', slug);
            const localVarPath = `/database/views/gallery/{slug}/public/rows/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (includeFields !== undefined) {
                localVarQueryParameter['include_fields'] = includeFields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableGalleryViewApi - functional programming interface
 * @export
 */
const DatabaseTableGalleryViewApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableGalleryViewApiAxiosParamCreator(configuration);
    return {
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated by a limit/offset style.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGalleryViewRows(viewId, count, filterFieldFilter, filterType, filters, include, limit, offset, orderBy, search, searchMode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableGalleryViewRows(viewId, count, filterFieldFilter, filterType, filters, include, limit, offset, orderBy, search, searchMode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGalleryViewApi.listDatabaseTableGalleryViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the gallery view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGalleryViewRows(slug, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publicListDatabaseTableGalleryViewRows(slug, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGalleryViewApi.publicListDatabaseTableGalleryViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableGalleryViewApi - factory interface
 * @export
 */
const DatabaseTableGalleryViewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableGalleryViewApiFp(configuration);
    return {
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated by a limit/offset style.
         * @param {DatabaseTableGalleryViewApiListDatabaseTableGalleryViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGalleryViewRows(requestParameters, options) {
            return localVarFp.listDatabaseTableGalleryViewRows(requestParameters.viewId, requestParameters.count, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.search, requestParameters.searchMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the gallery view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {DatabaseTableGalleryViewApiPublicListDatabaseTableGalleryViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGalleryViewRows(requestParameters, options) {
            return localVarFp.publicListDatabaseTableGalleryViewRows(requestParameters.slug, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableGalleryViewApi - object-oriented interface
 * @export
 * @class DatabaseTableGalleryViewApi
 * @extends {BaseAPI}
 */
class DatabaseTableGalleryViewApi extends BaseAPI {
    /**
     * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated by a limit/offset style.
     * @param {DatabaseTableGalleryViewApiListDatabaseTableGalleryViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGalleryViewApi
     */
    listDatabaseTableGalleryViewRows(requestParameters, options) {
        return DatabaseTableGalleryViewApiFp(this.configuration).listDatabaseTableGalleryViewRows(requestParameters.viewId, requestParameters.count, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.search, requestParameters.searchMode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the requested rows of the view\'s table related to the provided `slug` if the gallery view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
     * @param {DatabaseTableGalleryViewApiPublicListDatabaseTableGalleryViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGalleryViewApi
     */
    publicListDatabaseTableGalleryViewRows(requestParameters, options) {
        return DatabaseTableGalleryViewApiFp(this.configuration).publicListDatabaseTableGalleryViewRows(requestParameters.slug, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableGridViewApi - axios parameter creator
 * @export
 */
const DatabaseTableGridViewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Lists only the rows and fields that match the request. Only the rows with the ids that are in the `row_ids` list are going to be returned. Same goes for the fields, only the fields with the ids in the `field_ids` are going to be returned. This endpoint could be used to refresh data after changes something. For example in the web frontend after changing a field type, the data of the related cells will be refreshed using this endpoint. In the example all field types are listed, but normally  the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {GridViewFilter} gridViewFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDatabaseTableGridViewRows: (viewId_1, gridViewFilter_1, ...args_1) => __awaiter(this, [viewId_1, gridViewFilter_1, ...args_1], void 0, function* (viewId, gridViewFilter, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('filterDatabaseTableGridViewRows', 'viewId', viewId);
            // verify required parameter 'gridViewFilter' is not null or undefined
            assertParamExists('filterDatabaseTableGridViewRows', 'gridViewFilter', gridViewFilter);
            const localVarPath = `/database/views/grid/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(gridViewFilter, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Computes the aggregation of all the values for a specified field from the selected grid view. You must select the aggregation type by setting the `type` GET parameter. If filters are configured for the selected view, the aggregation is calculated only on filtered rows. You need to have read permissions on the view to request an aggregation.
         * @param {number} fieldId The field id you want to aggregate
         * @param {number} viewId Select the view you want the aggregation for.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [type] The aggregation type you want. Available aggregation types: empty_count, not_empty_count, unique_count, min, max, sum, average, median, decile, variance, std_dev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregation: (fieldId_1, viewId_1, include_1, type_1, ...args_1) => __awaiter(this, [fieldId_1, viewId_1, include_1, type_1, ...args_1], void 0, function* (fieldId, viewId, include, type, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('getDatabaseTableGridViewFieldAggregation', 'fieldId', fieldId);
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('getDatabaseTableGridViewFieldAggregation', 'viewId', viewId);
            const localVarPath = `/database/views/grid/{view_id}/aggregation/{field_id}/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)))
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.You need to have read permissions on the view to request aggregations.
         * @param {number} viewId Select the view you want the aggregations for.
         * @param {string} [filterFieldFilter] The aggregation can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the aggregated rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the aggregated rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply for the aggregation. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [search] If provided the aggregations are calculated only for matching rows.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregations: (viewId_1, filterFieldFilter_1, filterType_1, filters_1, include_1, search_1, searchMode_1, ...args_1) => __awaiter(this, [viewId_1, filterFieldFilter_1, filterType_1, filters_1, include_1, search_1, searchMode_1, ...args_1], void 0, function* (viewId, filterFieldFilter, filterType, filters, include, search, searchMode, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('getDatabaseTableGridViewFieldAggregations', 'viewId', viewId);
            const localVarPath = `/database/views/grid/{view_id}/aggregations/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.
         * @param {string} slug Select the view you want the aggregations for.
         * @param {string} [filterFieldFilter] The aggregation can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the aggregated rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the aggregated rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply for the aggregation. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [search] If provided the aggregations are calculated only for matching rows.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTablePublicGridViewFieldAggregations: (slug_1, filterFieldFilter_1, filterType_1, filters_1, include_1, search_1, searchMode_1, ...args_1) => __awaiter(this, [slug_1, filterFieldFilter_1, filterType_1, filters_1, include_1, search_1, searchMode_1, ...args_1], void 0, function* (slug, filterFieldFilter, filterType, filters, include, search, searchMode, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getDatabaseTablePublicGridViewFieldAggregations', 'slug', slug);
            const localVarPath = `/database/views/grid/{slug}/public/aggregations/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.  The filters and sortings are automatically applied. To get a full overview of the applied filters and sortings you can use the `list_database_table_view_filters` and `list_database_table_view_sortings` endpoints.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGridViewRows: (viewId_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1) => __awaiter(this, [viewId_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1], void 0, function* (viewId, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableGridViewRows', 'viewId', viewId);
            const localVarPath = `/database/views/grid/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (includeFields !== undefined) {
                localVarQueryParameter['include_fields'] = includeFields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the grid view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [groupBy] Optionally the rows can be grouped by provided field ids separated by comma. By default no groups are applied. This doesn\&#39;t actually responds with the rows groups, this is just what\&#39;s needed for the Baserow group by feature.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGridViewRows: (slug_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, groupBy_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1) => __awaiter(this, [slug_1, count_1, excludeFields_1, filterFieldFilter_1, filterType_1, filters_1, groupBy_1, include_1, includeFields_1, limit_1, offset_1, orderBy_1, page_1, search_1, searchMode_1, size_1, ...args_1], void 0, function* (slug, count, excludeFields, filterFieldFilter, filterType, filters, groupBy, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publicListDatabaseTableGridViewRows', 'slug', slug);
            const localVarPath = `/database/views/grid/{slug}/public/rows/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (includeFields !== undefined) {
                localVarQueryParameter['include_fields'] = includeFields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableGridViewApi - functional programming interface
 * @export
 */
const DatabaseTableGridViewApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableGridViewApiAxiosParamCreator(configuration);
    return {
        /**
         * Lists only the rows and fields that match the request. Only the rows with the ids that are in the `row_ids` list are going to be returned. Same goes for the fields, only the fields with the ids in the `field_ids` are going to be returned. This endpoint could be used to refresh data after changes something. For example in the web frontend after changing a field type, the data of the related cells will be refreshed using this endpoint. In the example all field types are listed, but normally  the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {GridViewFilter} gridViewFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDatabaseTableGridViewRows(viewId, gridViewFilter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.filterDatabaseTableGridViewRows(viewId, gridViewFilter, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.filterDatabaseTableGridViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Computes the aggregation of all the values for a specified field from the selected grid view. You must select the aggregation type by setting the `type` GET parameter. If filters are configured for the selected view, the aggregation is calculated only on filtered rows. You need to have read permissions on the view to request an aggregation.
         * @param {number} fieldId The field id you want to aggregate
         * @param {number} viewId Select the view you want the aggregation for.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [type] The aggregation type you want. Available aggregation types: empty_count, not_empty_count, unique_count, min, max, sum, average, median, decile, variance, std_dev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregation(fieldId, viewId, include, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableGridViewFieldAggregation(fieldId, viewId, include, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.getDatabaseTableGridViewFieldAggregation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.You need to have read permissions on the view to request aggregations.
         * @param {number} viewId Select the view you want the aggregations for.
         * @param {string} [filterFieldFilter] The aggregation can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the aggregated rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the aggregated rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply for the aggregation. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [search] If provided the aggregations are calculated only for matching rows.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregations(viewId, filterFieldFilter, filterType, filters, include, search, searchMode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableGridViewFieldAggregations(viewId, filterFieldFilter, filterType, filters, include, search, searchMode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.getDatabaseTableGridViewFieldAggregations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.
         * @param {string} slug Select the view you want the aggregations for.
         * @param {string} [filterFieldFilter] The aggregation can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the aggregated rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the aggregated rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply for the aggregation. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] if &#x60;include&#x60; is set to &#x60;total&#x60;, the total row count will be returned with the result.
         * @param {string} [search] If provided the aggregations are calculated only for matching rows.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTablePublicGridViewFieldAggregations(slug, filterFieldFilter, filterType, filters, include, search, searchMode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTablePublicGridViewFieldAggregations(slug, filterFieldFilter, filterType, filters, include, search, searchMode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.getDatabaseTablePublicGridViewFieldAggregations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.  The filters and sortings are automatically applied. To get a full overview of the applied filters and sortings you can use the `list_database_table_view_filters` and `list_database_table_view_sortings` endpoints.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGridViewRows(viewId, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableGridViewRows(viewId, count, excludeFields, filterFieldFilter, filterType, filters, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.listDatabaseTableGridViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the grid view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {boolean} [count] If provided only the count will be returned.
         * @param {string} [excludeFields] All the fields are included in the response by default. You can select a subset of fields by providing the exclude_fields query parameter. If you for example provide the following GET parameter &#x60;exclude_fields&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [groupBy] Optionally the rows can be grouped by provided field ids separated by comma. By default no groups are applied. This doesn\&#39;t actually responds with the rows groups, this is just what\&#39;s needed for the Baserow group by feature.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here.
         * @param {string} [includeFields] All the fields are included in the response by default. You can select a subset of fields by providing the fields query parameter. If you for example provide the following GET parameter &#x60;include_fields&#x3D;field_1,field_2&#x60; then only the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A).
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGridViewRows(slug, count, excludeFields, filterFieldFilter, filterType, filters, groupBy, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publicListDatabaseTableGridViewRows(slug, count, excludeFields, filterFieldFilter, filterType, filters, groupBy, include, includeFields, limit, offset, orderBy, page, search, searchMode, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableGridViewApi.publicListDatabaseTableGridViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableGridViewApi - factory interface
 * @export
 */
const DatabaseTableGridViewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableGridViewApiFp(configuration);
    return {
        /**
         * Lists only the rows and fields that match the request. Only the rows with the ids that are in the `row_ids` list are going to be returned. Same goes for the fields, only the fields with the ids in the `field_ids` are going to be returned. This endpoint could be used to refresh data after changes something. For example in the web frontend after changing a field type, the data of the related cells will be refreshed using this endpoint. In the example all field types are listed, but normally  the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {DatabaseTableGridViewApiFilterDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDatabaseTableGridViewRows(requestParameters, options) {
            return localVarFp.filterDatabaseTableGridViewRows(requestParameters.viewId, requestParameters.gridViewFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Computes the aggregation of all the values for a specified field from the selected grid view. You must select the aggregation type by setting the `type` GET parameter. If filters are configured for the selected view, the aggregation is calculated only on filtered rows. You need to have read permissions on the view to request an aggregation.
         * @param {DatabaseTableGridViewApiGetDatabaseTableGridViewFieldAggregationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregation(requestParameters, options) {
            return localVarFp.getDatabaseTableGridViewFieldAggregation(requestParameters.fieldId, requestParameters.viewId, requestParameters.include, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.You need to have read permissions on the view to request aggregations.
         * @param {DatabaseTableGridViewApiGetDatabaseTableGridViewFieldAggregationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableGridViewFieldAggregations(requestParameters, options) {
            return localVarFp.getDatabaseTableGridViewFieldAggregations(requestParameters.viewId, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.search, requestParameters.searchMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.
         * @param {DatabaseTableGridViewApiGetDatabaseTablePublicGridViewFieldAggregationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTablePublicGridViewFieldAggregations(requestParameters, options) {
            return localVarFp.getDatabaseTablePublicGridViewFieldAggregations(requestParameters.slug, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.search, requestParameters.searchMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.  The filters and sortings are automatically applied. To get a full overview of the applied filters and sortings you can use the `list_database_table_view_filters` and `list_database_table_view_sortings` endpoints.
         * @param {DatabaseTableGridViewApiListDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableGridViewRows(requestParameters, options) {
            return localVarFp.listDatabaseTableGridViewRows(requestParameters.viewId, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the requested rows of the view\'s table related to the provided `slug` if the grid view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {DatabaseTableGridViewApiPublicListDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableGridViewRows(requestParameters, options) {
            return localVarFp.publicListDatabaseTableGridViewRows(requestParameters.slug, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.groupBy, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableGridViewApi - object-oriented interface
 * @export
 * @class DatabaseTableGridViewApi
 * @extends {BaseAPI}
 */
class DatabaseTableGridViewApi extends BaseAPI {
    /**
     * Lists only the rows and fields that match the request. Only the rows with the ids that are in the `row_ids` list are going to be returned. Same goes for the fields, only the fields with the ids in the `field_ids` are going to be returned. This endpoint could be used to refresh data after changes something. For example in the web frontend after changing a field type, the data of the related cells will be refreshed using this endpoint. In the example all field types are listed, but normally  the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
     * @param {DatabaseTableGridViewApiFilterDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    filterDatabaseTableGridViewRows(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).filterDatabaseTableGridViewRows(requestParameters.viewId, requestParameters.gridViewFilter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes the aggregation of all the values for a specified field from the selected grid view. You must select the aggregation type by setting the `type` GET parameter. If filters are configured for the selected view, the aggregation is calculated only on filtered rows. You need to have read permissions on the view to request an aggregation.
     * @param {DatabaseTableGridViewApiGetDatabaseTableGridViewFieldAggregationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    getDatabaseTableGridViewFieldAggregation(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).getDatabaseTableGridViewFieldAggregation(requestParameters.fieldId, requestParameters.viewId, requestParameters.include, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.You need to have read permissions on the view to request aggregations.
     * @param {DatabaseTableGridViewApiGetDatabaseTableGridViewFieldAggregationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    getDatabaseTableGridViewFieldAggregations(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).getDatabaseTableGridViewFieldAggregations(requestParameters.viewId, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.search, requestParameters.searchMode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all field aggregations values previously defined for this grid view. If filters exist for this view, the aggregations are computed only on filtered rows.
     * @param {DatabaseTableGridViewApiGetDatabaseTablePublicGridViewFieldAggregationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    getDatabaseTablePublicGridViewFieldAggregations(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).getDatabaseTablePublicGridViewFieldAggregations(requestParameters.slug, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.search, requestParameters.searchMode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the requested rows of the view\'s table related to the provided `view_id` if the authorized user has access to the database\'s workspace. The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.  The filters and sortings are automatically applied. To get a full overview of the applied filters and sortings you can use the `list_database_table_view_filters` and `list_database_table_view_sortings` endpoints.
     * @param {DatabaseTableGridViewApiListDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    listDatabaseTableGridViewRows(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).listDatabaseTableGridViewRows(requestParameters.viewId, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the requested rows of the view\'s table related to the provided `slug` if the grid view is public.The response is paginated either by a limit/offset or page/size style. The style depends on the provided GET parameters. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. The value is what the user has provided and the format of it depends on the fields type.
     * @param {DatabaseTableGridViewApiPublicListDatabaseTableGridViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableGridViewApi
     */
    publicListDatabaseTableGridViewRows(requestParameters, options) {
        return DatabaseTableGridViewApiFp(this.configuration).publicListDatabaseTableGridViewRows(requestParameters.slug, requestParameters.count, requestParameters.excludeFields, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.groupBy, requestParameters.include, requestParameters.includeFields, requestParameters.limit, requestParameters.offset, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableKanbanViewApi - axios parameter creator
 * @export
 */
const DatabaseTableKanbanViewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Responds with serialized rows grouped by the view\'s single select field options if the user is authenticated and has access to the related workspace. Additional query parameters can be provided to control the `limit` and `offset` per select option.  This is a **premium** feature.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [selectOption] Accepts multiple &#x60;select_option&#x60; parameters. If not provided, the rows of all select options will be returned. If one or more &#x60;select_option&#x60; parameters are provided, then only the rows of those will be included in the response. &#x60;?select_option&#x3D;1&amp;select_option&#x3D;null&#x60; will only include the rows for both select option with id &#x60;1&#x60; and &#x60;null&#x60;. &#x60;?select_option&#x3D;1,10,20&#x60; will only include the rows of select option id &#x60;1&#x60; with a limit of &#x60;10&#x60; and and offset of &#x60;20&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableKanbanViewRows: (viewId_1, filterFieldFilter_1, filterType_1, filters_1, include_1, limit_1, offset_1, selectOption_1, ...args_1) => __awaiter(this, [viewId_1, filterFieldFilter_1, filterType_1, filters_1, include_1, limit_1, offset_1, selectOption_1, ...args_1], void 0, function* (viewId, filterFieldFilter, filterType, filters, include, limit, offset, selectOption, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableKanbanViewRows', 'viewId', viewId);
            const localVarPath = `/database/views/kanban/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (selectOption !== undefined) {
                localVarQueryParameter['select_option'] = selectOption;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with serialized rows grouped by the view\'s single select field options related to the `slug` if the kanban view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [selectOption] Accepts multiple &#x60;select_option&#x60; parameters. If not provided, the rows of all select options will be returned. If one or more &#x60;select_option&#x60; parameters are provided, then only the rows of those will be included in the response. &#x60;?select_option&#x3D;1&amp;select_option&#x3D;null&#x60; will only include the rows for both select option with id &#x60;1&#x60; and &#x60;null&#x60;. &#x60;?select_option&#x3D;1,10,20&#x60; will only include the rows of select option id &#x60;1&#x60; with a limit of &#x60;10&#x60; and and offset of &#x60;20&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableKanbanViewRows: (slug_1, filterFieldFilter_1, filterType_1, filters_1, limit_1, offset_1, selectOption_1, ...args_1) => __awaiter(this, [slug_1, filterFieldFilter_1, filterType_1, filters_1, limit_1, offset_1, selectOption_1, ...args_1], void 0, function* (slug, filterFieldFilter, filterType, filters, limit, offset, selectOption, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publicListDatabaseTableKanbanViewRows', 'slug', slug);
            const localVarPath = `/database/views/kanban/{slug}/public/rows/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (selectOption !== undefined) {
                localVarQueryParameter['select_option'] = selectOption;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableKanbanViewApi - functional programming interface
 * @export
 */
const DatabaseTableKanbanViewApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableKanbanViewApiAxiosParamCreator(configuration);
    return {
        /**
         * Responds with serialized rows grouped by the view\'s single select field options if the user is authenticated and has access to the related workspace. Additional query parameters can be provided to control the `limit` and `offset` per select option.  This is a **premium** feature.
         * @param {number} viewId Returns only rows that belong to the related view\&#39;s table.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filter parameters the view filters saved for the view itself will be ignored.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.Please note that by passing the filters parameter the view filters saved for the view itself will be ignored.
         * @param {string} [include] A comma separated list allowing the values of &#x60;field_options&#x60; and &#x60;row_metadata&#x60; which will add the object/objects with the same name to the response if included. The &#x60;field_options&#x60; object contains user defined view settings for each field. For example the field\&#39;s width is included in here. The &#x60;row_metadata&#x60; object includes extra row specific data on a per row basis.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [selectOption] Accepts multiple &#x60;select_option&#x60; parameters. If not provided, the rows of all select options will be returned. If one or more &#x60;select_option&#x60; parameters are provided, then only the rows of those will be included in the response. &#x60;?select_option&#x3D;1&amp;select_option&#x3D;null&#x60; will only include the rows for both select option with id &#x60;1&#x60; and &#x60;null&#x60;. &#x60;?select_option&#x3D;1,10,20&#x60; will only include the rows of select option id &#x60;1&#x60; with a limit of &#x60;10&#x60; and and offset of &#x60;20&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableKanbanViewRows(viewId, filterFieldFilter, filterType, filters, include, limit, offset, selectOption, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableKanbanViewRows(viewId, filterFieldFilter, filterType, filters, include, limit, offset, selectOption, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableKanbanViewApi.listDatabaseTableKanbanViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with serialized rows grouped by the view\'s single select field options related to the `slug` if the kanban view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {string} slug Returns only rows that belong to the related view.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {number} [limit] Defines how many rows should be returned by default. This value can be overwritten per select option.
         * @param {number} [offset] Defines from which offset the rows should be returned.This value can be overwritten per select option.
         * @param {string} [selectOption] Accepts multiple &#x60;select_option&#x60; parameters. If not provided, the rows of all select options will be returned. If one or more &#x60;select_option&#x60; parameters are provided, then only the rows of those will be included in the response. &#x60;?select_option&#x3D;1&amp;select_option&#x3D;null&#x60; will only include the rows for both select option with id &#x60;1&#x60; and &#x60;null&#x60;. &#x60;?select_option&#x3D;1,10,20&#x60; will only include the rows of select option id &#x60;1&#x60; with a limit of &#x60;10&#x60; and and offset of &#x60;20&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableKanbanViewRows(slug, filterFieldFilter, filterType, filters, limit, offset, selectOption, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publicListDatabaseTableKanbanViewRows(slug, filterFieldFilter, filterType, filters, limit, offset, selectOption, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableKanbanViewApi.publicListDatabaseTableKanbanViewRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableKanbanViewApi - factory interface
 * @export
 */
const DatabaseTableKanbanViewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableKanbanViewApiFp(configuration);
    return {
        /**
         * Responds with serialized rows grouped by the view\'s single select field options if the user is authenticated and has access to the related workspace. Additional query parameters can be provided to control the `limit` and `offset` per select option.  This is a **premium** feature.
         * @param {DatabaseTableKanbanViewApiListDatabaseTableKanbanViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableKanbanViewRows(requestParameters, options) {
            return localVarFp.listDatabaseTableKanbanViewRows(requestParameters.viewId, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.selectOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with serialized rows grouped by the view\'s single select field options related to the `slug` if the kanban view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
         * @param {DatabaseTableKanbanViewApiPublicListDatabaseTableKanbanViewRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListDatabaseTableKanbanViewRows(requestParameters, options) {
            return localVarFp.publicListDatabaseTableKanbanViewRows(requestParameters.slug, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.selectOption, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableKanbanViewApi - object-oriented interface
 * @export
 * @class DatabaseTableKanbanViewApi
 * @extends {BaseAPI}
 */
class DatabaseTableKanbanViewApi extends BaseAPI {
    /**
     * Responds with serialized rows grouped by the view\'s single select field options if the user is authenticated and has access to the related workspace. Additional query parameters can be provided to control the `limit` and `offset` per select option.  This is a **premium** feature.
     * @param {DatabaseTableKanbanViewApiListDatabaseTableKanbanViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableKanbanViewApi
     */
    listDatabaseTableKanbanViewRows(requestParameters, options) {
        return DatabaseTableKanbanViewApiFp(this.configuration).listDatabaseTableKanbanViewRows(requestParameters.viewId, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.limit, requestParameters.offset, requestParameters.selectOption, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with serialized rows grouped by the view\'s single select field options related to the `slug` if the kanban view is publicly shared. Additional query parameters can be provided to control the `limit` and `offset` per select option.   This is a **premium** feature.
     * @param {DatabaseTableKanbanViewApiPublicListDatabaseTableKanbanViewRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableKanbanViewApi
     */
    publicListDatabaseTableKanbanViewRows(requestParameters, options) {
        return DatabaseTableKanbanViewApiFp(this.configuration).publicListDatabaseTableKanbanViewRows(requestParameters.slug, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.selectOption, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableRowsApi - axios parameter creator
 * @export
 */
const DatabaseTableRowsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates new rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row created webhooks.
         * @param {number} tableId Creates the rows in the table.
         * @param {ExampleBatchRowsRequest} exampleBatchRowsRequest
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [before] If provided then the newly created rows will be positioned before the row with the provided id.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateDatabaseTableRows: (tableId_1, exampleBatchRowsRequest_1, clientSessionId_1, clientUndoRedoActionGroupId_1, before_1, userFieldNames_1, ...args_1) => __awaiter(this, [tableId_1, exampleBatchRowsRequest_1, clientSessionId_1, clientUndoRedoActionGroupId_1, before_1, userFieldNames_1, ...args_1], void 0, function* (tableId, exampleBatchRowsRequest, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('batchCreateDatabaseTableRows', 'tableId', tableId);
            // verify required parameter 'exampleBatchRowsRequest' is not null or undefined
            assertParamExists('batchCreateDatabaseTableRows', 'exampleBatchRowsRequest', exampleBatchRowsRequest);
            const localVarPath = `/database/rows/table/{table_id}/batch/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(exampleBatchRowsRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes existing rows in the table if the user has access to the table\'s workspace.   **WARNING:**  This endpoint doesn\'t yet work with row deleted webhooks.
         * @param {number} tableId Deletes the rows in the table related to the value.
         * @param {BatchDeleteRows} batchDeleteRows
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchDeleteDatabaseTableRows: (tableId_1, batchDeleteRows_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [tableId_1, batchDeleteRows_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (tableId, batchDeleteRows, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('batchDeleteDatabaseTableRows', 'tableId', tableId);
            // verify required parameter 'batchDeleteRows' is not null or undefined
            assertParamExists('batchDeleteDatabaseTableRows', 'batchDeleteRows', batchDeleteRows);
            const localVarPath = `/database/rows/table/{table_id}/batch-delete/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(batchDeleteRows, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates existing rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided for each row. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row updated webhooks.
         * @param {number} tableId Updates the rows in the table.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {PatchedExampleBatchUpdateRowsRequest} [patchedExampleBatchUpdateRowsRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateDatabaseTableRows: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, userFieldNames_1, patchedExampleBatchUpdateRowsRequest_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, userFieldNames_1, patchedExampleBatchUpdateRowsRequest_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleBatchUpdateRowsRequest, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('batchUpdateDatabaseTableRows', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/batch/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExampleBatchUpdateRowsRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {number} tableId Creates a row in the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [before] If provided then the newly created row will be positioned before the row with the provided id.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {ExampleRowRequestSerializerWithUserFieldNames} [exampleRowRequestSerializerWithUserFieldNames]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableRow: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, before_1, userFieldNames_1, exampleRowRequestSerializerWithUserFieldNames_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, before_1, userFieldNames_1, exampleRowRequestSerializerWithUserFieldNames_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, exampleRowRequestSerializerWithUserFieldNames, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('createDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(exampleRowRequestSerializerWithUserFieldNames, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a comment on the specified row.  This is a **premium** feature.
         * @param {number} rowId The row to create a comment for.
         * @param {number} tableId The table to find the row to comment on in.
         * @param {RowCommentCreate} rowCommentCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRowComment: (rowId_1, tableId_1, rowCommentCreate_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, rowCommentCreate_1, ...args_1], void 0, function* (rowId, tableId, rowCommentCreate, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('createRowComment', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('createRowComment', 'tableId', tableId);
            // verify required parameter 'rowCommentCreate' is not null or undefined
            assertParamExists('createRowComment', 'rowCommentCreate', rowCommentCreate);
            const localVarPath = `/row_comments/{table_id}/{row_id}/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(rowCommentCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an existing row in the table if the user has access to the table\'s workspace.
         * @param {number} rowId Deletes the row related to the value.
         * @param {number} tableId Deletes the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableRow: (rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('deleteDatabaseTableRow', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('deleteDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a row comment.  This is a **premium** feature.
         * @param {number} commentId The row comment to delete.
         * @param {number} tableId The table the row is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRowComment: (commentId_1, tableId_1, ...args_1) => __awaiter(this, [commentId_1, tableId_1, ...args_1], void 0, function* (commentId, tableId, options = {}) {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteRowComment', 'commentId', commentId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('deleteRowComment', 'tableId', tableId);
            const localVarPath = `/row_comments/{table_id}/comment/{comment_id}/`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetches the adjacent row to a given row_id in the table with the given table_id. If the previous flag is set it will return the previous row, otherwise it will return the next row. You can specifya view_id and it will apply the filters and sorts of the provided view.
         * @param {number} rowId Returns the row adjacent the provided value.
         * @param {number} tableId Returns the row of the table related to the provided value.
         * @param {boolean} [previous] A flag query parameter which if provided returns theprevious row to the specified row_id. If it\&#39;s not setit will return the next row.
         * @param {string} [search] If provided, the adjacent row will be one that matchesthe search query.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {number} [viewId] Applies the filters and sorts of the provided view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdjacentDatabaseTableRow: (rowId_1, tableId_1, previous_1, search_1, searchMode_1, userFieldNames_1, viewId_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, previous_1, search_1, searchMode_1, userFieldNames_1, viewId_1, ...args_1], void 0, function* (rowId, tableId, previous, search, searchMode, userFieldNames, viewId, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('getAdjacentDatabaseTableRow', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('getAdjacentDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/adjacent/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (viewId !== undefined) {
                localVarQueryParameter['view_id'] = viewId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetches an existing row from the table if the user has access to the related table\'s workspace. The properties of the returned row depend on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} rowId Returns the row related the provided value.
         * @param {number} tableId Returns the row of the table related to the provided value.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRow: (rowId_1, tableId_1, userFieldNames_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, userFieldNames_1, ...args_1], void 0, function* (rowId, tableId, userFieldNames, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('getDatabaseTableRow', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('getDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetches the row change history of a given row_id in the table with the given table_id. The row change history is paginated and can be limited with the limit and offset query parameters.
         * @param {number} rowId The id of the row to fetch the change history from.
         * @param {number} tableId The id of the table to fetch the row change history from.
         * @param {number} [limit] The maximum number of row change history entries to return.
         * @param {number} [offset] The offset of the row change history entries to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRowHistory: (rowId_1, tableId_1, limit_1, offset_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, limit_1, offset_1, ...args_1], void 0, function* (rowId, tableId, limit, offset, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('getDatabaseTableRowHistory', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('getDatabaseTableRowHistory', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/history/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all row comments for the specified table and row.  This is a **premium** feature.
         * @param {number} rowId The row to get row comments for.
         * @param {number} tableId The table the row is in.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRowComments: (rowId_1, tableId_1, limit_1, offset_1, page_1, size_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, limit_1, offset_1, page_1, size_1, ...args_1], void 0, function* (rowId, tableId, limit, offset, page, size, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('getRowComments', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('getRowComments', 'tableId', tableId);
            const localVarPath = `/row_comments/{table_id}/{row_id}/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the names of the given row of the given tables. The nameof a row is the primary field value for this row. The result can be usedfor example, when you want to display the name of a linked row from another table.
         * @param {string} [tableId] A list of comma separated row ids to query from the table with id {id}. For example, if you want the name of row &#x60;42&#x60; and &#x60;43&#x60; from table &#x60;28&#x60; this parameter will be &#x60;table__28&#x3D;42,43&#x60;. You can specify multiple rows for different tables but every tables must be in the same database. You need at least read permission on all specified tables.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRowNames: (tableId_1, ...args_1) => __awaiter(this, [tableId_1, ...args_1], void 0, function* (tableId, options = {}) {
            const localVarPath = `/database/rows/names/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (tableId !== undefined) {
                localVarQueryParameter['table__{id}'] = tableId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the rows of the table related to the provided parameter if the user has access to the related database\'s workspace. The response is paginated by a page/size style. It is also possible to provide an optional search query, only rows where the data matches the search query are going to be returned then. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} tableId Returns the rows of the table related to the provided value.
         * @param {string} [exclude] All the fields are included in the response by default. You can select a subset of fields by providing the exclude query parameter. If you for example provide the following GET parameter &#x60;exclude&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response. If the &#x60;user_field_names&#x60; parameter is provided then instead exclude should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;exclude&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;exclude&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;. The &#x60;field&#x60; value must be the ID of the field to filter on, or the name of the field if &#x60;user_field_names&#x60; is true.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [include] All the fields are included in the response by default. You can select a subset of fields by providing the include query parameter. If you for example provide the following GET parameter &#x60;include&#x3D;field_1,field_2&#x60; then only the fields withid &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response. If the &#x60;user_field_names&#x60; parameter is provided then instead include should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;include&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;include&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A). If the &#x60;user_field_names&#x60; parameter is provided then instead order_by should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;order_by&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;order_by&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {number} [page] Defines which page of rows should be returned.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Defines how many rows should be returned per page.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {number} [viewId] Includes all the filters and sorts of the provided view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRows: (tableId_1, exclude_1, filterFieldFilter_1, filterType_1, filters_1, include_1, orderBy_1, page_1, search_1, searchMode_1, size_1, userFieldNames_1, viewId_1, ...args_1) => __awaiter(this, [tableId_1, exclude_1, filterFieldFilter_1, filterType_1, filters_1, include_1, orderBy_1, page_1, search_1, searchMode_1, size_1, userFieldNames_1, viewId_1, ...args_1], void 0, function* (tableId, exclude, filterFieldFilter, filterType, filters, include, orderBy, page, search, searchMode, size, userFieldNames, viewId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('listDatabaseTableRows', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }
            if (filterFieldFilter !== undefined) {
                localVarQueryParameter['filter__{field}__{filter}'] = filterFieldFilter;
            }
            if (filterType !== undefined) {
                localVarQueryParameter['filter_type'] = filterType;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (viewId !== undefined) {
                localVarQueryParameter['view_id'] = viewId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Moves the row related to given `row_id` parameter to another position. It is only possible to move the row before another existing row or to the end. If the `before_id` is provided then the row related to the `row_id` parameter is moved before that row. If the `before_id` parameter is not provided, then the row will be moved to the end.
         * @param {number} rowId Moves the row related to the value.
         * @param {number} tableId Moves the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [beforeId] Moves the row related to the given &#x60;row_id&#x60; before the row related to the provided value. If not provided, then the row will be moved to the end.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDatabaseTableRow: (rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, beforeId_1, userFieldNames_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, beforeId_1, userFieldNames_1, ...args_1], void 0, function* (rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, beforeId, userFieldNames, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('moveDatabaseTableRow', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('moveDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/move/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (beforeId !== undefined) {
                localVarQueryParameter['before_id'] = beforeId;
            }
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {number} rowId Updates the row related to the value.
         * @param {number} tableId Updates the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {PatchedExampleUpdateRowRequestSerializerWithUserFieldNames} [patchedExampleUpdateRowRequestSerializerWithUserFieldNames]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableRow: (rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, userFieldNames_1, patchedExampleUpdateRowRequestSerializerWithUserFieldNames_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, userFieldNames_1, patchedExampleUpdateRowRequestSerializerWithUserFieldNames_1, ...args_1], void 0, function* (rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleUpdateRowRequestSerializerWithUserFieldNames, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('updateDatabaseTableRow', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('updateDatabaseTableRow', 'tableId', tableId);
            const localVarPath = `/database/rows/table/{table_id}/{row_id}/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (userFieldNames !== undefined) {
                localVarQueryParameter['user_field_names'] = userFieldNames;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExampleUpdateRowRequestSerializerWithUserFieldNames, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a row comment.  This is a **premium** feature.
         * @param {number} commentId The row comment to update.
         * @param {number} tableId The table the row is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowComment: (commentId_1, tableId_1, ...args_1) => __awaiter(this, [commentId_1, tableId_1, ...args_1], void 0, function* (commentId, tableId, options = {}) {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateRowComment', 'commentId', commentId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('updateRowComment', 'tableId', tableId);
            const localVarPath = `/row_comments/{table_id}/comment/{comment_id}/`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the user\'s notification preferences for comments made on a specified table row.  This is a **premium** feature.
         * @param {number} rowId The row on which to manage the comment subscription.
         * @param {number} tableId The table id where the row is in.
         * @param {RowCommentsNotificationMode} rowCommentsNotificationMode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowCommentNotificationMode: (rowId_1, tableId_1, rowCommentsNotificationMode_1, ...args_1) => __awaiter(this, [rowId_1, tableId_1, rowCommentsNotificationMode_1, ...args_1], void 0, function* (rowId, tableId, rowCommentsNotificationMode, options = {}) {
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('updateRowCommentNotificationMode', 'rowId', rowId);
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('updateRowCommentNotificationMode', 'tableId', tableId);
            // verify required parameter 'rowCommentsNotificationMode' is not null or undefined
            assertParamExists('updateRowCommentNotificationMode', 'rowCommentsNotificationMode', rowCommentsNotificationMode);
            const localVarPath = `/row_comments/{table_id}/{row_id}/notification-mode/`
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)))
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(rowCommentsNotificationMode, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableRowsApi - functional programming interface
 * @export
 */
const DatabaseTableRowsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableRowsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates new rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row created webhooks.
         * @param {number} tableId Creates the rows in the table.
         * @param {ExampleBatchRowsRequest} exampleBatchRowsRequest
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [before] If provided then the newly created rows will be positioned before the row with the provided id.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateDatabaseTableRows(tableId, exampleBatchRowsRequest, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchCreateDatabaseTableRows(tableId, exampleBatchRowsRequest, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.batchCreateDatabaseTableRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes existing rows in the table if the user has access to the table\'s workspace.   **WARNING:**  This endpoint doesn\'t yet work with row deleted webhooks.
         * @param {number} tableId Deletes the rows in the table related to the value.
         * @param {BatchDeleteRows} batchDeleteRows
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchDeleteDatabaseTableRows(tableId, batchDeleteRows, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchDeleteDatabaseTableRows(tableId, batchDeleteRows, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.batchDeleteDatabaseTableRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates existing rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided for each row. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row updated webhooks.
         * @param {number} tableId Updates the rows in the table.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {PatchedExampleBatchUpdateRowsRequest} [patchedExampleBatchUpdateRowsRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateDatabaseTableRows(tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleBatchUpdateRowsRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchUpdateDatabaseTableRows(tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleBatchUpdateRowsRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.batchUpdateDatabaseTableRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {number} tableId Creates a row in the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [before] If provided then the newly created row will be positioned before the row with the provided id.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {ExampleRowRequestSerializerWithUserFieldNames} [exampleRowRequestSerializerWithUserFieldNames]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableRow(tableId, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, exampleRowRequestSerializerWithUserFieldNames, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableRow(tableId, clientSessionId, clientUndoRedoActionGroupId, before, userFieldNames, exampleRowRequestSerializerWithUserFieldNames, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.createDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a comment on the specified row.  This is a **premium** feature.
         * @param {number} rowId The row to create a comment for.
         * @param {number} tableId The table to find the row to comment on in.
         * @param {RowCommentCreate} rowCommentCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRowComment(rowId, tableId, rowCommentCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRowComment(rowId, tableId, rowCommentCreate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.createRowComment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an existing row in the table if the user has access to the table\'s workspace.
         * @param {number} rowId Deletes the row related to the value.
         * @param {number} tableId Deletes the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.deleteDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a row comment.  This is a **premium** feature.
         * @param {number} commentId The row comment to delete.
         * @param {number} tableId The table the row is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRowComment(commentId, tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRowComment(commentId, tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.deleteRowComment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetches the adjacent row to a given row_id in the table with the given table_id. If the previous flag is set it will return the previous row, otherwise it will return the next row. You can specifya view_id and it will apply the filters and sorts of the provided view.
         * @param {number} rowId Returns the row adjacent the provided value.
         * @param {number} tableId Returns the row of the table related to the provided value.
         * @param {boolean} [previous] A flag query parameter which if provided returns theprevious row to the specified row_id. If it\&#39;s not setit will return the next row.
         * @param {string} [search] If provided, the adjacent row will be one that matchesthe search query.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {number} [viewId] Applies the filters and sorts of the provided view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdjacentDatabaseTableRow(rowId, tableId, previous, search, searchMode, userFieldNames, viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAdjacentDatabaseTableRow(rowId, tableId, previous, search, searchMode, userFieldNames, viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.getAdjacentDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetches an existing row from the table if the user has access to the related table\'s workspace. The properties of the returned row depend on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} rowId Returns the row related the provided value.
         * @param {number} tableId Returns the row of the table related to the provided value.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRow(rowId, tableId, userFieldNames, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableRow(rowId, tableId, userFieldNames, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.getDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetches the row change history of a given row_id in the table with the given table_id. The row change history is paginated and can be limited with the limit and offset query parameters.
         * @param {number} rowId The id of the row to fetch the change history from.
         * @param {number} tableId The id of the table to fetch the row change history from.
         * @param {number} [limit] The maximum number of row change history entries to return.
         * @param {number} [offset] The offset of the row change history entries to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRowHistory(rowId, tableId, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableRowHistory(rowId, tableId, limit, offset, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.getDatabaseTableRowHistory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all row comments for the specified table and row.  This is a **premium** feature.
         * @param {number} rowId The row to get row comments for.
         * @param {number} tableId The table the row is in.
         * @param {number} [limit] Defines how many rows should be returned.
         * @param {number} [offset] Can only be used in combination with the &#x60;limit&#x60; parameter and defines from which offset the rows should be returned.
         * @param {number} [page] Defines which page of rows should be returned. Either the &#x60;page&#x60; or &#x60;limit&#x60; can be provided, not both.
         * @param {number} [size] Can only be used in combination with the &#x60;page&#x60; parameter and defines how many rows should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRowComments(rowId, tableId, limit, offset, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRowComments(rowId, tableId, limit, offset, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.getRowComments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the names of the given row of the given tables. The nameof a row is the primary field value for this row. The result can be usedfor example, when you want to display the name of a linked row from another table.
         * @param {string} [tableId] A list of comma separated row ids to query from the table with id {id}. For example, if you want the name of row &#x60;42&#x60; and &#x60;43&#x60; from table &#x60;28&#x60; this parameter will be &#x60;table__28&#x3D;42,43&#x60;. You can specify multiple rows for different tables but every tables must be in the same database. You need at least read permission on all specified tables.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRowNames(tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableRowNames(tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.listDatabaseTableRowNames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the rows of the table related to the provided parameter if the user has access to the related database\'s workspace. The response is paginated by a page/size style. It is also possible to provide an optional search query, only rows where the data matches the search query are going to be returned then. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {number} tableId Returns the rows of the table related to the provided value.
         * @param {string} [exclude] All the fields are included in the response by default. You can select a subset of fields by providing the exclude query parameter. If you for example provide the following GET parameter &#x60;exclude&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response. If the &#x60;user_field_names&#x60; parameter is provided then instead exclude should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;exclude&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;exclude&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {string} [filterFieldFilter] The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.   For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [filterType] &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.Please note that if the &#x60;filters&#x60; parameter is provided, this parameter will be ignored.
         * @param {string} [filters] A JSON serialized string containing the filter tree to apply to this view. The filter tree is a nested structure containing the filters that need to be applied.   Please note that if this parameter is provided, all other &#x60;filter__{field}__{filter}&#x60; will be ignored, as well as the &#x60;filter_type&#x60; parameter.   An example of a valid filter tree is the following:&#x60;{\&quot;filter_type\&quot;: \&quot;AND\&quot;, \&quot;filters\&quot;: [{\&quot;field\&quot;: 1, \&quot;type\&quot;: \&quot;equal\&quot;, \&quot;value\&quot;: \&quot;test\&quot;}]}&#x60;. The &#x60;field&#x60; value must be the ID of the field to filter on, or the name of the field if &#x60;user_field_names&#x60; is true.  The following filters are available: equal, not_equal, filename_contains, files_lower_than, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, higher_than_or_equal, lower_than, lower_than_or_equal, is_even_and_whole, date_equal, date_before, date_before_or_equal, date_after_days_ago, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, date_is, date_is_not, date_is_before, date_is_on_or_before, date_is_after, date_is_on_or_after, date_is_within, single_select_equal, single_select_not_equal, single_select_is_any_of, single_select_is_none_of, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not, user_is, user_is_not, has_value_equal, has_not_value_equal, has_value_contains, has_not_value_contains, has_value_contains_word, has_not_value_contains_word, has_value_length_is_lower_than, has_empty_value, has_not_empty_value.
         * @param {string} [include] All the fields are included in the response by default. You can select a subset of fields by providing the include query parameter. If you for example provide the following GET parameter &#x60;include&#x3D;field_1,field_2&#x60; then only the fields withid &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response. If the &#x60;user_field_names&#x60; parameter is provided then instead include should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;include&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;include&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {string} [orderBy] Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a \&#39;-\&#39; it can be ordered descending (Z-A). If the &#x60;user_field_names&#x60; parameter is provided then instead order_by should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;order_by&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;order_by&#x3D;My Field,Field with \\\&quot;&#x60;.
         * @param {number} [page] Defines which page of rows should be returned.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {number} [size] Defines how many rows should be returned per page.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {number} [viewId] Includes all the filters and sorts of the provided view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRows(tableId, exclude, filterFieldFilter, filterType, filters, include, orderBy, page, search, searchMode, size, userFieldNames, viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableRows(tableId, exclude, filterFieldFilter, filterType, filters, include, orderBy, page, search, searchMode, size, userFieldNames, viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.listDatabaseTableRows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Moves the row related to given `row_id` parameter to another position. It is only possible to move the row before another existing row or to the end. If the `before_id` is provided then the row related to the `row_id` parameter is moved before that row. If the `before_id` parameter is not provided, then the row will be moved to the end.
         * @param {number} rowId Moves the row related to the value.
         * @param {number} tableId Moves the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {number} [beforeId] Moves the row related to the given &#x60;row_id&#x60; before the row related to the provided value. If not provided, then the row will be moved to the end.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause the returned JSON to use the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, beforeId, userFieldNames, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.moveDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, beforeId, userFieldNames, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.moveDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {number} rowId Updates the row related to the value.
         * @param {number} tableId Updates the row in the table related to the value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {boolean} [userFieldNames] A flag query parameter that, if provided with one of the following values: &#x60;y&#x60;, &#x60;yes&#x60;, &#x60;true&#x60;, &#x60;t&#x60;, &#x60;on&#x60;, &#x60;1&#x60;, or an empty value, will cause this endpoint to expect and return the user-specified field names instead of the internal Baserow field names (e.g., field_123).
         * @param {PatchedExampleUpdateRowRequestSerializerWithUserFieldNames} [patchedExampleUpdateRowRequestSerializerWithUserFieldNames]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleUpdateRowRequestSerializerWithUserFieldNames, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableRow(rowId, tableId, clientSessionId, clientUndoRedoActionGroupId, userFieldNames, patchedExampleUpdateRowRequestSerializerWithUserFieldNames, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.updateDatabaseTableRow']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a row comment.  This is a **premium** feature.
         * @param {number} commentId The row comment to update.
         * @param {number} tableId The table the row is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowComment(commentId, tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRowComment(commentId, tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.updateRowComment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the user\'s notification preferences for comments made on a specified table row.  This is a **premium** feature.
         * @param {number} rowId The row on which to manage the comment subscription.
         * @param {number} tableId The table id where the row is in.
         * @param {RowCommentsNotificationMode} rowCommentsNotificationMode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowCommentNotificationMode(rowId, tableId, rowCommentsNotificationMode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRowCommentNotificationMode(rowId, tableId, rowCommentsNotificationMode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableRowsApi.updateRowCommentNotificationMode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableRowsApi - factory interface
 * @export
 */
const DatabaseTableRowsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableRowsApiFp(configuration);
    return {
        /**
         * Creates new rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row created webhooks.
         * @param {DatabaseTableRowsApiBatchCreateDatabaseTableRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateDatabaseTableRows(requestParameters, options) {
            return localVarFp.batchCreateDatabaseTableRows(requestParameters.tableId, requestParameters.exampleBatchRowsRequest, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.before, requestParameters.userFieldNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes existing rows in the table if the user has access to the table\'s workspace.   **WARNING:**  This endpoint doesn\'t yet work with row deleted webhooks.
         * @param {DatabaseTableRowsApiBatchDeleteDatabaseTableRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchDeleteDatabaseTableRows(requestParameters, options) {
            return localVarFp.batchDeleteDatabaseTableRows(requestParameters.tableId, requestParameters.batchDeleteRows, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates existing rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided for each row. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row updated webhooks.
         * @param {DatabaseTableRowsApiBatchUpdateDatabaseTableRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateDatabaseTableRows(requestParameters, options) {
            return localVarFp.batchUpdateDatabaseTableRows(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.userFieldNames, requestParameters.patchedExampleBatchUpdateRowsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {DatabaseTableRowsApiCreateDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableRow(requestParameters, options) {
            return localVarFp.createDatabaseTableRow(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.before, requestParameters.userFieldNames, requestParameters.exampleRowRequestSerializerWithUserFieldNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a comment on the specified row.  This is a **premium** feature.
         * @param {DatabaseTableRowsApiCreateRowCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRowComment(requestParameters, options) {
            return localVarFp.createRowComment(requestParameters.rowId, requestParameters.tableId, requestParameters.rowCommentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing row in the table if the user has access to the table\'s workspace.
         * @param {DatabaseTableRowsApiDeleteDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableRow(requestParameters, options) {
            return localVarFp.deleteDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a row comment.  This is a **premium** feature.
         * @param {DatabaseTableRowsApiDeleteRowCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRowComment(requestParameters, options) {
            return localVarFp.deleteRowComment(requestParameters.commentId, requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the adjacent row to a given row_id in the table with the given table_id. If the previous flag is set it will return the previous row, otherwise it will return the next row. You can specifya view_id and it will apply the filters and sorts of the provided view.
         * @param {DatabaseTableRowsApiGetAdjacentDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdjacentDatabaseTableRow(requestParameters, options) {
            return localVarFp.getAdjacentDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.previous, requestParameters.search, requestParameters.searchMode, requestParameters.userFieldNames, requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches an existing row from the table if the user has access to the related table\'s workspace. The properties of the returned row depend on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {DatabaseTableRowsApiGetDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRow(requestParameters, options) {
            return localVarFp.getDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.userFieldNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the row change history of a given row_id in the table with the given table_id. The row change history is paginated and can be limited with the limit and offset query parameters.
         * @param {DatabaseTableRowsApiGetDatabaseTableRowHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableRowHistory(requestParameters, options) {
            return localVarFp.getDatabaseTableRowHistory(requestParameters.rowId, requestParameters.tableId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all row comments for the specified table and row.  This is a **premium** feature.
         * @param {DatabaseTableRowsApiGetRowCommentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRowComments(requestParameters, options) {
            return localVarFp.getRowComments(requestParameters.rowId, requestParameters.tableId, requestParameters.limit, requestParameters.offset, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the names of the given row of the given tables. The nameof a row is the primary field value for this row. The result can be usedfor example, when you want to display the name of a linked row from another table.
         * @param {DatabaseTableRowsApiListDatabaseTableRowNamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRowNames(requestParameters = {}, options) {
            return localVarFp.listDatabaseTableRowNames(requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the rows of the table related to the provided parameter if the user has access to the related database\'s workspace. The response is paginated by a page/size style. It is also possible to provide an optional search query, only rows where the data matches the search query are going to be returned then. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
         * @param {DatabaseTableRowsApiListDatabaseTableRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableRows(requestParameters, options) {
            return localVarFp.listDatabaseTableRows(requestParameters.tableId, requestParameters.exclude, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, requestParameters.userFieldNames, requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves the row related to given `row_id` parameter to another position. It is only possible to move the row before another existing row or to the end. If the `before_id` is provided then the row related to the `row_id` parameter is moved before that row. If the `before_id` parameter is not provided, then the row will be moved to the end.
         * @param {DatabaseTableRowsApiMoveDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDatabaseTableRow(requestParameters, options) {
            return localVarFp.moveDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.beforeId, requestParameters.userFieldNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
         * @param {DatabaseTableRowsApiUpdateDatabaseTableRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableRow(requestParameters, options) {
            return localVarFp.updateDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.userFieldNames, requestParameters.patchedExampleUpdateRowRequestSerializerWithUserFieldNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a row comment.  This is a **premium** feature.
         * @param {DatabaseTableRowsApiUpdateRowCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowComment(requestParameters, options) {
            return localVarFp.updateRowComment(requestParameters.commentId, requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user\'s notification preferences for comments made on a specified table row.  This is a **premium** feature.
         * @param {DatabaseTableRowsApiUpdateRowCommentNotificationModeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRowCommentNotificationMode(requestParameters, options) {
            return localVarFp.updateRowCommentNotificationMode(requestParameters.rowId, requestParameters.tableId, requestParameters.rowCommentsNotificationMode, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableRowsApi - object-oriented interface
 * @export
 * @class DatabaseTableRowsApi
 * @extends {BaseAPI}
 */
class DatabaseTableRowsApi extends BaseAPI {
    /**
     * Creates new rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row created webhooks.
     * @param {DatabaseTableRowsApiBatchCreateDatabaseTableRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    batchCreateDatabaseTableRows(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).batchCreateDatabaseTableRows(requestParameters.tableId, requestParameters.exampleBatchRowsRequest, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.before, requestParameters.userFieldNames, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes existing rows in the table if the user has access to the table\'s workspace.   **WARNING:**  This endpoint doesn\'t yet work with row deleted webhooks.
     * @param {DatabaseTableRowsApiBatchDeleteDatabaseTableRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    batchDeleteDatabaseTableRows(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).batchDeleteDatabaseTableRows(requestParameters.tableId, requestParameters.batchDeleteRows, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates existing rows in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided for each row. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.   **WARNING:** This endpoint doesn\'t yet work with row updated webhooks.
     * @param {DatabaseTableRowsApiBatchUpdateDatabaseTableRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    batchUpdateDatabaseTableRows(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).batchUpdateDatabaseTableRows(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.userFieldNames, requestParameters.patchedExampleBatchUpdateRowsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
     * @param {DatabaseTableRowsApiCreateDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    createDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).createDatabaseTableRow(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.before, requestParameters.userFieldNames, requestParameters.exampleRowRequestSerializerWithUserFieldNames, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a comment on the specified row.  This is a **premium** feature.
     * @param {DatabaseTableRowsApiCreateRowCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    createRowComment(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).createRowComment(requestParameters.rowId, requestParameters.tableId, requestParameters.rowCommentCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an existing row in the table if the user has access to the table\'s workspace.
     * @param {DatabaseTableRowsApiDeleteDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    deleteDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).deleteDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a row comment.  This is a **premium** feature.
     * @param {DatabaseTableRowsApiDeleteRowCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    deleteRowComment(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).deleteRowComment(requestParameters.commentId, requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the adjacent row to a given row_id in the table with the given table_id. If the previous flag is set it will return the previous row, otherwise it will return the next row. You can specifya view_id and it will apply the filters and sorts of the provided view.
     * @param {DatabaseTableRowsApiGetAdjacentDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    getAdjacentDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).getAdjacentDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.previous, requestParameters.search, requestParameters.searchMode, requestParameters.userFieldNames, requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches an existing row from the table if the user has access to the related table\'s workspace. The properties of the returned row depend on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
     * @param {DatabaseTableRowsApiGetDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    getDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).getDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.userFieldNames, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the row change history of a given row_id in the table with the given table_id. The row change history is paginated and can be limited with the limit and offset query parameters.
     * @param {DatabaseTableRowsApiGetDatabaseTableRowHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    getDatabaseTableRowHistory(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).getDatabaseTableRowHistory(requestParameters.rowId, requestParameters.tableId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all row comments for the specified table and row.  This is a **premium** feature.
     * @param {DatabaseTableRowsApiGetRowCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    getRowComments(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).getRowComments(requestParameters.rowId, requestParameters.tableId, requestParameters.limit, requestParameters.offset, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the names of the given row of the given tables. The nameof a row is the primary field value for this row. The result can be usedfor example, when you want to display the name of a linked row from another table.
     * @param {DatabaseTableRowsApiListDatabaseTableRowNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    listDatabaseTableRowNames(requestParameters = {}, options) {
        return DatabaseTableRowsApiFp(this.configuration).listDatabaseTableRowNames(requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the rows of the table related to the provided parameter if the user has access to the related database\'s workspace. The response is paginated by a page/size style. It is also possible to provide an optional search query, only rows where the data matches the search query are going to be returned then. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.
     * @param {DatabaseTableRowsApiListDatabaseTableRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    listDatabaseTableRows(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).listDatabaseTableRows(requestParameters.tableId, requestParameters.exclude, requestParameters.filterFieldFilter, requestParameters.filterType, requestParameters.filters, requestParameters.include, requestParameters.orderBy, requestParameters.page, requestParameters.search, requestParameters.searchMode, requestParameters.size, requestParameters.userFieldNames, requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Moves the row related to given `row_id` parameter to another position. It is only possible to move the row before another existing row or to the end. If the `before_id` is provided then the row related to the `row_id` parameter is moved before that row. If the `before_id` parameter is not provided, then the row will be moved to the end.
     * @param {DatabaseTableRowsApiMoveDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    moveDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).moveDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.beforeId, requestParameters.userFieldNames, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing row in the table if the user has access to the related table\'s workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.
     * @param {DatabaseTableRowsApiUpdateDatabaseTableRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    updateDatabaseTableRow(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).updateDatabaseTableRow(requestParameters.rowId, requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.userFieldNames, requestParameters.patchedExampleUpdateRowRequestSerializerWithUserFieldNames, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a row comment.  This is a **premium** feature.
     * @param {DatabaseTableRowsApiUpdateRowCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    updateRowComment(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).updateRowComment(requestParameters.commentId, requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the user\'s notification preferences for comments made on a specified table row.  This is a **premium** feature.
     * @param {DatabaseTableRowsApiUpdateRowCommentNotificationModeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableRowsApi
     */
    updateRowCommentNotificationMode(requestParameters, options) {
        return DatabaseTableRowsApiFp(this.configuration).updateRowCommentNotificationMode(requestParameters.rowId, requestParameters.tableId, requestParameters.rowCommentsNotificationMode, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableViewDecorationsApi - axios parameter creator
 * @export
 */
const DatabaseTableViewDecorationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new decoration for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewId Creates a decoration for the view related to the given value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {DecoratorValueProviderTypeCreateViewDecoration} [decoratorValueProviderTypeCreateViewDecoration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewDecoration: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, decoratorValueProviderTypeCreateViewDecoration_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, decoratorValueProviderTypeCreateViewDecoration_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, decoratorValueProviderTypeCreateViewDecoration, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('createDatabaseTableViewDecoration', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/decorations/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(decoratorValueProviderTypeCreateViewDecoration, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Deletes the decoration related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewDecoration: (viewDecorationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewDecorationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewDecorationId' is not null or undefined
            assertParamExists('deleteDatabaseTableViewDecoration', 'viewDecorationId', viewDecorationId);
            const localVarPath = `/database/views/decoration/{view_decoration_id}/`
                .replace(`{${"view_decoration_id"}}`, encodeURIComponent(String(viewDecorationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view decoration if the current user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Returns the view decoration related to the provided id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewDecoration: (viewDecorationId_1, ...args_1) => __awaiter(this, [viewDecorationId_1, ...args_1], void 0, function* (viewDecorationId, options = {}) {
            // verify required parameter 'viewDecorationId' is not null or undefined
            assertParamExists('getDatabaseTableViewDecoration', 'viewDecorationId', viewDecorationId);
            const localVarPath = `/database/views/decoration/{view_decoration_id}/`
                .replace(`{${"view_decoration_id"}}`, encodeURIComponent(String(viewDecorationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all decorations of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple decorations. View decorators can be used to decorate rows. This can, for example, be used to change the border or background color of a row if it matches certain conditions.
         * @param {number} viewId Returns only decoration of the view given to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewDecorations: (viewId_1, ...args_1) => __awaiter(this, [viewId_1, ...args_1], void 0, function* (viewId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableViewDecorations', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/decorations/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Updates the view decoration related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedDecoratorValueProviderTypeUpdateViewDecoration} [patchedDecoratorValueProviderTypeUpdateViewDecoration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewDecoration: (viewDecorationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedDecoratorValueProviderTypeUpdateViewDecoration_1, ...args_1) => __awaiter(this, [viewDecorationId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedDecoratorValueProviderTypeUpdateViewDecoration_1, ...args_1], void 0, function* (viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, patchedDecoratorValueProviderTypeUpdateViewDecoration, options = {}) {
            // verify required parameter 'viewDecorationId' is not null or undefined
            assertParamExists('updateDatabaseTableViewDecoration', 'viewDecorationId', viewDecorationId);
            const localVarPath = `/database/views/decoration/{view_decoration_id}/`
                .replace(`{${"view_decoration_id"}}`, encodeURIComponent(String(viewDecorationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDecoratorValueProviderTypeUpdateViewDecoration, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableViewDecorationsApi - functional programming interface
 * @export
 */
const DatabaseTableViewDecorationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableViewDecorationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new decoration for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewId Creates a decoration for the view related to the given value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {DecoratorValueProviderTypeCreateViewDecoration} [decoratorValueProviderTypeCreateViewDecoration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewDecoration(viewId, clientSessionId, clientUndoRedoActionGroupId, decoratorValueProviderTypeCreateViewDecoration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableViewDecoration(viewId, clientSessionId, clientUndoRedoActionGroupId, decoratorValueProviderTypeCreateViewDecoration, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewDecorationsApi.createDatabaseTableViewDecoration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Deletes the decoration related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewDecoration(viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableViewDecoration(viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewDecorationsApi.deleteDatabaseTableViewDecoration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view decoration if the current user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Returns the view decoration related to the provided id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewDecoration(viewDecorationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewDecoration(viewDecorationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewDecorationsApi.getDatabaseTableViewDecoration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all decorations of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple decorations. View decorators can be used to decorate rows. This can, for example, be used to change the border or background color of a row if it matches certain conditions.
         * @param {number} viewId Returns only decoration of the view given to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewDecorations(viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableViewDecorations(viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewDecorationsApi.listDatabaseTableViewDecorations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {number} viewDecorationId Updates the view decoration related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedDecoratorValueProviderTypeUpdateViewDecoration} [patchedDecoratorValueProviderTypeUpdateViewDecoration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewDecoration(viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, patchedDecoratorValueProviderTypeUpdateViewDecoration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewDecoration(viewDecorationId, clientSessionId, clientUndoRedoActionGroupId, patchedDecoratorValueProviderTypeUpdateViewDecoration, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewDecorationsApi.updateDatabaseTableViewDecoration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableViewDecorationsApi - factory interface
 * @export
 */
const DatabaseTableViewDecorationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableViewDecorationsApiFp(configuration);
    return {
        /**
         * Creates a new decoration for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewDecorationsApiCreateDatabaseTableViewDecorationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewDecoration(requestParameters, options) {
            return localVarFp.createDatabaseTableViewDecoration(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.decoratorValueProviderTypeCreateViewDecoration, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewDecorationsApiDeleteDatabaseTableViewDecorationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewDecoration(requestParameters, options) {
            return localVarFp.deleteDatabaseTableViewDecoration(requestParameters.viewDecorationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view decoration if the current user has access to the related database\'s workspace.
         * @param {DatabaseTableViewDecorationsApiGetDatabaseTableViewDecorationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewDecoration(requestParameters, options) {
            return localVarFp.getDatabaseTableViewDecoration(requestParameters.viewDecorationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all decorations of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple decorations. View decorators can be used to decorate rows. This can, for example, be used to change the border or background color of a row if it matches certain conditions.
         * @param {DatabaseTableViewDecorationsApiListDatabaseTableViewDecorationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewDecorations(requestParameters, options) {
            return localVarFp.listDatabaseTableViewDecorations(requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing decoration if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewDecorationsApiUpdateDatabaseTableViewDecorationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewDecoration(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewDecoration(requestParameters.viewDecorationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedDecoratorValueProviderTypeUpdateViewDecoration, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableViewDecorationsApi - object-oriented interface
 * @export
 * @class DatabaseTableViewDecorationsApi
 * @extends {BaseAPI}
 */
class DatabaseTableViewDecorationsApi extends BaseAPI {
    /**
     * Creates a new decoration for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewDecorationsApiCreateDatabaseTableViewDecorationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewDecorationsApi
     */
    createDatabaseTableViewDecoration(requestParameters, options) {
        return DatabaseTableViewDecorationsApiFp(this.configuration).createDatabaseTableViewDecoration(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.decoratorValueProviderTypeCreateViewDecoration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing decoration if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewDecorationsApiDeleteDatabaseTableViewDecorationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewDecorationsApi
     */
    deleteDatabaseTableViewDecoration(requestParameters, options) {
        return DatabaseTableViewDecorationsApiFp(this.configuration).deleteDatabaseTableViewDecoration(requestParameters.viewDecorationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view decoration if the current user has access to the related database\'s workspace.
     * @param {DatabaseTableViewDecorationsApiGetDatabaseTableViewDecorationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewDecorationsApi
     */
    getDatabaseTableViewDecoration(requestParameters, options) {
        return DatabaseTableViewDecorationsApiFp(this.configuration).getDatabaseTableViewDecoration(requestParameters.viewDecorationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all decorations of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple decorations. View decorators can be used to decorate rows. This can, for example, be used to change the border or background color of a row if it matches certain conditions.
     * @param {DatabaseTableViewDecorationsApiListDatabaseTableViewDecorationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewDecorationsApi
     */
    listDatabaseTableViewDecorations(requestParameters, options) {
        return DatabaseTableViewDecorationsApiFp(this.configuration).listDatabaseTableViewDecorations(requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing decoration if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewDecorationsApiUpdateDatabaseTableViewDecorationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewDecorationsApi
     */
    updateDatabaseTableViewDecoration(requestParameters, options) {
        return DatabaseTableViewDecorationsApiFp(this.configuration).updateDatabaseTableViewDecoration(requestParameters.viewDecorationId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedDecoratorValueProviderTypeUpdateViewDecoration, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableViewFiltersApi - axios parameter creator
 * @export
 */
const DatabaseTableViewFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new filter for the view related to the provided `view_id` parameter. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, then only the rows that apply to all the filters are going to be returned. A filter compares the value of a field to the value of a filter. It depends on the type how values are going to be compared.
         * @param {number} viewId Creates a filter for the view related to the provided value.
         * @param {CreateViewFilter} createViewFilter
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilter: (viewId_1, createViewFilter_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, createViewFilter_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, createViewFilter, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('createDatabaseTableViewFilter', 'viewId', viewId);
            // verify required parameter 'createViewFilter' is not null or undefined
            assertParamExists('createDatabaseTableViewFilter', 'createViewFilter', createViewFilter);
            const localVarPath = `/database/views/{view_id}/filters/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createViewFilter, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new filter group for the view related to the provided `view_id` parameter.
         * @param {number} viewId The ID of the view where create the new filter group.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {CreateViewFilterGroup} [createViewFilterGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilterGroup: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, createViewFilterGroup_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, createViewFilterGroup_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, createViewFilterGroup, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('createDatabaseTableViewFilterGroup', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/filter-groups/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createViewFilterGroup, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing filter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewFilterId The ID of the view filter to delete.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilter: (viewFilterId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewFilterId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewFilterId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewFilterId' is not null or undefined
            assertParamExists('deleteDatabaseTableViewFilter', 'viewFilterId', viewFilterId);
            const localVarPath = `/database/views/filter/{view_filter_id}/`
                .replace(`{${"view_filter_id"}}`, encodeURIComponent(String(viewFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId The ID of the view filter group to delete.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilterGroup: (filterGroupId_1, viewFilterGroupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [filterGroupId_1, viewFilterGroupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'filterGroupId' is not null or undefined
            assertParamExists('deleteDatabaseTableViewFilterGroup', 'filterGroupId', filterGroupId);
            // verify required parameter 'viewFilterGroupId' is not null or undefined
            assertParamExists('deleteDatabaseTableViewFilterGroup', 'viewFilterGroupId', viewFilterGroupId);
            const localVarPath = `/database/views/filter-group/{filter_group_id}/`
                .replace(`{${"filter_group_id"}}`, encodeURIComponent(String(filterGroupId)))
                .replace(`{${"view_filter_group_id"}}`, encodeURIComponent(String(viewFilterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view filter.
         * @param {number} viewFilterId The ID of the view filter to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilter: (viewFilterId_1, ...args_1) => __awaiter(this, [viewFilterId_1, ...args_1], void 0, function* (viewFilterId, options = {}) {
            // verify required parameter 'viewFilterId' is not null or undefined
            assertParamExists('getDatabaseTableViewFilter', 'viewFilterId', viewFilterId);
            const localVarPath = `/database/views/filter/{view_filter_id}/`
                .replace(`{${"view_filter_id"}}`, encodeURIComponent(String(viewFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId Teh ID of the view filter group to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilterGroup: (filterGroupId_1, viewFilterGroupId_1, ...args_1) => __awaiter(this, [filterGroupId_1, viewFilterGroupId_1, ...args_1], void 0, function* (filterGroupId, viewFilterGroupId, options = {}) {
            // verify required parameter 'filterGroupId' is not null or undefined
            assertParamExists('getDatabaseTableViewFilterGroup', 'filterGroupId', filterGroupId);
            // verify required parameter 'viewFilterGroupId' is not null or undefined
            assertParamExists('getDatabaseTableViewFilterGroup', 'viewFilterGroupId', viewFilterGroupId);
            const localVarPath = `/database/views/filter-group/{filter_group_id}/`
                .replace(`{${"filter_group_id"}}`, encodeURIComponent(String(filterGroupId)))
                .replace(`{${"view_filter_group_id"}}`, encodeURIComponent(String(viewFilterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all filters of the view related to the provided `view_id`. A view can have multiple filters. When all the rows are requested for the view only those that apply to the filters are returned.
         * @param {number} viewId Returns only filters of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewFilters: (viewId_1, ...args_1) => __awaiter(this, [viewId_1, ...args_1], void 0, function* (viewId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableViewFilters', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/filters/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing filter.
         * @param {number} viewFilterId The ID of the view filter to update.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewFilter} [patchedUpdateViewFilter]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilter: (viewFilterId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewFilter_1, ...args_1) => __awaiter(this, [viewFilterId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewFilter_1, ...args_1], void 0, function* (viewFilterId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilter, options = {}) {
            // verify required parameter 'viewFilterId' is not null or undefined
            assertParamExists('updateDatabaseTableViewFilter', 'viewFilterId', viewFilterId);
            const localVarPath = `/database/views/filter/{view_filter_id}/`
                .replace(`{${"view_filter_id"}}`, encodeURIComponent(String(viewFilterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateViewFilter, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId The ID of the view filter group to update.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewFilterGroup} [patchedUpdateViewFilterGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilterGroup: (filterGroupId_1, viewFilterGroupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewFilterGroup_1, ...args_1) => __awaiter(this, [filterGroupId_1, viewFilterGroupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewFilterGroup_1, ...args_1], void 0, function* (filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilterGroup, options = {}) {
            // verify required parameter 'filterGroupId' is not null or undefined
            assertParamExists('updateDatabaseTableViewFilterGroup', 'filterGroupId', filterGroupId);
            // verify required parameter 'viewFilterGroupId' is not null or undefined
            assertParamExists('updateDatabaseTableViewFilterGroup', 'viewFilterGroupId', viewFilterGroupId);
            const localVarPath = `/database/views/filter-group/{filter_group_id}/`
                .replace(`{${"filter_group_id"}}`, encodeURIComponent(String(filterGroupId)))
                .replace(`{${"view_filter_group_id"}}`, encodeURIComponent(String(viewFilterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateViewFilterGroup, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableViewFiltersApi - functional programming interface
 * @export
 */
const DatabaseTableViewFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableViewFiltersApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new filter for the view related to the provided `view_id` parameter. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, then only the rows that apply to all the filters are going to be returned. A filter compares the value of a field to the value of a filter. It depends on the type how values are going to be compared.
         * @param {number} viewId Creates a filter for the view related to the provided value.
         * @param {CreateViewFilter} createViewFilter
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilter(viewId, createViewFilter, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableViewFilter(viewId, createViewFilter, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.createDatabaseTableViewFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new filter group for the view related to the provided `view_id` parameter.
         * @param {number} viewId The ID of the view where create the new filter group.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {CreateViewFilterGroup} [createViewFilterGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilterGroup(viewId, clientSessionId, clientUndoRedoActionGroupId, createViewFilterGroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableViewFilterGroup(viewId, clientSessionId, clientUndoRedoActionGroupId, createViewFilterGroup, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.createDatabaseTableViewFilterGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing filter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewFilterId The ID of the view filter to delete.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilter(viewFilterId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableViewFilter(viewFilterId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.deleteDatabaseTableViewFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId The ID of the view filter group to delete.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.deleteDatabaseTableViewFilterGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view filter.
         * @param {number} viewFilterId The ID of the view filter to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilter(viewFilterId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewFilter(viewFilterId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.getDatabaseTableViewFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId Teh ID of the view filter group to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.getDatabaseTableViewFilterGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all filters of the view related to the provided `view_id`. A view can have multiple filters. When all the rows are requested for the view only those that apply to the filters are returned.
         * @param {number} viewId Returns only filters of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewFilters(viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableViewFilters(viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.listDatabaseTableViewFilters']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing filter.
         * @param {number} viewFilterId The ID of the view filter to update.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewFilter} [patchedUpdateViewFilter]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilter(viewFilterId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewFilter(viewFilterId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilter, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.updateDatabaseTableViewFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing filter group with the given `view_filter_group_id`.
         * @param {string} filterGroupId
         * @param {number} viewFilterGroupId The ID of the view filter group to update.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewFilterGroup} [patchedUpdateViewFilterGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilterGroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewFilterGroup(filterGroupId, viewFilterGroupId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewFilterGroup, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewFiltersApi.updateDatabaseTableViewFilterGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableViewFiltersApi - factory interface
 * @export
 */
const DatabaseTableViewFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableViewFiltersApiFp(configuration);
    return {
        /**
         * Creates a new filter for the view related to the provided `view_id` parameter. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, then only the rows that apply to all the filters are going to be returned. A filter compares the value of a field to the value of a filter. It depends on the type how values are going to be compared.
         * @param {DatabaseTableViewFiltersApiCreateDatabaseTableViewFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilter(requestParameters, options) {
            return localVarFp.createDatabaseTableViewFilter(requestParameters.viewId, requestParameters.createViewFilter, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new filter group for the view related to the provided `view_id` parameter.
         * @param {DatabaseTableViewFiltersApiCreateDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewFilterGroup(requestParameters, options) {
            return localVarFp.createDatabaseTableViewFilterGroup(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.createViewFilterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing filter if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewFiltersApiDeleteDatabaseTableViewFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilter(requestParameters, options) {
            return localVarFp.deleteDatabaseTableViewFilter(requestParameters.viewFilterId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing filter group with the given `view_filter_group_id`.
         * @param {DatabaseTableViewFiltersApiDeleteDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewFilterGroup(requestParameters, options) {
            return localVarFp.deleteDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view filter.
         * @param {DatabaseTableViewFiltersApiGetDatabaseTableViewFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilter(requestParameters, options) {
            return localVarFp.getDatabaseTableViewFilter(requestParameters.viewFilterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view filter group with the given `view_filter_group_id`.
         * @param {DatabaseTableViewFiltersApiGetDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFilterGroup(requestParameters, options) {
            return localVarFp.getDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all filters of the view related to the provided `view_id`. A view can have multiple filters. When all the rows are requested for the view only those that apply to the filters are returned.
         * @param {DatabaseTableViewFiltersApiListDatabaseTableViewFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewFilters(requestParameters, options) {
            return localVarFp.listDatabaseTableViewFilters(requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing filter.
         * @param {DatabaseTableViewFiltersApiUpdateDatabaseTableViewFilterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilter(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewFilter(requestParameters.viewFilterId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing filter group with the given `view_filter_group_id`.
         * @param {DatabaseTableViewFiltersApiUpdateDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFilterGroup(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewFilterGroup, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableViewFiltersApi - object-oriented interface
 * @export
 * @class DatabaseTableViewFiltersApi
 * @extends {BaseAPI}
 */
class DatabaseTableViewFiltersApi extends BaseAPI {
    /**
     * Creates a new filter for the view related to the provided `view_id` parameter. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, then only the rows that apply to all the filters are going to be returned. A filter compares the value of a field to the value of a filter. It depends on the type how values are going to be compared.
     * @param {DatabaseTableViewFiltersApiCreateDatabaseTableViewFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    createDatabaseTableViewFilter(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).createDatabaseTableViewFilter(requestParameters.viewId, requestParameters.createViewFilter, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new filter group for the view related to the provided `view_id` parameter.
     * @param {DatabaseTableViewFiltersApiCreateDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    createDatabaseTableViewFilterGroup(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).createDatabaseTableViewFilterGroup(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.createViewFilterGroup, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing filter if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewFiltersApiDeleteDatabaseTableViewFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    deleteDatabaseTableViewFilter(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).deleteDatabaseTableViewFilter(requestParameters.viewFilterId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing filter group with the given `view_filter_group_id`.
     * @param {DatabaseTableViewFiltersApiDeleteDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    deleteDatabaseTableViewFilterGroup(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).deleteDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view filter.
     * @param {DatabaseTableViewFiltersApiGetDatabaseTableViewFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    getDatabaseTableViewFilter(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).getDatabaseTableViewFilter(requestParameters.viewFilterId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view filter group with the given `view_filter_group_id`.
     * @param {DatabaseTableViewFiltersApiGetDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    getDatabaseTableViewFilterGroup(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).getDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all filters of the view related to the provided `view_id`. A view can have multiple filters. When all the rows are requested for the view only those that apply to the filters are returned.
     * @param {DatabaseTableViewFiltersApiListDatabaseTableViewFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    listDatabaseTableViewFilters(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).listDatabaseTableViewFilters(requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing filter.
     * @param {DatabaseTableViewFiltersApiUpdateDatabaseTableViewFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    updateDatabaseTableViewFilter(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).updateDatabaseTableViewFilter(requestParameters.viewFilterId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewFilter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing filter group with the given `view_filter_group_id`.
     * @param {DatabaseTableViewFiltersApiUpdateDatabaseTableViewFilterGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewFiltersApi
     */
    updateDatabaseTableViewFilterGroup(requestParameters, options) {
        return DatabaseTableViewFiltersApiFp(this.configuration).updateDatabaseTableViewFilterGroup(requestParameters.filterGroupId, requestParameters.viewFilterGroupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewFilterGroup, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableViewGroupingsApi - axios parameter creator
 * @export
 */
const DatabaseTableViewGroupingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new group by for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewId Creates a group by for the view related to the provided value.
         * @param {CreateViewGroupBy} createViewGroupBy
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewGroup: (viewId_1, createViewGroupBy_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, createViewGroupBy_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, createViewGroupBy, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('createDatabaseTableViewGroup', 'viewId', viewId);
            // verify required parameter 'createViewGroupBy' is not null or undefined
            assertParamExists('createDatabaseTableViewGroup', 'createViewGroupBy', createViewGroupBy);
            const localVarPath = `/database/views/{view_id}/group_bys/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createViewGroupBy, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Deletes the group by related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewGroup: (viewGroupById_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewGroupById_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewGroupById, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewGroupById' is not null or undefined
            assertParamExists('deleteDatabaseTableViewGroup', 'viewGroupById', viewGroupById);
            const localVarPath = `/database/views/group_by/{view_group_by_id}/`
                .replace(`{${"view_group_by_id"}}`, encodeURIComponent(String(viewGroupById)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Returns the view group by related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewGroup: (viewGroupById_1, ...args_1) => __awaiter(this, [viewGroupById_1, ...args_1], void 0, function* (viewGroupById, options = {}) {
            // verify required parameter 'viewGroupById' is not null or undefined
            assertParamExists('getDatabaseTableViewGroup', 'viewGroupById', viewGroupById);
            const localVarPath = `/database/views/group_by/{view_group_by_id}/`
                .replace(`{${"view_group_by_id"}}`, encodeURIComponent(String(viewGroupById)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all groupings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple groupings.
         * @param {number} viewId Returns only groupings of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewGroupings: (viewId_1, ...args_1) => __awaiter(this, [viewId_1, ...args_1], void 0, function* (viewId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableViewGroupings', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/group_bys/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Updates the view group by related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewGroupBy} [patchedUpdateViewGroupBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewGroup: (viewGroupById_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewGroupBy_1, ...args_1) => __awaiter(this, [viewGroupById_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewGroupBy_1, ...args_1], void 0, function* (viewGroupById, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewGroupBy, options = {}) {
            // verify required parameter 'viewGroupById' is not null or undefined
            assertParamExists('updateDatabaseTableViewGroup', 'viewGroupById', viewGroupById);
            const localVarPath = `/database/views/group_by/{view_group_by_id}/`
                .replace(`{${"view_group_by_id"}}`, encodeURIComponent(String(viewGroupById)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateViewGroupBy, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableViewGroupingsApi - functional programming interface
 * @export
 */
const DatabaseTableViewGroupingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableViewGroupingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new group by for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {number} viewId Creates a group by for the view related to the provided value.
         * @param {CreateViewGroupBy} createViewGroupBy
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewGroup(viewId, createViewGroupBy, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableViewGroup(viewId, createViewGroupBy, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewGroupingsApi.createDatabaseTableViewGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Deletes the group by related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewGroup(viewGroupById, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableViewGroup(viewGroupById, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewGroupingsApi.deleteDatabaseTableViewGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Returns the view group by related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewGroup(viewGroupById, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewGroup(viewGroupById, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewGroupingsApi.getDatabaseTableViewGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all groupings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple groupings.
         * @param {number} viewId Returns only groupings of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewGroupings(viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableViewGroupings(viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewGroupingsApi.listDatabaseTableViewGroupings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {number} viewGroupById Updates the view group by related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewGroupBy} [patchedUpdateViewGroupBy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewGroup(viewGroupById, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewGroupBy, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewGroup(viewGroupById, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewGroupBy, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewGroupingsApi.updateDatabaseTableViewGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableViewGroupingsApi - factory interface
 * @export
 */
const DatabaseTableViewGroupingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableViewGroupingsApiFp(configuration);
    return {
        /**
         * Creates a new group by for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewGroupingsApiCreateDatabaseTableViewGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewGroup(requestParameters, options) {
            return localVarFp.createDatabaseTableViewGroup(requestParameters.viewId, requestParameters.createViewGroupBy, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewGroupingsApiDeleteDatabaseTableViewGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewGroup(requestParameters, options) {
            return localVarFp.deleteDatabaseTableViewGroup(requestParameters.viewGroupById, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view group by if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewGroupingsApiGetDatabaseTableViewGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewGroup(requestParameters, options) {
            return localVarFp.getDatabaseTableViewGroup(requestParameters.viewGroupById, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all groupings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple groupings.
         * @param {DatabaseTableViewGroupingsApiListDatabaseTableViewGroupingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewGroupings(requestParameters, options) {
            return localVarFp.listDatabaseTableViewGroupings(requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing group by if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewGroupingsApiUpdateDatabaseTableViewGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewGroup(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewGroup(requestParameters.viewGroupById, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewGroupBy, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableViewGroupingsApi - object-oriented interface
 * @export
 * @class DatabaseTableViewGroupingsApi
 * @extends {BaseAPI}
 */
class DatabaseTableViewGroupingsApi extends BaseAPI {
    /**
     * Creates a new group by for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewGroupingsApiCreateDatabaseTableViewGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewGroupingsApi
     */
    createDatabaseTableViewGroup(requestParameters, options) {
        return DatabaseTableViewGroupingsApiFp(this.configuration).createDatabaseTableViewGroup(requestParameters.viewId, requestParameters.createViewGroupBy, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing group by if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewGroupingsApiDeleteDatabaseTableViewGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewGroupingsApi
     */
    deleteDatabaseTableViewGroup(requestParameters, options) {
        return DatabaseTableViewGroupingsApiFp(this.configuration).deleteDatabaseTableViewGroup(requestParameters.viewGroupById, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view group by if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewGroupingsApiGetDatabaseTableViewGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewGroupingsApi
     */
    getDatabaseTableViewGroup(requestParameters, options) {
        return DatabaseTableViewGroupingsApiFp(this.configuration).getDatabaseTableViewGroup(requestParameters.viewGroupById, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all groupings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple groupings.
     * @param {DatabaseTableViewGroupingsApiListDatabaseTableViewGroupingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewGroupingsApi
     */
    listDatabaseTableViewGroupings(requestParameters, options) {
        return DatabaseTableViewGroupingsApiFp(this.configuration).listDatabaseTableViewGroupings(requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing group by if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewGroupingsApiUpdateDatabaseTableViewGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewGroupingsApi
     */
    updateDatabaseTableViewGroup(requestParameters, options) {
        return DatabaseTableViewGroupingsApiFp(this.configuration).updateDatabaseTableViewGroup(requestParameters.viewGroupById, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewGroupBy, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableViewSortingsApi - axios parameter creator
 * @export
 */
const DatabaseTableViewSortingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new sort for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, they will be returned in the respected order defined by all the sortings.
         * @param {number} viewId Creates a sort for the view related to the provided value.
         * @param {CreateViewSort} createViewSort
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewSort: (viewId_1, createViewSort_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, createViewSort_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, createViewSort, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('createDatabaseTableViewSort', 'viewId', viewId);
            // verify required parameter 'createViewSort' is not null or undefined
            assertParamExists('createDatabaseTableViewSort', 'createViewSort', createViewSort);
            const localVarPath = `/database/views/{view_id}/sortings/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createViewSort, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Deletes the sort related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewSort: (viewSortId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewSortId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewSortId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewSortId' is not null or undefined
            assertParamExists('deleteDatabaseTableViewSort', 'viewSortId', viewSortId);
            const localVarPath = `/database/views/sort/{view_sort_id}/`
                .replace(`{${"view_sort_id"}}`, encodeURIComponent(String(viewSortId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Returns the view sort related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewSort: (viewSortId_1, ...args_1) => __awaiter(this, [viewSortId_1, ...args_1], void 0, function* (viewSortId, options = {}) {
            // verify required parameter 'viewSortId' is not null or undefined
            assertParamExists('getDatabaseTableViewSort', 'viewSortId', viewSortId);
            const localVarPath = `/database/views/sort/{view_sort_id}/`
                .replace(`{${"view_sort_id"}}`, encodeURIComponent(String(viewSortId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all sortings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple sortings. When all the rows are requested they will be in the desired order.
         * @param {number} viewId Returns only sortings of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewSortings: (viewId_1, ...args_1) => __awaiter(this, [viewId_1, ...args_1], void 0, function* (viewId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('listDatabaseTableViewSortings', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/sortings/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Updates the view sort related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewSort} [patchedUpdateViewSort]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewSort: (viewSortId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewSort_1, ...args_1) => __awaiter(this, [viewSortId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedUpdateViewSort_1, ...args_1], void 0, function* (viewSortId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewSort, options = {}) {
            // verify required parameter 'viewSortId' is not null or undefined
            assertParamExists('updateDatabaseTableViewSort', 'viewSortId', viewSortId);
            const localVarPath = `/database/views/sort/{view_sort_id}/`
                .replace(`{${"view_sort_id"}}`, encodeURIComponent(String(viewSortId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateViewSort, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableViewSortingsApi - functional programming interface
 * @export
 */
const DatabaseTableViewSortingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableViewSortingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new sort for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, they will be returned in the respected order defined by all the sortings.
         * @param {number} viewId Creates a sort for the view related to the provided value.
         * @param {CreateViewSort} createViewSort
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewSort(viewId, createViewSort, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableViewSort(viewId, createViewSort, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewSortingsApi.createDatabaseTableViewSort']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Deletes the sort related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewSort(viewSortId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableViewSort(viewSortId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewSortingsApi.deleteDatabaseTableViewSort']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Returns the view sort related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewSort(viewSortId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewSort(viewSortId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewSortingsApi.getDatabaseTableViewSort']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all sortings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple sortings. When all the rows are requested they will be in the desired order.
         * @param {number} viewId Returns only sortings of the view related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewSortings(viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableViewSortings(viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewSortingsApi.listDatabaseTableViewSortings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {number} viewSortId Updates the view sort related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedUpdateViewSort} [patchedUpdateViewSort]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewSort(viewSortId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewSort, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewSort(viewSortId, clientSessionId, clientUndoRedoActionGroupId, patchedUpdateViewSort, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewSortingsApi.updateDatabaseTableViewSort']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableViewSortingsApi - factory interface
 * @export
 */
const DatabaseTableViewSortingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableViewSortingsApiFp(configuration);
    return {
        /**
         * Creates a new sort for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, they will be returned in the respected order defined by all the sortings.
         * @param {DatabaseTableViewSortingsApiCreateDatabaseTableViewSortRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableViewSort(requestParameters, options) {
            return localVarFp.createDatabaseTableViewSort(requestParameters.viewId, requestParameters.createViewSort, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewSortingsApiDeleteDatabaseTableViewSortRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableViewSort(requestParameters, options) {
            return localVarFp.deleteDatabaseTableViewSort(requestParameters.viewSortId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view sort if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewSortingsApiGetDatabaseTableViewSortRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewSort(requestParameters, options) {
            return localVarFp.getDatabaseTableViewSort(requestParameters.viewSortId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all sortings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple sortings. When all the rows are requested they will be in the desired order.
         * @param {DatabaseTableViewSortingsApiListDatabaseTableViewSortingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViewSortings(requestParameters, options) {
            return localVarFp.listDatabaseTableViewSortings(requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing sort if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableViewSortingsApiUpdateDatabaseTableViewSortRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewSort(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewSort(requestParameters.viewSortId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewSort, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableViewSortingsApi - object-oriented interface
 * @export
 * @class DatabaseTableViewSortingsApi
 * @extends {BaseAPI}
 */
class DatabaseTableViewSortingsApi extends BaseAPI {
    /**
     * Creates a new sort for the view related to the provided `view_id` parameter if the authorized user has access to the related database\'s workspace. When the rows of a view are requested, for example via the `list_database_table_grid_view_rows` endpoint, they will be returned in the respected order defined by all the sortings.
     * @param {DatabaseTableViewSortingsApiCreateDatabaseTableViewSortRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewSortingsApi
     */
    createDatabaseTableViewSort(requestParameters, options) {
        return DatabaseTableViewSortingsApiFp(this.configuration).createDatabaseTableViewSort(requestParameters.viewId, requestParameters.createViewSort, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing sort if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewSortingsApiDeleteDatabaseTableViewSortRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewSortingsApi
     */
    deleteDatabaseTableViewSort(requestParameters, options) {
        return DatabaseTableViewSortingsApiFp(this.configuration).deleteDatabaseTableViewSort(requestParameters.viewSortId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view sort if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewSortingsApiGetDatabaseTableViewSortRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewSortingsApi
     */
    getDatabaseTableViewSort(requestParameters, options) {
        return DatabaseTableViewSortingsApiFp(this.configuration).getDatabaseTableViewSort(requestParameters.viewSortId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all sortings of the view related to the provided `view_id` if the user has access to the related database\'s workspace. A view can have multiple sortings. When all the rows are requested they will be in the desired order.
     * @param {DatabaseTableViewSortingsApiListDatabaseTableViewSortingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewSortingsApi
     */
    listDatabaseTableViewSortings(requestParameters, options) {
        return DatabaseTableViewSortingsApiFp(this.configuration).listDatabaseTableViewSortings(requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing sort if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableViewSortingsApiUpdateDatabaseTableViewSortRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewSortingsApi
     */
    updateDatabaseTableViewSort(requestParameters, options) {
        return DatabaseTableViewSortingsApiFp(this.configuration).updateDatabaseTableViewSort(requestParameters.viewSortId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedUpdateViewSort, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableViewsApi - axios parameter creator
 * @export
 */
const DatabaseTableViewsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns ICal feed for a specific Calendar view identified by ical_slug value. Calendar View resource contains full url in .ical_feed_url field.
         * @param {string} icalSlug ICal feed unique slug.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalFeed: (icalSlug_1, clientSessionId_1, ...args_1) => __awaiter(this, [icalSlug_1, clientSessionId_1, ...args_1], void 0, function* (icalSlug, clientSessionId, options = {}) {
            // verify required parameter 'icalSlug' is not null or undefined
            assertParamExists('calendarIcalFeed', 'icalSlug', icalSlug);
            const localVarPath = `/database/views/calendar/{ical_slug}.ics`
                .replace(`{${"ical_slug"}}`, encodeURIComponent(String(icalSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new view for the table related to the provided `table_id` parameter. Depending on the type, different properties can optionally be set.
         * @param {number} tableId Creates a view for the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {string} [include] A comma separated list of extra attributes to include on each view in the response. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {ViewCreateView} [viewCreateView]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableView: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, include_1, viewCreateView_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, include_1, viewCreateView_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, include, viewCreateView, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('createDatabaseTableView', 'tableId', tableId);
            const localVarPath = `/database/views/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(viewCreateView, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * If the view is publicly shared or if an authenticated user has access to the related workspace, then this endpoint can be used to do a value lookup of the link row fields that are included in the view. Normally it is not possible for a not authenticated visitor to fetch the rows of a table. This endpoint makes it possible to fetch the id and primary field value of the related table of a link row included in the view.
         * @param {number} fieldId The field id of the link row field.
         * @param {string} slug The slug related to the view.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseTablePublicViewLinkRowFieldLookup: (fieldId_1, slug_1, search_1, searchMode_1, ...args_1) => __awaiter(this, [fieldId_1, slug_1, search_1, searchMode_1, ...args_1], void 0, function* (fieldId, slug, search, searchMode, options = {}) {
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('databaseTablePublicViewLinkRowFieldLookup', 'fieldId', fieldId);
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('databaseTablePublicViewLinkRowFieldLookup', 'slug', slug);
            const localVarPath = `/database/views/{slug}/link-row-field-lookup/{field_id}/`
                .replace(`{${"field_id"}}`, encodeURIComponent(String(fieldId)))
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (searchMode !== undefined) {
                localVarQueryParameter['search_mode'] = searchMode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing view. Note that all the related settings of the view are going to be deleted also. The data stays intact after deleting the view because this is related to the table and not the view.
         * @param {number} viewId Deletes the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableView: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('deleteDatabaseTableView', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates an existing view if the user has access to it. When a view is duplicated everything is copied except: - The name is appended with the copy number. Ex: `ViewName`->`ViewName(2)` and `View(2)`->`View(3)` - If the original view is publicly shared, the new view will not be shared anymore
         * @param {number} viewId Duplicates the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableView: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('duplicateDatabaseTableView', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/duplicate/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing view. Depending on the type different properties could be returned.
         * @param {number} viewId Returns the view related to the provided value.
         * @param {string} [include] A comma separated list of extra attributes to include on the returned view. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableView: (viewId_1, include_1, ...args_1) => __awaiter(this, [viewId_1, include_1, ...args_1], void 0, function* (viewId, include, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('getDatabaseTableView', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with the fields options of the provided view if the authenticated user has access to the related workspace.
         * @param {number} viewId Responds with field options related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFieldOptions: (viewId_1, ...args_1) => __awaiter(this, [viewId_1, ...args_1], void 0, function* (viewId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('getDatabaseTableViewFieldOptions', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/field-options/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the required public information to display a single shared view.
         * @param {string} slug The slug of the view to get public information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicViewInfo: (slug_1, ...args_1) => __awaiter(this, [slug_1, ...args_1], void 0, function* (slug, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getPublicViewInfo', 'slug', slug);
            const localVarPath = `/database/views/{slug}/public/info/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all views of the table related to the provided `table_id`. If the workspace is related to a template, then this endpoint will be publicly accessible. A table can have multiple views. Each view can display the data in a different way. For example the `grid` view shows the in a spreadsheet like way. That type has custom endpoints for data retrieval and manipulation. In the future other views types like a calendar or Kanban are going to be added. Each type can have different properties.
         * @param {number} tableId Returns only views of the table related to the provided value.
         * @param {string} [include] A comma separated list of extra attributes to include on each view in the response. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {number} [limit] The maximum amount of views that must be returned. This endpoint doesn\&#39;t support pagination, but if you for example just need to fetch the first view, you can do that by setting a limit. There isn\&#39;t a limit by default.
         * @param {string} [type] Optionally filter on the view type. If provided, only views of that type will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViews: (tableId_1, include_1, limit_1, type_1, ...args_1) => __awaiter(this, [tableId_1, include_1, limit_1, type_1, ...args_1], void 0, function* (tableId, include, limit, type, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('listDatabaseTableViews', 'tableId', tableId);
            const localVarPath = `/database/views/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes the order of the provided view ids to the matching position that the id has in the list. The order of the not provided views will be set to `0`.
         * @param {number} tableId Updates the order of the views in the table related to the provided value.
         * @param {OrderViews} orderViews
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTableViews: (tableId_1, orderViews_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [tableId_1, orderViews_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (tableId, orderViews, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('orderDatabaseTableViews', 'tableId', tableId);
            // verify required parameter 'orderViews' is not null or undefined
            assertParamExists('orderDatabaseTableViews', 'orderViews', orderViews);
            const localVarPath = `/database/views/table/{table_id}/order/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderViews, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sets view attributes only available for premium users.
         * @param {number} viewId Sets show_logo of this view.
         * @param {PatchedUpdatePremiumViewAttributes} [patchedUpdatePremiumViewAttributes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumViewAttributesUpdate: (viewId_1, patchedUpdatePremiumViewAttributes_1, ...args_1) => __awaiter(this, [viewId_1, patchedUpdatePremiumViewAttributes_1, ...args_1], void 0, function* (viewId, patchedUpdatePremiumViewAttributes, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('premiumViewAttributesUpdate', 'viewId', viewId);
            const localVarPath = `/database/view/{view_id}/premium`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdatePremiumViewAttributes, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a valid never-expiring JWT token for this public shared view if the password provided matches with the one saved by the view\'s owner.
         * @param {string} slug The slug of the grid view to get public information about.
         * @param {PublicViewAuthRequest} publicViewAuthRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicViewTokenAuth: (slug_1, publicViewAuthRequest_1, ...args_1) => __awaiter(this, [slug_1, publicViewAuthRequest_1, ...args_1], void 0, function* (slug, publicViewAuthRequest, options = {}) {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publicViewTokenAuth', 'slug', slug);
            // verify required parameter 'publicViewAuthRequest' is not null or undefined
            assertParamExists('publicViewTokenAuth', 'publicViewAuthRequest', publicViewAuthRequest);
            const localVarPath = `/database/views/{slug}/public/auth/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(publicViewAuthRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Rotates the unique slug of the calendar view\'s ical feed by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the view anymore.
         * @param {number} viewId Rotates the ical feed slug of the calendar view related to the provided id.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateCalendarViewIcalFeedSlug: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('rotateCalendarViewIcalFeedSlug', 'viewId', viewId);
            const localVarPath = `/database/views/calendar/{view_id}/ical_slug_rotate/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Rotates the unique slug of the view by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the viewanymore. Only view types which are sharable can have their slugs rotated.
         * @param {number} viewId Rotates the slug of the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateDatabaseViewSlug: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('rotateDatabaseViewSlug', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/rotate-slug/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing view. The type cannot be changed. It depends on the existing type which properties can be changed.
         * @param {number} viewId Updates the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {string} [include] A comma separated list of extra attributes to include on the returned view. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {PatchedViewUpdateView} [patchedViewUpdateView]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableView: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, include_1, patchedViewUpdateView_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, include_1, patchedViewUpdateView_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, include, patchedViewUpdateView, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('updateDatabaseTableView', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewUpdateView, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the field options of a view. The field options differ per field type  This could for example be used to update the field width of a `grid` view if the user changes it.
         * @param {number} viewId Updates the field options related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedViewFieldOptions} [patchedViewFieldOptions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFieldOptions: (viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedViewFieldOptions_1, ...args_1) => __awaiter(this, [viewId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedViewFieldOptions_1, ...args_1], void 0, function* (viewId, clientSessionId, clientUndoRedoActionGroupId, patchedViewFieldOptions, options = {}) {
            // verify required parameter 'viewId' is not null or undefined
            assertParamExists('updateDatabaseTableViewFieldOptions', 'viewId', viewId);
            const localVarPath = `/database/views/{view_id}/field-options/`
                .replace(`{${"view_id"}}`, encodeURIComponent(String(viewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewFieldOptions, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableViewsApi - functional programming interface
 * @export
 */
const DatabaseTableViewsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableViewsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns ICal feed for a specific Calendar view identified by ical_slug value. Calendar View resource contains full url in .ical_feed_url field.
         * @param {string} icalSlug ICal feed unique slug.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalFeed(icalSlug, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.calendarIcalFeed(icalSlug, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.calendarIcalFeed']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new view for the table related to the provided `table_id` parameter. Depending on the type, different properties can optionally be set.
         * @param {number} tableId Creates a view for the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {string} [include] A comma separated list of extra attributes to include on each view in the response. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {ViewCreateView} [viewCreateView]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableView(tableId, clientSessionId, clientUndoRedoActionGroupId, include, viewCreateView, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableView(tableId, clientSessionId, clientUndoRedoActionGroupId, include, viewCreateView, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.createDatabaseTableView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * If the view is publicly shared or if an authenticated user has access to the related workspace, then this endpoint can be used to do a value lookup of the link row fields that are included in the view. Normally it is not possible for a not authenticated visitor to fetch the rows of a table. This endpoint makes it possible to fetch the id and primary field value of the related table of a link row included in the view.
         * @param {number} fieldId The field id of the link row field.
         * @param {string} slug The slug related to the view.
         * @param {string} [search] If provided only rows with data that matches the search query are going to be returned.
         * @param {string} [searchMode] If provided, allows API consumers to determine what kind of search experience they wish to have. If the default &#x60;SearchModes.MODE_FT_WITH_COUNT&#x60; is used, then Postgres full-text search is used. If &#x60;SearchModes.MODE_COMPAT&#x60; is provided then the search term will be exactly searched for including whitespace on each cell. This is the Baserow legacy search behaviour.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseTablePublicViewLinkRowFieldLookup(fieldId, slug, search, searchMode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.databaseTablePublicViewLinkRowFieldLookup(fieldId, slug, search, searchMode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.databaseTablePublicViewLinkRowFieldLookup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing view. Note that all the related settings of the view are going to be deleted also. The data stays intact after deleting the view because this is related to the table and not the view.
         * @param {number} viewId Deletes the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.deleteDatabaseTableView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Duplicates an existing view if the user has access to it. When a view is duplicated everything is copied except: - The name is appended with the copy number. Ex: `ViewName`->`ViewName(2)` and `View(2)`->`View(3)` - If the original view is publicly shared, the new view will not be shared anymore
         * @param {number} viewId Duplicates the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.duplicateDatabaseTableView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing view. Depending on the type different properties could be returned.
         * @param {number} viewId Returns the view related to the provided value.
         * @param {string} [include] A comma separated list of extra attributes to include on the returned view. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableView(viewId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableView(viewId, include, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.getDatabaseTableView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with the fields options of the provided view if the authenticated user has access to the related workspace.
         * @param {number} viewId Responds with field options related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFieldOptions(viewId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableViewFieldOptions(viewId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.getDatabaseTableViewFieldOptions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the required public information to display a single shared view.
         * @param {string} slug The slug of the view to get public information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicViewInfo(slug, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicViewInfo(slug, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.getPublicViewInfo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all views of the table related to the provided `table_id`. If the workspace is related to a template, then this endpoint will be publicly accessible. A table can have multiple views. Each view can display the data in a different way. For example the `grid` view shows the in a spreadsheet like way. That type has custom endpoints for data retrieval and manipulation. In the future other views types like a calendar or Kanban are going to be added. Each type can have different properties.
         * @param {number} tableId Returns only views of the table related to the provided value.
         * @param {string} [include] A comma separated list of extra attributes to include on each view in the response. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {number} [limit] The maximum amount of views that must be returned. This endpoint doesn\&#39;t support pagination, but if you for example just need to fetch the first view, you can do that by setting a limit. There isn\&#39;t a limit by default.
         * @param {string} [type] Optionally filter on the view type. If provided, only views of that type will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViews(tableId, include, limit, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableViews(tableId, include, limit, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.listDatabaseTableViews']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Changes the order of the provided view ids to the matching position that the id has in the list. The order of the not provided views will be set to `0`.
         * @param {number} tableId Updates the order of the views in the table related to the provided value.
         * @param {OrderViews} orderViews
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTableViews(tableId, orderViews, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderDatabaseTableViews(tableId, orderViews, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.orderDatabaseTableViews']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Sets view attributes only available for premium users.
         * @param {number} viewId Sets show_logo of this view.
         * @param {PatchedUpdatePremiumViewAttributes} [patchedUpdatePremiumViewAttributes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumViewAttributesUpdate(viewId, patchedUpdatePremiumViewAttributes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.premiumViewAttributesUpdate(viewId, patchedUpdatePremiumViewAttributes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.premiumViewAttributesUpdate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a valid never-expiring JWT token for this public shared view if the password provided matches with the one saved by the view\'s owner.
         * @param {string} slug The slug of the grid view to get public information about.
         * @param {PublicViewAuthRequest} publicViewAuthRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicViewTokenAuth(slug, publicViewAuthRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.publicViewTokenAuth(slug, publicViewAuthRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.publicViewTokenAuth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Rotates the unique slug of the calendar view\'s ical feed by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the view anymore.
         * @param {number} viewId Rotates the ical feed slug of the calendar view related to the provided id.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateCalendarViewIcalFeedSlug(viewId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rotateCalendarViewIcalFeedSlug(viewId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.rotateCalendarViewIcalFeedSlug']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Rotates the unique slug of the view by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the viewanymore. Only view types which are sharable can have their slugs rotated.
         * @param {number} viewId Rotates the slug of the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateDatabaseViewSlug(viewId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rotateDatabaseViewSlug(viewId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.rotateDatabaseViewSlug']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing view. The type cannot be changed. It depends on the existing type which properties can be changed.
         * @param {number} viewId Updates the view related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {string} [include] A comma separated list of extra attributes to include on the returned view. The supported attributes are &#x60;filters&#x60;, &#x60;sortings&#x60; and &#x60;decorations&#x60;. For example &#x60;include&#x3D;filters,sortings&#x60; will add the attributes &#x60;filters&#x60; and &#x60;sortings&#x60; to every returned view, containing a list of the views filters and sortings respectively.
         * @param {PatchedViewUpdateView} [patchedViewUpdateView]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, include, patchedViewUpdateView, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableView(viewId, clientSessionId, clientUndoRedoActionGroupId, include, patchedViewUpdateView, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.updateDatabaseTableView']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the field options of a view. The field options differ per field type  This could for example be used to update the field width of a `grid` view if the user changes it.
         * @param {number} viewId Updates the field options related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedViewFieldOptions} [patchedViewFieldOptions]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFieldOptions(viewId, clientSessionId, clientUndoRedoActionGroupId, patchedViewFieldOptions, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableViewFieldOptions(viewId, clientSessionId, clientUndoRedoActionGroupId, patchedViewFieldOptions, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableViewsApi.updateDatabaseTableViewFieldOptions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableViewsApi - factory interface
 * @export
 */
const DatabaseTableViewsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableViewsApiFp(configuration);
    return {
        /**
         * Returns ICal feed for a specific Calendar view identified by ical_slug value. Calendar View resource contains full url in .ical_feed_url field.
         * @param {DatabaseTableViewsApiCalendarIcalFeedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalFeed(requestParameters, options) {
            return localVarFp.calendarIcalFeed(requestParameters.icalSlug, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new view for the table related to the provided `table_id` parameter. Depending on the type, different properties can optionally be set.
         * @param {DatabaseTableViewsApiCreateDatabaseTableViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableView(requestParameters, options) {
            return localVarFp.createDatabaseTableView(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.include, requestParameters.viewCreateView, options).then((request) => request(axios, basePath));
        },
        /**
         * If the view is publicly shared or if an authenticated user has access to the related workspace, then this endpoint can be used to do a value lookup of the link row fields that are included in the view. Normally it is not possible for a not authenticated visitor to fetch the rows of a table. This endpoint makes it possible to fetch the id and primary field value of the related table of a link row included in the view.
         * @param {DatabaseTableViewsApiDatabaseTablePublicViewLinkRowFieldLookupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseTablePublicViewLinkRowFieldLookup(requestParameters, options) {
            return localVarFp.databaseTablePublicViewLinkRowFieldLookup(requestParameters.fieldId, requestParameters.slug, requestParameters.search, requestParameters.searchMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing view. Note that all the related settings of the view are going to be deleted also. The data stays intact after deleting the view because this is related to the table and not the view.
         * @param {DatabaseTableViewsApiDeleteDatabaseTableViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableView(requestParameters, options) {
            return localVarFp.deleteDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates an existing view if the user has access to it. When a view is duplicated everything is copied except: - The name is appended with the copy number. Ex: `ViewName`->`ViewName(2)` and `View(2)`->`View(3)` - If the original view is publicly shared, the new view will not be shared anymore
         * @param {DatabaseTableViewsApiDuplicateDatabaseTableViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableView(requestParameters, options) {
            return localVarFp.duplicateDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing view. Depending on the type different properties could be returned.
         * @param {DatabaseTableViewsApiGetDatabaseTableViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableView(requestParameters, options) {
            return localVarFp.getDatabaseTableView(requestParameters.viewId, requestParameters.include, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with the fields options of the provided view if the authenticated user has access to the related workspace.
         * @param {DatabaseTableViewsApiGetDatabaseTableViewFieldOptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableViewFieldOptions(requestParameters, options) {
            return localVarFp.getDatabaseTableViewFieldOptions(requestParameters.viewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the required public information to display a single shared view.
         * @param {DatabaseTableViewsApiGetPublicViewInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicViewInfo(requestParameters, options) {
            return localVarFp.getPublicViewInfo(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all views of the table related to the provided `table_id`. If the workspace is related to a template, then this endpoint will be publicly accessible. A table can have multiple views. Each view can display the data in a different way. For example the `grid` view shows the in a spreadsheet like way. That type has custom endpoints for data retrieval and manipulation. In the future other views types like a calendar or Kanban are going to be added. Each type can have different properties.
         * @param {DatabaseTableViewsApiListDatabaseTableViewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableViews(requestParameters, options) {
            return localVarFp.listDatabaseTableViews(requestParameters.tableId, requestParameters.include, requestParameters.limit, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the order of the provided view ids to the matching position that the id has in the list. The order of the not provided views will be set to `0`.
         * @param {DatabaseTableViewsApiOrderDatabaseTableViewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTableViews(requestParameters, options) {
            return localVarFp.orderDatabaseTableViews(requestParameters.tableId, requestParameters.orderViews, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets view attributes only available for premium users.
         * @param {DatabaseTableViewsApiPremiumViewAttributesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumViewAttributesUpdate(requestParameters, options) {
            return localVarFp.premiumViewAttributesUpdate(requestParameters.viewId, requestParameters.patchedUpdatePremiumViewAttributes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a valid never-expiring JWT token for this public shared view if the password provided matches with the one saved by the view\'s owner.
         * @param {DatabaseTableViewsApiPublicViewTokenAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicViewTokenAuth(requestParameters, options) {
            return localVarFp.publicViewTokenAuth(requestParameters.slug, requestParameters.publicViewAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotates the unique slug of the calendar view\'s ical feed by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the view anymore.
         * @param {DatabaseTableViewsApiRotateCalendarViewIcalFeedSlugRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateCalendarViewIcalFeedSlug(requestParameters, options) {
            return localVarFp.rotateCalendarViewIcalFeedSlug(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotates the unique slug of the view by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the viewanymore. Only view types which are sharable can have their slugs rotated.
         * @param {DatabaseTableViewsApiRotateDatabaseViewSlugRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateDatabaseViewSlug(requestParameters, options) {
            return localVarFp.rotateDatabaseViewSlug(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing view. The type cannot be changed. It depends on the existing type which properties can be changed.
         * @param {DatabaseTableViewsApiUpdateDatabaseTableViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableView(requestParameters, options) {
            return localVarFp.updateDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.include, requestParameters.patchedViewUpdateView, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the field options of a view. The field options differ per field type  This could for example be used to update the field width of a `grid` view if the user changes it.
         * @param {DatabaseTableViewsApiUpdateDatabaseTableViewFieldOptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableViewFieldOptions(requestParameters, options) {
            return localVarFp.updateDatabaseTableViewFieldOptions(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedViewFieldOptions, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableViewsApi - object-oriented interface
 * @export
 * @class DatabaseTableViewsApi
 * @extends {BaseAPI}
 */
class DatabaseTableViewsApi extends BaseAPI {
    /**
     * Returns ICal feed for a specific Calendar view identified by ical_slug value. Calendar View resource contains full url in .ical_feed_url field.
     * @param {DatabaseTableViewsApiCalendarIcalFeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    calendarIcalFeed(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).calendarIcalFeed(requestParameters.icalSlug, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new view for the table related to the provided `table_id` parameter. Depending on the type, different properties can optionally be set.
     * @param {DatabaseTableViewsApiCreateDatabaseTableViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    createDatabaseTableView(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).createDatabaseTableView(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.include, requestParameters.viewCreateView, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If the view is publicly shared or if an authenticated user has access to the related workspace, then this endpoint can be used to do a value lookup of the link row fields that are included in the view. Normally it is not possible for a not authenticated visitor to fetch the rows of a table. This endpoint makes it possible to fetch the id and primary field value of the related table of a link row included in the view.
     * @param {DatabaseTableViewsApiDatabaseTablePublicViewLinkRowFieldLookupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    databaseTablePublicViewLinkRowFieldLookup(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).databaseTablePublicViewLinkRowFieldLookup(requestParameters.fieldId, requestParameters.slug, requestParameters.search, requestParameters.searchMode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing view. Note that all the related settings of the view are going to be deleted also. The data stays intact after deleting the view because this is related to the table and not the view.
     * @param {DatabaseTableViewsApiDeleteDatabaseTableViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    deleteDatabaseTableView(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).deleteDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates an existing view if the user has access to it. When a view is duplicated everything is copied except: - The name is appended with the copy number. Ex: `ViewName`->`ViewName(2)` and `View(2)`->`View(3)` - If the original view is publicly shared, the new view will not be shared anymore
     * @param {DatabaseTableViewsApiDuplicateDatabaseTableViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    duplicateDatabaseTableView(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).duplicateDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing view. Depending on the type different properties could be returned.
     * @param {DatabaseTableViewsApiGetDatabaseTableViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    getDatabaseTableView(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).getDatabaseTableView(requestParameters.viewId, requestParameters.include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with the fields options of the provided view if the authenticated user has access to the related workspace.
     * @param {DatabaseTableViewsApiGetDatabaseTableViewFieldOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    getDatabaseTableViewFieldOptions(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).getDatabaseTableViewFieldOptions(requestParameters.viewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the required public information to display a single shared view.
     * @param {DatabaseTableViewsApiGetPublicViewInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    getPublicViewInfo(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).getPublicViewInfo(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all views of the table related to the provided `table_id`. If the workspace is related to a template, then this endpoint will be publicly accessible. A table can have multiple views. Each view can display the data in a different way. For example the `grid` view shows the in a spreadsheet like way. That type has custom endpoints for data retrieval and manipulation. In the future other views types like a calendar or Kanban are going to be added. Each type can have different properties.
     * @param {DatabaseTableViewsApiListDatabaseTableViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    listDatabaseTableViews(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).listDatabaseTableViews(requestParameters.tableId, requestParameters.include, requestParameters.limit, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the order of the provided view ids to the matching position that the id has in the list. The order of the not provided views will be set to `0`.
     * @param {DatabaseTableViewsApiOrderDatabaseTableViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    orderDatabaseTableViews(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).orderDatabaseTableViews(requestParameters.tableId, requestParameters.orderViews, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets view attributes only available for premium users.
     * @param {DatabaseTableViewsApiPremiumViewAttributesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    premiumViewAttributesUpdate(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).premiumViewAttributesUpdate(requestParameters.viewId, requestParameters.patchedUpdatePremiumViewAttributes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a valid never-expiring JWT token for this public shared view if the password provided matches with the one saved by the view\'s owner.
     * @param {DatabaseTableViewsApiPublicViewTokenAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    publicViewTokenAuth(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).publicViewTokenAuth(requestParameters.slug, requestParameters.publicViewAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rotates the unique slug of the calendar view\'s ical feed by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the view anymore.
     * @param {DatabaseTableViewsApiRotateCalendarViewIcalFeedSlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    rotateCalendarViewIcalFeedSlug(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).rotateCalendarViewIcalFeedSlug(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rotates the unique slug of the view by replacing it with a new value. This would mean that the publicly shared URL of the view will change. Anyone with the old URL won\'t be able to access the viewanymore. Only view types which are sharable can have their slugs rotated.
     * @param {DatabaseTableViewsApiRotateDatabaseViewSlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    rotateDatabaseViewSlug(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).rotateDatabaseViewSlug(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing view. The type cannot be changed. It depends on the existing type which properties can be changed.
     * @param {DatabaseTableViewsApiUpdateDatabaseTableViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    updateDatabaseTableView(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).updateDatabaseTableView(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.include, requestParameters.patchedViewUpdateView, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the field options of a view. The field options differ per field type  This could for example be used to update the field width of a `grid` view if the user changes it.
     * @param {DatabaseTableViewsApiUpdateDatabaseTableViewFieldOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableViewsApi
     */
    updateDatabaseTableViewFieldOptions(requestParameters, options) {
        return DatabaseTableViewsApiFp(this.configuration).updateDatabaseTableViewFieldOptions(requestParameters.viewId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedViewFieldOptions, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTableWebhooksApi - axios parameter creator
 * @export
 */
const DatabaseTableWebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new webhook for the table related to the provided `table_id` parameter if the authorized user has access to the related database workspace.
         * @param {number} tableId Creates a webhook for the table related to the provided value.
         * @param {TableWebhookCreateRequest} tableWebhookCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableWebhook: (tableId_1, tableWebhookCreateRequest_1, ...args_1) => __awaiter(this, [tableId_1, tableWebhookCreateRequest_1, ...args_1], void 0, function* (tableId, tableWebhookCreateRequest, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('createDatabaseTableWebhook', 'tableId', tableId);
            // verify required parameter 'tableWebhookCreateRequest' is not null or undefined
            assertParamExists('createDatabaseTableWebhook', 'tableWebhookCreateRequest', tableWebhookCreateRequest);
            const localVarPath = `/database/webhooks/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tableWebhookCreateRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing webhook if the authorized user has access to the related database\'s workspace.
         * @param {number} webhookId Deletes the webhook related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableWebhook: (webhookId_1, ...args_1) => __awaiter(this, [webhookId_1, ...args_1], void 0, function* (webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteDatabaseTableWebhook', 'webhookId', webhookId);
            const localVarPath = `/database/webhooks/{webhook_id}/`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the existing webhook if the authorized user has access to the related database workspace.
         * @param {number} webhookId Returns the webhook related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableWebhook: (webhookId_1, ...args_1) => __awaiter(this, [webhookId_1, ...args_1], void 0, function* (webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getDatabaseTableWebhook', 'webhookId', webhookId);
            const localVarPath = `/database/webhooks/{webhook_id}/`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all webhooks of the table related to the provided `table_id` if the user has access to the related database workspace.
         * @param {number} tableId Returns only webhooks of the table related to this value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableWebhooks: (tableId_1, ...args_1) => __awaiter(this, [tableId_1, ...args_1], void 0, function* (tableId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('listDatabaseTableWebhooks', 'tableId', tableId);
            const localVarPath = `/database/webhooks/table/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint triggers a test call based on the provided data if the user has access to the workspace related to the table. The test call will be made immediately and a copy of the request, response and status will be included in the response.
         * @param {number} tableId The id of the table that must be tested.
         * @param {TableWebhookTestCallRequest} tableWebhookTestCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCallDatabaseTableWebhook: (tableId_1, tableWebhookTestCallRequest_1, ...args_1) => __awaiter(this, [tableId_1, tableWebhookTestCallRequest_1, ...args_1], void 0, function* (tableId, tableWebhookTestCallRequest, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('testCallDatabaseTableWebhook', 'tableId', tableId);
            // verify required parameter 'tableWebhookTestCallRequest' is not null or undefined
            assertParamExists('testCallDatabaseTableWebhook', 'tableWebhookTestCallRequest', tableWebhookTestCallRequest);
            const localVarPath = `/database/webhooks/table/{table_id}/test-call/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tableWebhookTestCallRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing view if the authorized user has access to the related database workspace.
         * @param {number} webhookId Updates the webhook related to the provided value.
         * @param {PatchedTableWebhookUpdateRequest} [patchedTableWebhookUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableWebhook: (webhookId_1, patchedTableWebhookUpdateRequest_1, ...args_1) => __awaiter(this, [webhookId_1, patchedTableWebhookUpdateRequest_1, ...args_1], void 0, function* (webhookId, patchedTableWebhookUpdateRequest, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateDatabaseTableWebhook', 'webhookId', webhookId);
            const localVarPath = `/database/webhooks/{webhook_id}/`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTableWebhookUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTableWebhooksApi - functional programming interface
 * @export
 */
const DatabaseTableWebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTableWebhooksApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new webhook for the table related to the provided `table_id` parameter if the authorized user has access to the related database workspace.
         * @param {number} tableId Creates a webhook for the table related to the provided value.
         * @param {TableWebhookCreateRequest} tableWebhookCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableWebhook(tableId, tableWebhookCreateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableWebhook(tableId, tableWebhookCreateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.createDatabaseTableWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing webhook if the authorized user has access to the related database\'s workspace.
         * @param {number} webhookId Deletes the webhook related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableWebhook(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTableWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.deleteDatabaseTableWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the existing webhook if the authorized user has access to the related database workspace.
         * @param {number} webhookId Returns the webhook related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableWebhook(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTableWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.getDatabaseTableWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all webhooks of the table related to the provided `table_id` if the user has access to the related database workspace.
         * @param {number} tableId Returns only webhooks of the table related to this value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableWebhooks(tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTableWebhooks(tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.listDatabaseTableWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint triggers a test call based on the provided data if the user has access to the workspace related to the table. The test call will be made immediately and a copy of the request, response and status will be included in the response.
         * @param {number} tableId The id of the table that must be tested.
         * @param {TableWebhookTestCallRequest} tableWebhookTestCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCallDatabaseTableWebhook(tableId, tableWebhookTestCallRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.testCallDatabaseTableWebhook(tableId, tableWebhookTestCallRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.testCallDatabaseTableWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing view if the authorized user has access to the related database workspace.
         * @param {number} webhookId Updates the webhook related to the provided value.
         * @param {PatchedTableWebhookUpdateRequest} [patchedTableWebhookUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableWebhook(webhookId, patchedTableWebhookUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTableWebhook(webhookId, patchedTableWebhookUpdateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTableWebhooksApi.updateDatabaseTableWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTableWebhooksApi - factory interface
 * @export
 */
const DatabaseTableWebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTableWebhooksApiFp(configuration);
    return {
        /**
         * Creates a new webhook for the table related to the provided `table_id` parameter if the authorized user has access to the related database workspace.
         * @param {DatabaseTableWebhooksApiCreateDatabaseTableWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableWebhook(requestParameters, options) {
            return localVarFp.createDatabaseTableWebhook(requestParameters.tableId, requestParameters.tableWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing webhook if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTableWebhooksApiDeleteDatabaseTableWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTableWebhook(requestParameters, options) {
            return localVarFp.deleteDatabaseTableWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the existing webhook if the authorized user has access to the related database workspace.
         * @param {DatabaseTableWebhooksApiGetDatabaseTableWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTableWebhook(requestParameters, options) {
            return localVarFp.getDatabaseTableWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all webhooks of the table related to the provided `table_id` if the user has access to the related database workspace.
         * @param {DatabaseTableWebhooksApiListDatabaseTableWebhooksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTableWebhooks(requestParameters, options) {
            return localVarFp.listDatabaseTableWebhooks(requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint triggers a test call based on the provided data if the user has access to the workspace related to the table. The test call will be made immediately and a copy of the request, response and status will be included in the response.
         * @param {DatabaseTableWebhooksApiTestCallDatabaseTableWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCallDatabaseTableWebhook(requestParameters, options) {
            return localVarFp.testCallDatabaseTableWebhook(requestParameters.tableId, requestParameters.tableWebhookTestCallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing view if the authorized user has access to the related database workspace.
         * @param {DatabaseTableWebhooksApiUpdateDatabaseTableWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTableWebhook(requestParameters, options) {
            return localVarFp.updateDatabaseTableWebhook(requestParameters.webhookId, requestParameters.patchedTableWebhookUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTableWebhooksApi - object-oriented interface
 * @export
 * @class DatabaseTableWebhooksApi
 * @extends {BaseAPI}
 */
class DatabaseTableWebhooksApi extends BaseAPI {
    /**
     * Creates a new webhook for the table related to the provided `table_id` parameter if the authorized user has access to the related database workspace.
     * @param {DatabaseTableWebhooksApiCreateDatabaseTableWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    createDatabaseTableWebhook(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).createDatabaseTableWebhook(requestParameters.tableId, requestParameters.tableWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing webhook if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTableWebhooksApiDeleteDatabaseTableWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    deleteDatabaseTableWebhook(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).deleteDatabaseTableWebhook(requestParameters.webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the existing webhook if the authorized user has access to the related database workspace.
     * @param {DatabaseTableWebhooksApiGetDatabaseTableWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    getDatabaseTableWebhook(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).getDatabaseTableWebhook(requestParameters.webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all webhooks of the table related to the provided `table_id` if the user has access to the related database workspace.
     * @param {DatabaseTableWebhooksApiListDatabaseTableWebhooksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    listDatabaseTableWebhooks(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).listDatabaseTableWebhooks(requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint triggers a test call based on the provided data if the user has access to the workspace related to the table. The test call will be made immediately and a copy of the request, response and status will be included in the response.
     * @param {DatabaseTableWebhooksApiTestCallDatabaseTableWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    testCallDatabaseTableWebhook(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).testCallDatabaseTableWebhook(requestParameters.tableId, requestParameters.tableWebhookTestCallRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing view if the authorized user has access to the related database workspace.
     * @param {DatabaseTableWebhooksApiUpdateDatabaseTableWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTableWebhooksApi
     */
    updateDatabaseTableWebhook(requestParameters, options) {
        return DatabaseTableWebhooksApiFp(this.configuration).updateDatabaseTableWebhook(requestParameters.webhookId, requestParameters.patchedTableWebhookUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTablesApi - axios parameter creator
 * @export
 */
const DatabaseTablesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates synchronously a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace.  As an alternative you can use the `create_async_database_table` for better performances and importing bigger files.
         * @param {number} databaseId Creates a table for the database related to the provided value.
         * @param {TableCreate} tableCreate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTable: (databaseId_1, tableCreate_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [databaseId_1, tableCreate_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (databaseId, tableCreate, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('createDatabaseTable', 'databaseId', databaseId);
            // verify required parameter 'tableCreate' is not null or undefined
            assertParamExists('createDatabaseTable', 'tableCreate', tableCreate);
            const localVarPath = `/database/tables/database/{database_id}/`
                .replace(`{${"database_id"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tableCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a job that creates a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {number} databaseId Creates a table for the database related to the provided value.
         * @param {TableCreate} tableCreate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableAsync: (databaseId_1, tableCreate_1, clientSessionId_1, ...args_1) => __awaiter(this, [databaseId_1, tableCreate_1, clientSessionId_1, ...args_1], void 0, function* (databaseId, tableCreate, clientSessionId, options = {}) {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('createDatabaseTableAsync', 'databaseId', databaseId);
            // verify required parameter 'tableCreate' is not null or undefined
            assertParamExists('createDatabaseTableAsync', 'tableCreate', tableCreate);
            const localVarPath = `/database/tables/database/{database_id}/async/`
                .replace(`{${"database_id"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tableCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Deletes the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTable: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('deleteDatabaseTable', 'tableId', tableId);
            const localVarPath = `/database/tables/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Start a job to duplicate the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {number} tableId The table to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableAsync: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('duplicateDatabaseTableAsync', 'tableId', tableId);
            const localVarPath = `/database/tables/{table_id}/duplicate/async/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the requested table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Returns the table related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTable: (tableId_1, ...args_1) => __awaiter(this, [tableId_1, ...args_1], void 0, function* (tableId, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('getDatabaseTable', 'tableId', tableId);
            const localVarPath = `/database/tables/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Import data in the specified table if the authorized user has access to the related database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {number} tableId Import data into the table related to the provided value.
         * @param {TableImport} tableImport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDataDatabaseTableAsync: (tableId_1, tableImport_1, ...args_1) => __awaiter(this, [tableId_1, tableImport_1, ...args_1], void 0, function* (tableId, tableImport, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('importDataDatabaseTableAsync', 'tableId', tableId);
            // verify required parameter 'tableImport' is not null or undefined
            assertParamExists('importDataDatabaseTableAsync', 'tableImport', tableImport);
            const localVarPath = `/database/tables/{table_id}/import/async/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tableImport, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the tables that are in the database related to the `database_id` parameter if the user has access to the database\'s workspace. A table is exactly as the name suggests. It can hold multiple fields, each having their own type and multiple rows. They can be added via the **create_database_table_field** and **create_database_table_row** endpoints.
         * @param {number} databaseId Returns only tables that are related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTables: (databaseId_1, ...args_1) => __awaiter(this, [databaseId_1, ...args_1], void 0, function* (databaseId, options = {}) {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseTables', 'databaseId', databaseId);
            const localVarPath = `/database/tables/database/{database_id}/`
                .replace(`{${"database_id"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes the order of the provided table ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} databaseId Updates the order of the tables in the database related to the provided value.
         * @param {OrderTables} orderTables
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTables: (databaseId_1, orderTables_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [databaseId_1, orderTables_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (databaseId, orderTables, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('orderDatabaseTables', 'databaseId', databaseId);
            // verify required parameter 'orderTables' is not null or undefined
            assertParamExists('orderDatabaseTables', 'orderTables', orderTables);
            const localVarPath = `/database/tables/database/{database_id}/order/`
                .replace(`{${"database_id"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderTables, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Updates the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedTableUpdate} [patchedTableUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTable: (tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedTableUpdate_1, ...args_1) => __awaiter(this, [tableId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedTableUpdate_1, ...args_1], void 0, function* (tableId, clientSessionId, clientUndoRedoActionGroupId, patchedTableUpdate, options = {}) {
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('updateDatabaseTable', 'tableId', tableId);
            const localVarPath = `/database/tables/{table_id}/`
                .replace(`{${"table_id"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTableUpdate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTablesApi - functional programming interface
 * @export
 */
const DatabaseTablesApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTablesApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates synchronously a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace.  As an alternative you can use the `create_async_database_table` for better performances and importing bigger files.
         * @param {number} databaseId Creates a table for the database related to the provided value.
         * @param {TableCreate} tableCreate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTable(databaseId, tableCreate, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTable(databaseId, tableCreate, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.createDatabaseTable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a job that creates a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {number} databaseId Creates a table for the database related to the provided value.
         * @param {TableCreate} tableCreate
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableAsync(databaseId, tableCreate, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseTableAsync(databaseId, tableCreate, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.createDatabaseTableAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Deletes the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTable(tableId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseTable(tableId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.deleteDatabaseTable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Start a job to duplicate the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {number} tableId The table to duplicate.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableAsync(tableId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.duplicateDatabaseTableAsync(tableId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.duplicateDatabaseTableAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the requested table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Returns the table related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTable(tableId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseTable(tableId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.getDatabaseTable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Import data in the specified table if the authorized user has access to the related database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {number} tableId Import data into the table related to the provided value.
         * @param {TableImport} tableImport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDataDatabaseTableAsync(tableId, tableImport, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.importDataDatabaseTableAsync(tableId, tableImport, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.importDataDatabaseTableAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the tables that are in the database related to the `database_id` parameter if the user has access to the database\'s workspace. A table is exactly as the name suggests. It can hold multiple fields, each having their own type and multiple rows. They can be added via the **create_database_table_field** and **create_database_table_row** endpoints.
         * @param {number} databaseId Returns only tables that are related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTables(databaseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTables(databaseId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.listDatabaseTables']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Changes the order of the provided table ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {number} databaseId Updates the order of the tables in the database related to the provided value.
         * @param {OrderTables} orderTables
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTables(databaseId, orderTables, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderDatabaseTables(databaseId, orderTables, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.orderDatabaseTables']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing table if the authorized user has access to the related database\'s workspace.
         * @param {number} tableId Updates the table related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedTableUpdate} [patchedTableUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTable(tableId, clientSessionId, clientUndoRedoActionGroupId, patchedTableUpdate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseTable(tableId, clientSessionId, clientUndoRedoActionGroupId, patchedTableUpdate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTablesApi.updateDatabaseTable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTablesApi - factory interface
 * @export
 */
const DatabaseTablesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTablesApiFp(configuration);
    return {
        /**
         * Creates synchronously a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace.  As an alternative you can use the `create_async_database_table` for better performances and importing bigger files.
         * @param {DatabaseTablesApiCreateDatabaseTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTable(requestParameters, options) {
            return localVarFp.createDatabaseTable(requestParameters.databaseId, requestParameters.tableCreate, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a job that creates a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {DatabaseTablesApiCreateDatabaseTableAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseTableAsync(requestParameters, options) {
            return localVarFp.createDatabaseTableAsync(requestParameters.databaseId, requestParameters.tableCreate, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing table if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTablesApiDeleteDatabaseTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseTable(requestParameters, options) {
            return localVarFp.deleteDatabaseTable(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a job to duplicate the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
         * @param {DatabaseTablesApiDuplicateDatabaseTableAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDatabaseTableAsync(requestParameters, options) {
            return localVarFp.duplicateDatabaseTableAsync(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested table if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTablesApiGetDatabaseTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseTable(requestParameters, options) {
            return localVarFp.getDatabaseTable(requestParameters.tableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import data in the specified table if the authorized user has access to the related database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
         * @param {DatabaseTablesApiImportDataDatabaseTableAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDataDatabaseTableAsync(requestParameters, options) {
            return localVarFp.importDataDatabaseTableAsync(requestParameters.tableId, requestParameters.tableImport, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the tables that are in the database related to the `database_id` parameter if the user has access to the database\'s workspace. A table is exactly as the name suggests. It can hold multiple fields, each having their own type and multiple rows. They can be added via the **create_database_table_field** and **create_database_table_row** endpoints.
         * @param {DatabaseTablesApiListDatabaseTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTables(requestParameters, options) {
            return localVarFp.listDatabaseTables(requestParameters.databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the order of the provided table ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
         * @param {DatabaseTablesApiOrderDatabaseTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDatabaseTables(requestParameters, options) {
            return localVarFp.orderDatabaseTables(requestParameters.databaseId, requestParameters.orderTables, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing table if the authorized user has access to the related database\'s workspace.
         * @param {DatabaseTablesApiUpdateDatabaseTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseTable(requestParameters, options) {
            return localVarFp.updateDatabaseTable(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedTableUpdate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTablesApi - object-oriented interface
 * @export
 * @class DatabaseTablesApi
 * @extends {BaseAPI}
 */
class DatabaseTablesApi extends BaseAPI {
    /**
     * Creates synchronously a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace.  As an alternative you can use the `create_async_database_table` for better performances and importing bigger files.
     * @param {DatabaseTablesApiCreateDatabaseTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    createDatabaseTable(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).createDatabaseTable(requestParameters.databaseId, requestParameters.tableCreate, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a job that creates a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
     * @param {DatabaseTablesApiCreateDatabaseTableAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    createDatabaseTableAsync(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).createDatabaseTableAsync(requestParameters.databaseId, requestParameters.tableCreate, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing table if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTablesApiDeleteDatabaseTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    deleteDatabaseTable(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).deleteDatabaseTable(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Start a job to duplicate the table with the provided `table_id` parameter if the authorized user has access to the database\'s workspace.
     * @param {DatabaseTablesApiDuplicateDatabaseTableAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    duplicateDatabaseTableAsync(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).duplicateDatabaseTableAsync(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the requested table if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTablesApiGetDatabaseTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    getDatabaseTable(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).getDatabaseTable(requestParameters.tableId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Import data in the specified table if the authorized user has access to the related database\'s workspace. This endpoint is asynchronous and return the created job to track the progress of the task.
     * @param {DatabaseTablesApiImportDataDatabaseTableAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    importDataDatabaseTableAsync(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).importDataDatabaseTableAsync(requestParameters.tableId, requestParameters.tableImport, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the tables that are in the database related to the `database_id` parameter if the user has access to the database\'s workspace. A table is exactly as the name suggests. It can hold multiple fields, each having their own type and multiple rows. They can be added via the **create_database_table_field** and **create_database_table_row** endpoints.
     * @param {DatabaseTablesApiListDatabaseTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    listDatabaseTables(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).listDatabaseTables(requestParameters.databaseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the order of the provided table ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.
     * @param {DatabaseTablesApiOrderDatabaseTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    orderDatabaseTables(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).orderDatabaseTables(requestParameters.databaseId, requestParameters.orderTables, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing table if the authorized user has access to the related database\'s workspace.
     * @param {DatabaseTablesApiUpdateDatabaseTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTablesApi
     */
    updateDatabaseTable(requestParameters, options) {
        return DatabaseTablesApiFp(this.configuration).updateDatabaseTable(requestParameters.tableId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedTableUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatabaseTokensApi - axios parameter creator
 * @export
 */
const DatabaseTokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint check be used to check if the provided personal API token is valid. If returns a `200` response if so and a `403` is not. This can be used by integrations like Zapier or n8n to test if a token is valid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatabaseToken: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/database/tokens/check/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new database token for a given workspace and for the authorized user.
         * @param {TokenCreate} tokenCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseToken: (tokenCreate_1, ...args_1) => __awaiter(this, [tokenCreate_1, ...args_1], void 0, function* (tokenCreate, options = {}) {
            // verify required parameter 'tokenCreate' is not null or undefined
            assertParamExists('createDatabaseToken', 'tokenCreate', tokenCreate);
            const localVarPath = `/database/tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {number} tokenId Deletes the database token related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseToken: (tokenId_1, ...args_1) => __awaiter(this, [tokenId_1, ...args_1], void 0, function* (tokenId, options = {}) {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteDatabaseToken', 'tokenId', tokenId);
            const localVarPath = `/database/tokens/{token_id}/`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the requested database token if it is owned by the authorized user andif the user has access to the related workspace.
         * @param {number} tokenId Returns the database token related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseToken: (tokenId_1, ...args_1) => __awaiter(this, [tokenId_1, ...args_1], void 0, function* (tokenId, options = {}) {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getDatabaseToken', 'tokenId', tokenId);
            const localVarPath = `/database/tokens/{token_id}/`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the database tokens that belong to the authorized user. A token can be used to create, read, update and delete rows in the tables of the token\'s workspace. It only works on the tables if the token has the correct permissions. The **Database table rows** endpoints can be used for these operations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTokens: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/database/tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {number} tokenId Updates the database token related to the provided value.
         * @param {PatchedTokenUpdate} [patchedTokenUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseToken: (tokenId_1, patchedTokenUpdate_1, ...args_1) => __awaiter(this, [tokenId_1, patchedTokenUpdate_1, ...args_1], void 0, function* (tokenId, patchedTokenUpdate, options = {}) {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('updateDatabaseToken', 'tokenId', tokenId);
            const localVarPath = `/database/tokens/{token_id}/`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTokenUpdate, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DatabaseTokensApi - functional programming interface
 * @export
 */
const DatabaseTokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatabaseTokensApiAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint check be used to check if the provided personal API token is valid. If returns a `200` response if so and a `403` is not. This can be used by integrations like Zapier or n8n to test if a token is valid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatabaseToken(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkDatabaseToken(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.checkDatabaseToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new database token for a given workspace and for the authorized user.
         * @param {TokenCreate} tokenCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseToken(tokenCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createDatabaseToken(tokenCreate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.createDatabaseToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {number} tokenId Deletes the database token related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseToken(tokenId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDatabaseToken(tokenId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.deleteDatabaseToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the requested database token if it is owned by the authorized user andif the user has access to the related workspace.
         * @param {number} tokenId Returns the database token related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseToken(tokenId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDatabaseToken(tokenId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.getDatabaseToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the database tokens that belong to the authorized user. A token can be used to create, read, update and delete rows in the tables of the token\'s workspace. It only works on the tables if the token has the correct permissions. The **Database table rows** endpoints can be used for these operations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTokens(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDatabaseTokens(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.listDatabaseTokens']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {number} tokenId Updates the database token related to the provided value.
         * @param {PatchedTokenUpdate} [patchedTokenUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseToken(tokenId, patchedTokenUpdate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDatabaseToken(tokenId, patchedTokenUpdate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DatabaseTokensApi.updateDatabaseToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DatabaseTokensApi - factory interface
 * @export
 */
const DatabaseTokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatabaseTokensApiFp(configuration);
    return {
        /**
         * This endpoint check be used to check if the provided personal API token is valid. If returns a `200` response if so and a `403` is not. This can be used by integrations like Zapier or n8n to test if a token is valid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatabaseToken(options) {
            return localVarFp.checkDatabaseToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new database token for a given workspace and for the authorized user.
         * @param {DatabaseTokensApiCreateDatabaseTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabaseToken(requestParameters, options) {
            return localVarFp.createDatabaseToken(requestParameters.tokenCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {DatabaseTokensApiDeleteDatabaseTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabaseToken(requestParameters, options) {
            return localVarFp.deleteDatabaseToken(requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested database token if it is owned by the authorized user andif the user has access to the related workspace.
         * @param {DatabaseTokensApiGetDatabaseTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseToken(requestParameters, options) {
            return localVarFp.getDatabaseToken(requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the database tokens that belong to the authorized user. A token can be used to create, read, update and delete rows in the tables of the token\'s workspace. It only works on the tables if the token has the correct permissions. The **Database table rows** endpoints can be used for these operations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseTokens(options) {
            return localVarFp.listDatabaseTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
         * @param {DatabaseTokensApiUpdateDatabaseTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatabaseToken(requestParameters, options) {
            return localVarFp.updateDatabaseToken(requestParameters.tokenId, requestParameters.patchedTokenUpdate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatabaseTokensApi - object-oriented interface
 * @export
 * @class DatabaseTokensApi
 * @extends {BaseAPI}
 */
class DatabaseTokensApi extends BaseAPI {
    /**
     * This endpoint check be used to check if the provided personal API token is valid. If returns a `200` response if so and a `403` is not. This can be used by integrations like Zapier or n8n to test if a token is valid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    checkDatabaseToken(options) {
        return DatabaseTokensApiFp(this.configuration).checkDatabaseToken(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new database token for a given workspace and for the authorized user.
     * @param {DatabaseTokensApiCreateDatabaseTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    createDatabaseToken(requestParameters, options) {
        return DatabaseTokensApiFp(this.configuration).createDatabaseToken(requestParameters.tokenCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
     * @param {DatabaseTokensApiDeleteDatabaseTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    deleteDatabaseToken(requestParameters, options) {
        return DatabaseTokensApiFp(this.configuration).deleteDatabaseToken(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the requested database token if it is owned by the authorized user andif the user has access to the related workspace.
     * @param {DatabaseTokensApiGetDatabaseTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    getDatabaseToken(requestParameters, options) {
        return DatabaseTokensApiFp(this.configuration).getDatabaseToken(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the database tokens that belong to the authorized user. A token can be used to create, read, update and delete rows in the tables of the token\'s workspace. It only works on the tables if the token has the correct permissions. The **Database table rows** endpoints can be used for these operations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    listDatabaseTokens(options) {
        return DatabaseTokensApiFp(this.configuration).listDatabaseTokens(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing database token if it is owned by the authorized user and ifthe user has access to the related workspace.
     * @param {DatabaseTokensApiUpdateDatabaseTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseTokensApi
     */
    updateDatabaseToken(requestParameters, options) {
        return DatabaseTokensApiFp(this.configuration).updateDatabaseToken(requestParameters.tokenId, requestParameters.patchedTokenUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GroupInvitationsApi - axios parameter creator
 * @export
 */
const GroupInvitationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [accept_workspace_invitation](#tag/Workspace-invitations/operation/accept_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Accepts a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} groupInvitationId Accepts the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        acceptGroupInvitation: (groupInvitationId_1, ...args_1) => __awaiter(this, [groupInvitationId_1, ...args_1], void 0, function* (groupInvitationId, options = {}) {
            // verify required parameter 'groupInvitationId' is not null or undefined
            assertParamExists('acceptGroupInvitation', 'groupInvitationId', groupInvitationId);
            const localVarPath = `/groups/invitations/{group_invitation_id}/accept/`
                .replace(`{${"group_invitation_id"}}`, encodeURIComponent(String(groupInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace_invitation](#tag/Workspace-invitations/operation/create_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Creates a new group invitations for an email address if the authorized user has admin rights to the related group. An email containing a sign up link will be send to the user.
         * @param {number} groupId Creates a group invitation to the group related to the provided value.
         * @param {CreateWorkspaceInvitation} createWorkspaceInvitation
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroupInvitation: (groupId_1, createWorkspaceInvitation_1, ...args_1) => __awaiter(this, [groupId_1, createWorkspaceInvitation_1, ...args_1], void 0, function* (groupId, createWorkspaceInvitation, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupInvitation', 'groupId', groupId);
            // verify required parameter 'createWorkspaceInvitation' is not null or undefined
            assertParamExists('createGroupInvitation', 'createWorkspaceInvitation', createWorkspaceInvitation);
            const localVarPath = `/groups/invitations/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceInvitation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_invitation](#tag/Workspace-invitations/operation/delete_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Deletes a group invitation if the authorized user has admin rights to the related group.
         * @param {number} groupInvitationId Deletes the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupInvitation: (groupInvitationId_1, ...args_1) => __awaiter(this, [groupInvitationId_1, ...args_1], void 0, function* (groupInvitationId, options = {}) {
            // verify required parameter 'groupInvitationId' is not null or undefined
            assertParamExists('deleteGroupInvitation', 'groupInvitationId', groupInvitationId);
            const localVarPath = `/groups/invitations/{group_invitation_id}/`
                .replace(`{${"group_invitation_id"}}`, encodeURIComponent(String(groupInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation](#tag/Workspace-invitations/operation/get_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Returns the requested group invitation if the authorized user has admin right to the related group
         * @param {number} groupInvitationId Returns the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitation: (groupInvitationId_1, ...args_1) => __awaiter(this, [groupInvitationId_1, ...args_1], void 0, function* (groupInvitationId, options = {}) {
            // verify required parameter 'groupInvitationId' is not null or undefined
            assertParamExists('getGroupInvitation', 'groupInvitationId', groupInvitationId);
            const localVarPath = `/groups/invitations/{group_invitation_id}/`
                .replace(`{${"group_invitation_id"}}`, encodeURIComponent(String(groupInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation_by_token](#tag/Workspace-invitations/operation/get_workspace_invitation_by_token).**  **Support for this endpoint will end in 2024.**   Responds with the serialized group invitation if an invitation with the provided token is found.
         * @param {string} token Returns the group invitation related to the provided token.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitationByToken: (token_1, ...args_1) => __awaiter(this, [token_1, ...args_1], void 0, function* (token, options = {}) {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getGroupInvitationByToken', 'token', token);
            const localVarPath = `/groups/invitations/token/{token}/`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_invitations](#tag/Workspace-invitations/operation/list_workspace_invitations).**  **Support for this endpoint will end in 2024.**   Lists all the group invitations of the group related to the provided `group_id` parameter if the authorized user has admin rights to that group.
         * @param {number} groupId Returns only invitations that are in the group related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupInvitations: (groupId_1, ...args_1) => __awaiter(this, [groupId_1, ...args_1], void 0, function* (groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listGroupInvitations', 'groupId', groupId);
            const localVarPath = `/groups/invitations/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [reject_workspace_invitation](#tag/Workspace-invitations/operation/reject_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Rejects a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} groupInvitationId Rejects the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rejectGroupInvitation: (groupInvitationId_1, ...args_1) => __awaiter(this, [groupInvitationId_1, ...args_1], void 0, function* (groupInvitationId, options = {}) {
            // verify required parameter 'groupInvitationId' is not null or undefined
            assertParamExists('rejectGroupInvitation', 'groupInvitationId', groupInvitationId);
            const localVarPath = `/groups/invitations/{group_invitation_id}/reject/`
                .replace(`{${"group_invitation_id"}}`, encodeURIComponent(String(groupInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_invitation](#tag/Workspace-invitations/operation/update_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Updates the existing group invitation related to the provided `group_invitation_id` param if the authorized user has admin rights to the related group.
         * @param {number} groupInvitationId Updates the group invitation related to the provided value.
         * @param {PatchedUpdateWorkspaceInvitation} [patchedUpdateWorkspaceInvitation]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupInvitation: (groupInvitationId_1, patchedUpdateWorkspaceInvitation_1, ...args_1) => __awaiter(this, [groupInvitationId_1, patchedUpdateWorkspaceInvitation_1, ...args_1], void 0, function* (groupInvitationId, patchedUpdateWorkspaceInvitation, options = {}) {
            // verify required parameter 'groupInvitationId' is not null or undefined
            assertParamExists('updateGroupInvitation', 'groupInvitationId', groupInvitationId);
            const localVarPath = `/groups/invitations/{group_invitation_id}/`
                .replace(`{${"group_invitation_id"}}`, encodeURIComponent(String(groupInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateWorkspaceInvitation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * GroupInvitationsApi - functional programming interface
 * @export
 */
const GroupInvitationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = GroupInvitationsApiAxiosParamCreator(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [accept_workspace_invitation](#tag/Workspace-invitations/operation/accept_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Accepts a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} groupInvitationId Accepts the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        acceptGroupInvitation(groupInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptGroupInvitation(groupInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.acceptGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace_invitation](#tag/Workspace-invitations/operation/create_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Creates a new group invitations for an email address if the authorized user has admin rights to the related group. An email containing a sign up link will be send to the user.
         * @param {number} groupId Creates a group invitation to the group related to the provided value.
         * @param {CreateWorkspaceInvitation} createWorkspaceInvitation
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroupInvitation(groupId, createWorkspaceInvitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGroupInvitation(groupId, createWorkspaceInvitation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.createGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_invitation](#tag/Workspace-invitations/operation/delete_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Deletes a group invitation if the authorized user has admin rights to the related group.
         * @param {number} groupInvitationId Deletes the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupInvitation(groupInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGroupInvitation(groupInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.deleteGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation](#tag/Workspace-invitations/operation/get_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Returns the requested group invitation if the authorized user has admin right to the related group
         * @param {number} groupInvitationId Returns the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitation(groupInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupInvitation(groupInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.getGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation_by_token](#tag/Workspace-invitations/operation/get_workspace_invitation_by_token).**  **Support for this endpoint will end in 2024.**   Responds with the serialized group invitation if an invitation with the provided token is found.
         * @param {string} token Returns the group invitation related to the provided token.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitationByToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupInvitationByToken(token, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.getGroupInvitationByToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_invitations](#tag/Workspace-invitations/operation/list_workspace_invitations).**  **Support for this endpoint will end in 2024.**   Lists all the group invitations of the group related to the provided `group_id` parameter if the authorized user has admin rights to that group.
         * @param {number} groupId Returns only invitations that are in the group related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupInvitations(groupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGroupInvitations(groupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.listGroupInvitations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [reject_workspace_invitation](#tag/Workspace-invitations/operation/reject_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Rejects a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} groupInvitationId Rejects the group invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rejectGroupInvitation(groupInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rejectGroupInvitation(groupInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.rejectGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_invitation](#tag/Workspace-invitations/operation/update_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Updates the existing group invitation related to the provided `group_invitation_id` param if the authorized user has admin rights to the related group.
         * @param {number} groupInvitationId Updates the group invitation related to the provided value.
         * @param {PatchedUpdateWorkspaceInvitation} [patchedUpdateWorkspaceInvitation]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupInvitation(groupInvitationId, patchedUpdateWorkspaceInvitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroupInvitation(groupInvitationId, patchedUpdateWorkspaceInvitation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupInvitationsApi.updateGroupInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * GroupInvitationsApi - factory interface
 * @export
 */
const GroupInvitationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GroupInvitationsApiFp(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [accept_workspace_invitation](#tag/Workspace-invitations/operation/accept_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Accepts a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {GroupInvitationsApiAcceptGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        acceptGroupInvitation(requestParameters, options) {
            return localVarFp.acceptGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace_invitation](#tag/Workspace-invitations/operation/create_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Creates a new group invitations for an email address if the authorized user has admin rights to the related group. An email containing a sign up link will be send to the user.
         * @param {GroupInvitationsApiCreateGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroupInvitation(requestParameters, options) {
            return localVarFp.createGroupInvitation(requestParameters.groupId, requestParameters.createWorkspaceInvitation, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_invitation](#tag/Workspace-invitations/operation/delete_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Deletes a group invitation if the authorized user has admin rights to the related group.
         * @param {GroupInvitationsApiDeleteGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupInvitation(requestParameters, options) {
            return localVarFp.deleteGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation](#tag/Workspace-invitations/operation/get_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Returns the requested group invitation if the authorized user has admin right to the related group
         * @param {GroupInvitationsApiGetGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitation(requestParameters, options) {
            return localVarFp.getGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation_by_token](#tag/Workspace-invitations/operation/get_workspace_invitation_by_token).**  **Support for this endpoint will end in 2024.**   Responds with the serialized group invitation if an invitation with the provided token is found.
         * @param {GroupInvitationsApiGetGroupInvitationByTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGroupInvitationByToken(requestParameters, options) {
            return localVarFp.getGroupInvitationByToken(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_invitations](#tag/Workspace-invitations/operation/list_workspace_invitations).**  **Support for this endpoint will end in 2024.**   Lists all the group invitations of the group related to the provided `group_id` parameter if the authorized user has admin rights to that group.
         * @param {GroupInvitationsApiListGroupInvitationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupInvitations(requestParameters, options) {
            return localVarFp.listGroupInvitations(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [reject_workspace_invitation](#tag/Workspace-invitations/operation/reject_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Rejects a group invitation with the given id if the email address of the user matches that of the invitation.
         * @param {GroupInvitationsApiRejectGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rejectGroupInvitation(requestParameters, options) {
            return localVarFp.rejectGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_invitation](#tag/Workspace-invitations/operation/update_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Updates the existing group invitation related to the provided `group_invitation_id` param if the authorized user has admin rights to the related group.
         * @param {GroupInvitationsApiUpdateGroupInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupInvitation(requestParameters, options) {
            return localVarFp.updateGroupInvitation(requestParameters.groupInvitationId, requestParameters.patchedUpdateWorkspaceInvitation, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GroupInvitationsApi - object-oriented interface
 * @export
 * @class GroupInvitationsApi
 * @extends {BaseAPI}
 */
class GroupInvitationsApi extends BaseAPI {
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [accept_workspace_invitation](#tag/Workspace-invitations/operation/accept_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Accepts a group invitation with the given id if the email address of the user matches that of the invitation.
     * @param {GroupInvitationsApiAcceptGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    acceptGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).acceptGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace_invitation](#tag/Workspace-invitations/operation/create_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Creates a new group invitations for an email address if the authorized user has admin rights to the related group. An email containing a sign up link will be send to the user.
     * @param {GroupInvitationsApiCreateGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    createGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).createGroupInvitation(requestParameters.groupId, requestParameters.createWorkspaceInvitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_invitation](#tag/Workspace-invitations/operation/delete_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Deletes a group invitation if the authorized user has admin rights to the related group.
     * @param {GroupInvitationsApiDeleteGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    deleteGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).deleteGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation](#tag/Workspace-invitations/operation/get_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Returns the requested group invitation if the authorized user has admin right to the related group
     * @param {GroupInvitationsApiGetGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    getGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).getGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [get_workspace_invitation_by_token](#tag/Workspace-invitations/operation/get_workspace_invitation_by_token).**  **Support for this endpoint will end in 2024.**   Responds with the serialized group invitation if an invitation with the provided token is found.
     * @param {GroupInvitationsApiGetGroupInvitationByTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    getGroupInvitationByToken(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).getGroupInvitationByToken(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_invitations](#tag/Workspace-invitations/operation/list_workspace_invitations).**  **Support for this endpoint will end in 2024.**   Lists all the group invitations of the group related to the provided `group_id` parameter if the authorized user has admin rights to that group.
     * @param {GroupInvitationsApiListGroupInvitationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    listGroupInvitations(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).listGroupInvitations(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [reject_workspace_invitation](#tag/Workspace-invitations/operation/reject_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Rejects a group invitation with the given id if the email address of the user matches that of the invitation.
     * @param {GroupInvitationsApiRejectGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    rejectGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).rejectGroupInvitation(requestParameters.groupInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_invitation](#tag/Workspace-invitations/operation/update_workspace_invitation).**  **Support for this endpoint will end in 2024.**   Updates the existing group invitation related to the provided `group_invitation_id` param if the authorized user has admin rights to the related group.
     * @param {GroupInvitationsApiUpdateGroupInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupInvitationsApi
     */
    updateGroupInvitation(requestParameters, options) {
        return GroupInvitationsApiFp(this.configuration).updateGroupInvitation(requestParameters.groupInvitationId, requestParameters.patchedUpdateWorkspaceInvitation, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
const GroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace](#tag/Workspaces/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new group where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {Workspace} workspace
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroup: (workspace_1, clientSessionId_1, ...args_1) => __awaiter(this, [workspace_1, clientSessionId_1, ...args_1], void 0, function* (workspace, clientSessionId, options = {}) {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createGroup', 'workspace', workspace);
            const localVarPath = `/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace](#tag/Workspaces/operation/delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes an existing group if the authorized user belongs to the group. All the applications, databases, tables etc that were in the group are going to be deleted also.
         * @param {number} groupId Deletes the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroup: (groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (groupId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId);
            const localVarPath = `/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_user](#tag/Workspaces/operation/delete_workspace_user).**   Deletes a group user if the authorized user has admin rights to the related group.
         * @param {number} groupUserId Deletes the group user related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupUser: (groupUserId_1, ...args_1) => __awaiter(this, [groupUserId_1, ...args_1], void 0, function* (groupUserId, options = {}) {
            // verify required parameter 'groupUserId' is not null or undefined
            assertParamExists('deleteGroupUser', 'groupUserId', groupUserId);
            const localVarPath = `/groups/users/{group_user_id}/`
                .replace(`{${"group_user_id"}}`, encodeURIComponent(String(groupUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_permissions](#tag/Workspaces/operation/workspace_permissions).**  **Support for this endpoint will end in 2024.**   Returns a the permission data necessary to determine the permissions of a specific user over a specific group.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {number} groupId The group id we want the permission object for.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupPermissions: (groupId_1, ...args_1) => __awaiter(this, [groupId_1, ...args_1], void 0, function* (groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupPermissions', 'groupId', groupId);
            const localVarPath = `/groups/{group_id}/permissions/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [leave_workspace](#tag/Workspaces/operation/leave_workspace).**  **Support for this endpoint will end in 2024.**   Makes the authenticated user leave the group related to the provided `group_id` if the user is in that group. If the user is the last admin in the group, they will not be able to leave it. There must always be one admin in the group, otherwise it will be left without control. If that is the case, they must either delete the group or give another member admin permissions first.
         * @param {number} groupId Leaves the group related to the value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        leaveGroup: (groupId_1, ...args_1) => __awaiter(this, [groupId_1, ...args_1], void 0, function* (groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('leaveGroup', 'groupId', groupId);
            const localVarPath = `/groups/{group_id}/leave/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_users](#tag/Workspaces/operation/list_workspace_users).**   Lists all the users that are in a group if the authorized user has admin permissions to the related group. To add a user to a group an invitation must be sent first.
         * @param {number} groupId Lists group users related to the provided group value.
         * @param {string} [search] Search for group users by username, or email.
         * @param {string} [sorts] Sort group users by name, email or role.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupUsers: (groupId_1, search_1, sorts_1, ...args_1) => __awaiter(this, [groupId_1, search_1, sorts_1, ...args_1], void 0, function* (groupId, search, sorts, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listGroupUsers', 'groupId', groupId);
            const localVarPath = `/groups/users/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspaces](#tag/Workspaces/operation/list_workspaces).**  **Support for this endpoint will end in 2024.**   Lists all the groups of the authorized user. A group can contain multiple applications like a database. Multiple users can have access to a group. For example each company could have their own group containing databases related to that company. The order of the groups are custom for each user. The order is configurable via the **order_groups** endpoint.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroups: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [order_workspaces](#tag/Workspaces/operation/order_workspaces).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided group ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order will be custom for each user.
         * @param {OrderWorkspaces} orderWorkspaces
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        orderGroups: (orderWorkspaces_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [orderWorkspaces_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'orderWorkspaces' is not null or undefined
            assertParamExists('orderGroups', 'orderWorkspaces', orderWorkspaces);
            const localVarPath = `/groups/order/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderWorkspaces, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace](#tag/Workspaces/operation/update_workspace).**  **Support for this endpoint will end in 2024.**   Updates the existing group related to the provided `group_id` parameter if the authorized user belongs to the group. It is not yet possible to add additional users to a group.
         * @param {number} groupId Updates the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedWorkspace} [patchedWorkspace]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroup: (groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedWorkspace_1, ...args_1) => __awaiter(this, [groupId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedWorkspace_1, ...args_1], void 0, function* (groupId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroup', 'groupId', groupId);
            const localVarPath = `/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorkspace, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_user](#tag/Workspaces/operation/update_workspace_user).**   Updates the existing group user related to the provided `group_user_id` param if the authorized user has admin rights to the related group.
         * @param {number} groupUserId Updates the group user related to the provided value.
         * @param {PatchedUpdateWorkspaceUser} [patchedUpdateWorkspaceUser]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupUser: (groupUserId_1, patchedUpdateWorkspaceUser_1, ...args_1) => __awaiter(this, [groupUserId_1, patchedUpdateWorkspaceUser_1, ...args_1], void 0, function* (groupUserId, patchedUpdateWorkspaceUser, options = {}) {
            // verify required parameter 'groupUserId' is not null or undefined
            assertParamExists('updateGroupUser', 'groupUserId', groupUserId);
            const localVarPath = `/groups/users/{group_user_id}/`
                .replace(`{${"group_user_id"}}`, encodeURIComponent(String(groupUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateWorkspaceUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
const GroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace](#tag/Workspaces/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new group where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {Workspace} workspace
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroup(workspace, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGroup(workspace, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.createGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace](#tag/Workspaces/operation/delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes an existing group if the authorized user belongs to the group. All the applications, databases, tables etc that were in the group are going to be deleted also.
         * @param {number} groupId Deletes the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroup(groupId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGroup(groupId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.deleteGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_user](#tag/Workspaces/operation/delete_workspace_user).**   Deletes a group user if the authorized user has admin rights to the related group.
         * @param {number} groupUserId Deletes the group user related to the provided value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupUser(groupUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGroupUser(groupUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.deleteGroupUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_permissions](#tag/Workspaces/operation/workspace_permissions).**  **Support for this endpoint will end in 2024.**   Returns a the permission data necessary to determine the permissions of a specific user over a specific group.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {number} groupId The group id we want the permission object for.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupPermissions(groupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupPermissions(groupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.groupPermissions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [leave_workspace](#tag/Workspaces/operation/leave_workspace).**  **Support for this endpoint will end in 2024.**   Makes the authenticated user leave the group related to the provided `group_id` if the user is in that group. If the user is the last admin in the group, they will not be able to leave it. There must always be one admin in the group, otherwise it will be left without control. If that is the case, they must either delete the group or give another member admin permissions first.
         * @param {number} groupId Leaves the group related to the value.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        leaveGroup(groupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.leaveGroup(groupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.leaveGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_users](#tag/Workspaces/operation/list_workspace_users).**   Lists all the users that are in a group if the authorized user has admin permissions to the related group. To add a user to a group an invitation must be sent first.
         * @param {number} groupId Lists group users related to the provided group value.
         * @param {string} [search] Search for group users by username, or email.
         * @param {string} [sorts] Sort group users by name, email or role.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupUsers(groupId, search, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGroupUsers(groupId, search, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.listGroupUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspaces](#tag/Workspaces/operation/list_workspaces).**  **Support for this endpoint will end in 2024.**   Lists all the groups of the authorized user. A group can contain multiple applications like a database. Multiple users can have access to a group. For example each company could have their own group containing databases related to that company. The order of the groups are custom for each user. The order is configurable via the **order_groups** endpoint.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroups(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGroups(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.listGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [order_workspaces](#tag/Workspaces/operation/order_workspaces).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided group ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order will be custom for each user.
         * @param {OrderWorkspaces} orderWorkspaces
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        orderGroups(orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderGroups(orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.orderGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace](#tag/Workspaces/operation/update_workspace).**  **Support for this endpoint will end in 2024.**   Updates the existing group related to the provided `group_id` parameter if the authorized user belongs to the group. It is not yet possible to add additional users to a group.
         * @param {number} groupId Updates the group related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedWorkspace} [patchedWorkspace]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroup(groupId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroup(groupId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.updateGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_user](#tag/Workspaces/operation/update_workspace_user).**   Updates the existing group user related to the provided `group_user_id` param if the authorized user has admin rights to the related group.
         * @param {number} groupUserId Updates the group user related to the provided value.
         * @param {PatchedUpdateWorkspaceUser} [patchedUpdateWorkspaceUser]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupUser(groupUserId, patchedUpdateWorkspaceUser, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroupUser(groupUserId, patchedUpdateWorkspaceUser, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['GroupsApi.updateGroupUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * GroupsApi - factory interface
 * @export
 */
const GroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GroupsApiFp(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace](#tag/Workspaces/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new group where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {GroupsApiCreateGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGroup(requestParameters, options) {
            return localVarFp.createGroup(requestParameters.workspace, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace](#tag/Workspaces/operation/delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes an existing group if the authorized user belongs to the group. All the applications, databases, tables etc that were in the group are going to be deleted also.
         * @param {GroupsApiDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroup(requestParameters, options) {
            return localVarFp.deleteGroup(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_user](#tag/Workspaces/operation/delete_workspace_user).**   Deletes a group user if the authorized user has admin rights to the related group.
         * @param {GroupsApiDeleteGroupUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteGroupUser(requestParameters, options) {
            return localVarFp.deleteGroupUser(requestParameters.groupUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_permissions](#tag/Workspaces/operation/workspace_permissions).**  **Support for this endpoint will end in 2024.**   Returns a the permission data necessary to determine the permissions of a specific user over a specific group.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {GroupsApiGroupPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupPermissions(requestParameters, options) {
            return localVarFp.groupPermissions(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [leave_workspace](#tag/Workspaces/operation/leave_workspace).**  **Support for this endpoint will end in 2024.**   Makes the authenticated user leave the group related to the provided `group_id` if the user is in that group. If the user is the last admin in the group, they will not be able to leave it. There must always be one admin in the group, otherwise it will be left without control. If that is the case, they must either delete the group or give another member admin permissions first.
         * @param {GroupsApiLeaveGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        leaveGroup(requestParameters, options) {
            return localVarFp.leaveGroup(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_users](#tag/Workspaces/operation/list_workspace_users).**   Lists all the users that are in a group if the authorized user has admin permissions to the related group. To add a user to a group an invitation must be sent first.
         * @param {GroupsApiListGroupUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroupUsers(requestParameters, options) {
            return localVarFp.listGroupUsers(requestParameters.groupId, requestParameters.search, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspaces](#tag/Workspaces/operation/list_workspaces).**  **Support for this endpoint will end in 2024.**   Lists all the groups of the authorized user. A group can contain multiple applications like a database. Multiple users can have access to a group. For example each company could have their own group containing databases related to that company. The order of the groups are custom for each user. The order is configurable via the **order_groups** endpoint.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listGroups(options) {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [order_workspaces](#tag/Workspaces/operation/order_workspaces).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided group ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order will be custom for each user.
         * @param {GroupsApiOrderGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        orderGroups(requestParameters, options) {
            return localVarFp.orderGroups(requestParameters.orderWorkspaces, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace](#tag/Workspaces/operation/update_workspace).**  **Support for this endpoint will end in 2024.**   Updates the existing group related to the provided `group_id` parameter if the authorized user belongs to the group. It is not yet possible to add additional users to a group.
         * @param {GroupsApiUpdateGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroup(requestParameters, options) {
            return localVarFp.updateGroup(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedWorkspace, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_user](#tag/Workspaces/operation/update_workspace_user).**   Updates the existing group user related to the provided `group_user_id` param if the authorized user has admin rights to the related group.
         * @param {GroupsApiUpdateGroupUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGroupUser(requestParameters, options) {
            return localVarFp.updateGroupUser(requestParameters.groupUserId, requestParameters.patchedUpdateWorkspaceUser, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
class GroupsApi extends BaseAPI {
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [create_workspace](#tag/Workspaces/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new group where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
     * @param {GroupsApiCreateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(requestParameters, options) {
        return GroupsApiFp(this.configuration).createGroup(requestParameters.workspace, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace](#tag/Workspaces/operation/delete_workspace).**  **Support for this endpoint will end in 2024.**   Deletes an existing group if the authorized user belongs to the group. All the applications, databases, tables etc that were in the group are going to be deleted also.
     * @param {GroupsApiDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup(requestParameters, options) {
        return GroupsApiFp(this.configuration).deleteGroup(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [delete_workspace_user](#tag/Workspaces/operation/delete_workspace_user).**   Deletes a group user if the authorized user has admin rights to the related group.
     * @param {GroupsApiDeleteGroupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupUser(requestParameters, options) {
        return GroupsApiFp(this.configuration).deleteGroupUser(requestParameters.groupUserId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_permissions](#tag/Workspaces/operation/workspace_permissions).**  **Support for this endpoint will end in 2024.**   Returns a the permission data necessary to determine the permissions of a specific user over a specific group.  See `core.handler.CoreHandler.get_permissions()` for more details.
     * @param {GroupsApiGroupPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupPermissions(requestParameters, options) {
        return GroupsApiFp(this.configuration).groupPermissions(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [leave_workspace](#tag/Workspaces/operation/leave_workspace).**  **Support for this endpoint will end in 2024.**   Makes the authenticated user leave the group related to the provided `group_id` if the user is in that group. If the user is the last admin in the group, they will not be able to leave it. There must always be one admin in the group, otherwise it will be left without control. If that is the case, they must either delete the group or give another member admin permissions first.
     * @param {GroupsApiLeaveGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    leaveGroup(requestParameters, options) {
        return GroupsApiFp(this.configuration).leaveGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspace_users](#tag/Workspaces/operation/list_workspace_users).**   Lists all the users that are in a group if the authorized user has admin permissions to the related group. To add a user to a group an invitation must be sent first.
     * @param {GroupsApiListGroupUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listGroupUsers(requestParameters, options) {
        return GroupsApiFp(this.configuration).listGroupUsers(requestParameters.groupId, requestParameters.search, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [list_workspaces](#tag/Workspaces/operation/list_workspaces).**  **Support for this endpoint will end in 2024.**   Lists all the groups of the authorized user. A group can contain multiple applications like a database. Multiple users can have access to a group. For example each company could have their own group containing databases related to that company. The order of the groups are custom for each user. The order is configurable via the **order_groups** endpoint.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listGroups(options) {
        return GroupsApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [order_workspaces](#tag/Workspaces/operation/order_workspaces).**  **Support for this endpoint will end in 2024.**   Changes the order of the provided group ids to the matching position that the id has in the list. If the authorized user does not belong to the group it will be ignored. The order will be custom for each user.
     * @param {GroupsApiOrderGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    orderGroups(requestParameters, options) {
        return GroupsApiFp(this.configuration).orderGroups(requestParameters.orderWorkspaces, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace](#tag/Workspaces/operation/update_workspace).**  **Support for this endpoint will end in 2024.**   Updates the existing group related to the provided `group_id` parameter if the authorized user belongs to the group. It is not yet possible to add additional users to a group.
     * @param {GroupsApiUpdateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroup(requestParameters, options) {
        return GroupsApiFp(this.configuration).updateGroup(requestParameters.groupId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedWorkspace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [update_workspace_user](#tag/Workspaces/operation/update_workspace_user).**   Updates the existing group user related to the provided `group_user_id` param if the authorized user has admin rights to the related group.
     * @param {GroupsApiUpdateGroupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupUser(requestParameters, options) {
        return GroupsApiFp(this.configuration).updateGroupUser(requestParameters.groupUserId, requestParameters.patchedUpdateWorkspaceUser, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * HealthApi - axios parameter creator
 * @export
 */
const HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sends a test email to the provided email address. Useful for testing Baserow\'s email configuration as errors are clearly returned.
         * @param {EmailTesterRequest} emailTesterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailTester: (emailTesterRequest_1, ...args_1) => __awaiter(this, [emailTesterRequest_1, ...args_1], void 0, function* (emailTesterRequest, options = {}) {
            // verify required parameter 'emailTesterRequest' is not null or undefined
            assertParamExists('emailTester', 'emailTesterRequest', emailTesterRequest);
            const localVarPath = `/_health/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(emailTesterRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Runs a full health check testing as many services and systems as possible. These health checks can be expensive operations such as writing files to storage etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fullHealthCheck: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/_health/full/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
const HealthApiFp = function (configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
    return {
        /**
         * Sends a test email to the provided email address. Useful for testing Baserow\'s email configuration as errors are clearly returned.
         * @param {EmailTesterRequest} emailTesterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailTester(emailTesterRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.emailTester(emailTesterRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['HealthApi.emailTester']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Runs a full health check testing as many services and systems as possible. These health checks can be expensive operations such as writing files to storage etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fullHealthCheck(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fullHealthCheck(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['HealthApi.fullHealthCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * HealthApi - factory interface
 * @export
 */
const HealthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = HealthApiFp(configuration);
    return {
        /**
         * Sends a test email to the provided email address. Useful for testing Baserow\'s email configuration as errors are clearly returned.
         * @param {HealthApiEmailTesterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailTester(requestParameters, options) {
            return localVarFp.emailTester(requestParameters.emailTesterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Runs a full health check testing as many services and systems as possible. These health checks can be expensive operations such as writing files to storage etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fullHealthCheck(options) {
            return localVarFp.fullHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends BaseAPI {
    /**
     * Sends a test email to the provided email address. Useful for testing Baserow\'s email configuration as errors are clearly returned.
     * @param {HealthApiEmailTesterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    emailTester(requestParameters, options) {
        return HealthApiFp(this.configuration).emailTester(requestParameters.emailTesterRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Runs a full health check testing as many services and systems as possible. These health checks can be expensive operations such as writing files to storage etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    fullHealthCheck(options) {
        return HealthApiFp(this.configuration).fullHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
const IntegrationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new integration
         * @param {number} applicationId Creates an integration for the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {IntegrationCreateIntegration} [integrationCreateIntegration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationIntegration: (applicationId_1, clientSessionId_1, integrationCreateIntegration_1, ...args_1) => __awaiter(this, [applicationId_1, clientSessionId_1, integrationCreateIntegration_1, ...args_1], void 0, function* (applicationId, clientSessionId, integrationCreateIntegration, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationIntegration', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/integrations/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(integrationCreateIntegration, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the integration related by the given id.
         * @param {number} integrationId The id of the integration
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationIntegration: (integrationId_1, clientSessionId_1, ...args_1) => __awaiter(this, [integrationId_1, clientSessionId_1, ...args_1], void 0, function* (integrationId, clientSessionId, options = {}) {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('deleteApplicationIntegration', 'integrationId', integrationId);
            const localVarPath = `/integration/{integration_id}/`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the integrations of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the integrations of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationIntegrations: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationIntegrations', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/integrations/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Moves the integration in the application before another integration or at the end of the application if no before integration is given. The integrations must belong to the same application.
         * @param {number} integrationId The id of the integration to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveIntegration} [patchedMoveIntegration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationIntegration: (integrationId_1, clientSessionId_1, patchedMoveIntegration_1, ...args_1) => __awaiter(this, [integrationId_1, clientSessionId_1, patchedMoveIntegration_1, ...args_1], void 0, function* (integrationId, clientSessionId, patchedMoveIntegration, options = {}) {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('moveApplicationIntegration', 'integrationId', integrationId);
            const localVarPath = `/integration/{integration_id}/move/`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMoveIntegration, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing integration.
         * @param {number} integrationId The id of the integration
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {LocalBaserowIntegrationUpdateIntegration} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationIntegration: (integrationId_1, clientSessionId_1, body_1, ...args_1) => __awaiter(this, [integrationId_1, clientSessionId_1, body_1, ...args_1], void 0, function* (integrationId, clientSessionId, body, options = {}) {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateApplicationIntegration', 'integrationId', integrationId);
            const localVarPath = `/integration/{integration_id}/`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * IntegrationsApi - functional programming interface
 * @export
 */
const IntegrationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new integration
         * @param {number} applicationId Creates an integration for the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {IntegrationCreateIntegration} [integrationCreateIntegration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationIntegration(applicationId, clientSessionId, integrationCreateIntegration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApplicationIntegration(applicationId, clientSessionId, integrationCreateIntegration, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['IntegrationsApi.createApplicationIntegration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the integration related by the given id.
         * @param {number} integrationId The id of the integration
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationIntegration(integrationId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplicationIntegration(integrationId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['IntegrationsApi.deleteApplicationIntegration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the integrations of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the integrations of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationIntegrations(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationIntegrations(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['IntegrationsApi.listApplicationIntegrations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Moves the integration in the application before another integration or at the end of the application if no before integration is given. The integrations must belong to the same application.
         * @param {number} integrationId The id of the integration to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveIntegration} [patchedMoveIntegration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationIntegration(integrationId, clientSessionId, patchedMoveIntegration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.moveApplicationIntegration(integrationId, clientSessionId, patchedMoveIntegration, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['IntegrationsApi.moveApplicationIntegration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing integration.
         * @param {number} integrationId The id of the integration
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {LocalBaserowIntegrationUpdateIntegration} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationIntegration(integrationId, clientSessionId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplicationIntegration(integrationId, clientSessionId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['IntegrationsApi.updateApplicationIntegration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * IntegrationsApi - factory interface
 * @export
 */
const IntegrationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = IntegrationsApiFp(configuration);
    return {
        /**
         * Creates a new integration
         * @param {IntegrationsApiCreateApplicationIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationIntegration(requestParameters, options) {
            return localVarFp.createApplicationIntegration(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.integrationCreateIntegration, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the integration related by the given id.
         * @param {IntegrationsApiDeleteApplicationIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationIntegration(requestParameters, options) {
            return localVarFp.deleteApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the integrations of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {IntegrationsApiListApplicationIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationIntegrations(requestParameters, options) {
            return localVarFp.listApplicationIntegrations(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves the integration in the application before another integration or at the end of the application if no before integration is given. The integrations must belong to the same application.
         * @param {IntegrationsApiMoveApplicationIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationIntegration(requestParameters, options) {
            return localVarFp.moveApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, requestParameters.patchedMoveIntegration, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing integration.
         * @param {IntegrationsApiUpdateApplicationIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationIntegration(requestParameters, options) {
            return localVarFp.updateApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
class IntegrationsApi extends BaseAPI {
    /**
     * Creates a new integration
     * @param {IntegrationsApiCreateApplicationIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    createApplicationIntegration(requestParameters, options) {
        return IntegrationsApiFp(this.configuration).createApplicationIntegration(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.integrationCreateIntegration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the integration related by the given id.
     * @param {IntegrationsApiDeleteApplicationIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    deleteApplicationIntegration(requestParameters, options) {
        return IntegrationsApiFp(this.configuration).deleteApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the integrations of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {IntegrationsApiListApplicationIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    listApplicationIntegrations(requestParameters, options) {
        return IntegrationsApiFp(this.configuration).listApplicationIntegrations(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Moves the integration in the application before another integration or at the end of the application if no before integration is given. The integrations must belong to the same application.
     * @param {IntegrationsApiMoveApplicationIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    moveApplicationIntegration(requestParameters, options) {
        return IntegrationsApiFp(this.configuration).moveApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, requestParameters.patchedMoveIntegration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing integration.
     * @param {IntegrationsApiUpdateApplicationIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    updateApplicationIntegration(requestParameters, options) {
        return IntegrationsApiFp(this.configuration).updateApplicationIntegration(requestParameters.integrationId, requestParameters.clientSessionId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * JobsApi - axios parameter creator
 * @export
 */
const JobsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new job. This job runs asynchronously in the background and execute the task specific to the provided typeparameters. The `get_job` can be used to get the current state of the job.
         * @param {JobTypeCreateJob} [jobTypeCreateJob]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: (jobTypeCreateJob_1, ...args_1) => __awaiter(this, [jobTypeCreateJob_1, ...args_1], void 0, function* (jobTypeCreateJob, options = {}) {
            const localVarPath = `/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(jobTypeCreateJob, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the information related to the provided job id. This endpoint can for example be polled to get the state and progress of the job in real time.
         * @param {number} jobId The job id to lookup information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: (jobId_1, ...args_1) => __awaiter(this, [jobId_1, ...args_1], void 0, function* (jobId, options = {}) {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId);
            const localVarPath = `/jobs/{job_id}/`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all existing jobs. Jobs are task executed asynchronously in the background. You can use the `get_job` endpoint to read the currentprogress of a the job.
         * @param {string} [jobIds] A comma separated list of job ids in the desired order.The jobs will be returned in the same order as the ids.If a job id is not found it will be ignored.
         * @param {string} [states] A comma separated list of jobs state to look for. The only possible values are: &#x60;pending&#x60;, &#x60;finished&#x60; and &#x60;failed&#x60;. It\&#39;s possible to exclude a state by prefixing it with a &#x60;!&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJob: (jobIds_1, states_1, ...args_1) => __awaiter(this, [jobIds_1, states_1, ...args_1], void 0, function* (jobIds, states, options = {}) {
            const localVarPath = `/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (jobIds !== undefined) {
                localVarQueryParameter['job_ids'] = jobIds;
            }
            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * JobsApi - functional programming interface
 * @export
 */
const JobsApiFp = function (configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new job. This job runs asynchronously in the background and execute the task specific to the provided typeparameters. The `get_job` can be used to get the current state of the job.
         * @param {JobTypeCreateJob} [jobTypeCreateJob]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(jobTypeCreateJob, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createJob(jobTypeCreateJob, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['JobsApi.createJob']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the information related to the provided job id. This endpoint can for example be polled to get the state and progress of the job in real time.
         * @param {number} jobId The job id to lookup information about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getJob(jobId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['JobsApi.getJob']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all existing jobs. Jobs are task executed asynchronously in the background. You can use the `get_job` endpoint to read the currentprogress of a the job.
         * @param {string} [jobIds] A comma separated list of job ids in the desired order.The jobs will be returned in the same order as the ids.If a job id is not found it will be ignored.
         * @param {string} [states] A comma separated list of jobs state to look for. The only possible values are: &#x60;pending&#x60;, &#x60;finished&#x60; and &#x60;failed&#x60;. It\&#39;s possible to exclude a state by prefixing it with a &#x60;!&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJob(jobIds, states, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listJob(jobIds, states, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['JobsApi.listJob']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * JobsApi - factory interface
 * @export
 */
const JobsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = JobsApiFp(configuration);
    return {
        /**
         * Creates a new job. This job runs asynchronously in the background and execute the task specific to the provided typeparameters. The `get_job` can be used to get the current state of the job.
         * @param {JobsApiCreateJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(requestParameters = {}, options) {
            return localVarFp.createJob(requestParameters.jobTypeCreateJob, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the information related to the provided job id. This endpoint can for example be polled to get the state and progress of the job in real time.
         * @param {JobsApiGetJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(requestParameters, options) {
            return localVarFp.getJob(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all existing jobs. Jobs are task executed asynchronously in the background. You can use the `get_job` endpoint to read the currentprogress of a the job.
         * @param {JobsApiListJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJob(requestParameters = {}, options) {
            return localVarFp.listJob(requestParameters.jobIds, requestParameters.states, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
class JobsApi extends BaseAPI {
    /**
     * Creates a new job. This job runs asynchronously in the background and execute the task specific to the provided typeparameters. The `get_job` can be used to get the current state of the job.
     * @param {JobsApiCreateJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    createJob(requestParameters = {}, options) {
        return JobsApiFp(this.configuration).createJob(requestParameters.jobTypeCreateJob, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the information related to the provided job id. This endpoint can for example be polled to get the state and progress of the job in real time.
     * @param {JobsApiGetJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    getJob(requestParameters, options) {
        return JobsApiFp(this.configuration).getJob(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all existing jobs. Jobs are task executed asynchronously in the background. You can use the `get_job` endpoint to read the currentprogress of a the job.
     * @param {JobsApiListJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    listJob(requestParameters = {}, options) {
        return JobsApiFp(this.configuration).listJob(requestParameters.jobIds, requestParameters.states, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NotificationsApi - axios parameter creator
 * @export
 */
const NotificationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Clear all the notifications for the given workspace and user.
         * @param {number} workspaceId The workspace the notifications are in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearWorkspaceNotifications: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('clearWorkspaceNotifications', 'workspaceId', workspaceId);
            const localVarPath = `/notifications/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the notifications for the given workspace and the current user. The response is paginated and the limit and offset parameters can be controlled using the query parameters.
         * @param {number} workspaceId The workspace id that the notifications belong to.
         * @param {number} [limit] Defines how many notifications should be returned.
         * @param {number} [offset] Defines the offset of the notifications that should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceNotifications: (workspaceId_1, limit_1, offset_1, ...args_1) => __awaiter(this, [workspaceId_1, limit_1, offset_1, ...args_1], void 0, function* (workspaceId, limit, offset, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceNotifications', 'workspaceId', workspaceId);
            const localVarPath = `/notifications/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Mark as read all the notifications for the given workspace and user.
         * @param {number} workspaceId The workspace the notifications are in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllWorkspaceNotificationsAsRead: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('markAllWorkspaceNotificationsAsRead', 'workspaceId', workspaceId);
            const localVarPath = `/notifications/{workspace_id}/mark-all-as-read/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Marks a notification as read.
         * @param {number} notificationId The notification id to update.
         * @param {number} workspaceId The workspace the notification is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: (notificationId_1, workspaceId_1, ...args_1) => __awaiter(this, [notificationId_1, workspaceId_1, ...args_1], void 0, function* (notificationId, workspaceId, options = {}) {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('markNotificationAsRead', 'notificationId', notificationId);
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('markNotificationAsRead', 'workspaceId', workspaceId);
            const localVarPath = `/notifications/{workspace_id}/{notification_id}/`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NotificationsApi - functional programming interface
 * @export
 */
const NotificationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Clear all the notifications for the given workspace and user.
         * @param {number} workspaceId The workspace the notifications are in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearWorkspaceNotifications(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.clearWorkspaceNotifications(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['NotificationsApi.clearWorkspaceNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the notifications for the given workspace and the current user. The response is paginated and the limit and offset parameters can be controlled using the query parameters.
         * @param {number} workspaceId The workspace id that the notifications belong to.
         * @param {number} [limit] Defines how many notifications should be returned.
         * @param {number} [offset] Defines the offset of the notifications that should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceNotifications(workspaceId, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkspaceNotifications(workspaceId, limit, offset, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['NotificationsApi.listWorkspaceNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Mark as read all the notifications for the given workspace and user.
         * @param {number} workspaceId The workspace the notifications are in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllWorkspaceNotificationsAsRead(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.markAllWorkspaceNotificationsAsRead(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['NotificationsApi.markAllWorkspaceNotificationsAsRead']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Marks a notification as read.
         * @param {number} notificationId The notification id to update.
         * @param {number} workspaceId The workspace the notification is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead(notificationId, workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.markNotificationAsRead(notificationId, workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['NotificationsApi.markNotificationAsRead']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * NotificationsApi - factory interface
 * @export
 */
const NotificationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NotificationsApiFp(configuration);
    return {
        /**
         * Clear all the notifications for the given workspace and user.
         * @param {NotificationsApiClearWorkspaceNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearWorkspaceNotifications(requestParameters, options) {
            return localVarFp.clearWorkspaceNotifications(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the notifications for the given workspace and the current user. The response is paginated and the limit and offset parameters can be controlled using the query parameters.
         * @param {NotificationsApiListWorkspaceNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceNotifications(requestParameters, options) {
            return localVarFp.listWorkspaceNotifications(requestParameters.workspaceId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark as read all the notifications for the given workspace and user.
         * @param {NotificationsApiMarkAllWorkspaceNotificationsAsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllWorkspaceNotificationsAsRead(requestParameters, options) {
            return localVarFp.markAllWorkspaceNotificationsAsRead(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a notification as read.
         * @param {NotificationsApiMarkNotificationAsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead(requestParameters, options) {
            return localVarFp.markNotificationAsRead(requestParameters.notificationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
class NotificationsApi extends BaseAPI {
    /**
     * Clear all the notifications for the given workspace and user.
     * @param {NotificationsApiClearWorkspaceNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    clearWorkspaceNotifications(requestParameters, options) {
        return NotificationsApiFp(this.configuration).clearWorkspaceNotifications(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the notifications for the given workspace and the current user. The response is paginated and the limit and offset parameters can be controlled using the query parameters.
     * @param {NotificationsApiListWorkspaceNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    listWorkspaceNotifications(requestParameters, options) {
        return NotificationsApiFp(this.configuration).listWorkspaceNotifications(requestParameters.workspaceId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Mark as read all the notifications for the given workspace and user.
     * @param {NotificationsApiMarkAllWorkspaceNotificationsAsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    markAllWorkspaceNotificationsAsRead(requestParameters, options) {
        return NotificationsApiFp(this.configuration).markAllWorkspaceNotificationsAsRead(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Marks a notification as read.
     * @param {NotificationsApiMarkNotificationAsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    markNotificationAsRead(requestParameters, options) {
        return NotificationsApiFp(this.configuration).markNotificationAsRead(requestParameters.notificationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * RoleAssignmentsApi - axios parameter creator
 * @export
 */
const RoleAssignmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * You can assign a role to a subject into the given workspace for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} workspaceId The workspace in which the role assignment takes place.
         * @param {CreateRoleAssignment} createRoleAssignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole: (workspaceId_1, createRoleAssignment_1, ...args_1) => __awaiter(this, [workspaceId_1, createRoleAssignment_1, ...args_1], void 0, function* (workspaceId, createRoleAssignment, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('assignRole', 'workspaceId', workspaceId);
            // verify required parameter 'createRoleAssignment' is not null or undefined
            assertParamExists('assignRole', 'createRoleAssignment', createRoleAssignment);
            const localVarPath = `/role/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleAssignment, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can assign a role to a multiple subjects into the given workspace for the given scopes with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} workspaceId The workspace in which the role assignment takes place.
         * @param {BatchCreateRoleAssignment} batchCreateRoleAssignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAssignRole: (workspaceId_1, batchCreateRoleAssignment_1, ...args_1) => __awaiter(this, [workspaceId_1, batchCreateRoleAssignment_1, ...args_1], void 0, function* (workspaceId, batchCreateRoleAssignment, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('batchAssignRole', 'workspaceId', workspaceId);
            // verify required parameter 'batchCreateRoleAssignment' is not null or undefined
            assertParamExists('batchAssignRole', 'batchCreateRoleAssignment', batchCreateRoleAssignment);
            const localVarPath = `/role/{workspace_id}/batch/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(batchCreateRoleAssignment, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a subject into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} groupId The group in which the role assignment takes place.
         * @param {CreateRoleAssignment} createRoleAssignment
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupAssignRole: (groupId_1, createRoleAssignment_1, ...args_1) => __awaiter(this, [groupId_1, createRoleAssignment_1, ...args_1], void 0, function* (groupId, createRoleAssignment, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupAssignRole', 'groupId', groupId);
            // verify required parameter 'createRoleAssignment' is not null or undefined
            assertParamExists('groupAssignRole', 'createRoleAssignment', createRoleAssignment);
            const localVarPath = `/role/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleAssignment, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_batch_assign_role](#tag/Role-assignments/operation/workspace_batch_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a multiple subjects into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} groupId The group in which the role assignment takes place.
         * @param {BatchCreateRoleAssignment} batchCreateRoleAssignment
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupBatchAssignRole: (groupId_1, batchCreateRoleAssignment_1, ...args_1) => __awaiter(this, [groupId_1, batchCreateRoleAssignment_1, ...args_1], void 0, function* (groupId, batchCreateRoleAssignment, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupBatchAssignRole', 'groupId', groupId);
            // verify required parameter 'batchCreateRoleAssignment' is not null or undefined
            assertParamExists('groupBatchAssignRole', 'batchCreateRoleAssignment', batchCreateRoleAssignment);
            const localVarPath = `/role/{group_id}/batch/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(batchCreateRoleAssignment, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can list the role assignments within a group, optionally filtered down to a specific scope inside of that group. If the scope isn\'t specified,the group will be considered the scope.
         * @param {number} groupId The group in which the role assignments are related to.
         * @param {number} [scopeId] The id of the scope you are trying to get all roleassignments for.
         * @param {string} [scopeType] The type of scope you are trying to get all roleassignments for.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListRoleAssignments: (groupId_1, scopeId_1, scopeType_1, ...args_1) => __awaiter(this, [groupId_1, scopeId_1, scopeType_1, ...args_1], void 0, function* (groupId, scopeId, scopeType, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupListRoleAssignments', 'groupId', groupId);
            const localVarPath = `/role/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (scopeId !== undefined) {
                localVarQueryParameter['scope_id'] = scopeId;
            }
            if (scopeType !== undefined) {
                localVarQueryParameter['scope_type'] = scopeType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can list the role assignments within a workspace, optionally filtered downto a specific scope inside of that workspace. If the scope isn\'t specified,the workspace will be considered the scope.
         * @param {number} workspaceId The workspace in which the role assignments are related to.
         * @param {number} [scopeId] The id of the scope you are trying to get all roleassignments for.
         * @param {string} [scopeType] The type of scope you are trying to get all roleassignments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleAssignments: (workspaceId_1, scopeId_1, scopeType_1, ...args_1) => __awaiter(this, [workspaceId_1, scopeId_1, scopeType_1, ...args_1], void 0, function* (workspaceId, scopeId, scopeType, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRoleAssignments', 'workspaceId', workspaceId);
            const localVarPath = `/role/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (scopeId !== undefined) {
                localVarQueryParameter['scope_id'] = scopeId;
            }
            if (scopeType !== undefined) {
                localVarQueryParameter['scope_type'] = scopeType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RoleAssignmentsApi - functional programming interface
 * @export
 */
const RoleAssignmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * You can assign a role to a subject into the given workspace for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} workspaceId The workspace in which the role assignment takes place.
         * @param {CreateRoleAssignment} createRoleAssignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole(workspaceId, createRoleAssignment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.assignRole(workspaceId, createRoleAssignment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.assignRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can assign a role to a multiple subjects into the given workspace for the given scopes with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} workspaceId The workspace in which the role assignment takes place.
         * @param {BatchCreateRoleAssignment} batchCreateRoleAssignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAssignRole(workspaceId, batchCreateRoleAssignment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchAssignRole(workspaceId, batchCreateRoleAssignment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.batchAssignRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a subject into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} groupId The group in which the role assignment takes place.
         * @param {CreateRoleAssignment} createRoleAssignment
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupAssignRole(groupId, createRoleAssignment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupAssignRole(groupId, createRoleAssignment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.groupAssignRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_batch_assign_role](#tag/Role-assignments/operation/workspace_batch_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a multiple subjects into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {number} groupId The group in which the role assignment takes place.
         * @param {BatchCreateRoleAssignment} batchCreateRoleAssignment
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupBatchAssignRole(groupId, batchCreateRoleAssignment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupBatchAssignRole(groupId, batchCreateRoleAssignment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.groupBatchAssignRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can list the role assignments within a group, optionally filtered down to a specific scope inside of that group. If the scope isn\'t specified,the group will be considered the scope.
         * @param {number} groupId The group in which the role assignments are related to.
         * @param {number} [scopeId] The id of the scope you are trying to get all roleassignments for.
         * @param {string} [scopeType] The type of scope you are trying to get all roleassignments for.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListRoleAssignments(groupId, scopeId, scopeType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupListRoleAssignments(groupId, scopeId, scopeType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.groupListRoleAssignments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can list the role assignments within a workspace, optionally filtered downto a specific scope inside of that workspace. If the scope isn\'t specified,the workspace will be considered the scope.
         * @param {number} workspaceId The workspace in which the role assignments are related to.
         * @param {number} [scopeId] The id of the scope you are trying to get all roleassignments for.
         * @param {string} [scopeType] The type of scope you are trying to get all roleassignments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleAssignments(workspaceId, scopeId, scopeType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRoleAssignments(workspaceId, scopeId, scopeType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['RoleAssignmentsApi.listRoleAssignments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * RoleAssignmentsApi - factory interface
 * @export
 */
const RoleAssignmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RoleAssignmentsApiFp(configuration);
    return {
        /**
         * You can assign a role to a subject into the given workspace for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole(requestParameters, options) {
            return localVarFp.assignRole(requestParameters.workspaceId, requestParameters.createRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * You can assign a role to a multiple subjects into the given workspace for the given scopes with this endpoint. If you want to remove the role you can omit the role property.
         * @param {RoleAssignmentsApiBatchAssignRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAssignRole(requestParameters, options) {
            return localVarFp.batchAssignRole(requestParameters.workspaceId, requestParameters.batchCreateRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a subject into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {RoleAssignmentsApiGroupAssignRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupAssignRole(requestParameters, options) {
            return localVarFp.groupAssignRole(requestParameters.groupId, requestParameters.createRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_batch_assign_role](#tag/Role-assignments/operation/workspace_batch_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a multiple subjects into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
         * @param {RoleAssignmentsApiGroupBatchAssignRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupBatchAssignRole(requestParameters, options) {
            return localVarFp.groupBatchAssignRole(requestParameters.groupId, requestParameters.batchCreateRoleAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can list the role assignments within a group, optionally filtered down to a specific scope inside of that group. If the scope isn\'t specified,the group will be considered the scope.
         * @param {RoleAssignmentsApiGroupListRoleAssignmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListRoleAssignments(requestParameters, options) {
            return localVarFp.groupListRoleAssignments(requestParameters.groupId, requestParameters.scopeId, requestParameters.scopeType, options).then((request) => request(axios, basePath));
        },
        /**
         * You can list the role assignments within a workspace, optionally filtered downto a specific scope inside of that workspace. If the scope isn\'t specified,the workspace will be considered the scope.
         * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleAssignments(requestParameters, options) {
            return localVarFp.listRoleAssignments(requestParameters.workspaceId, requestParameters.scopeId, requestParameters.scopeType, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RoleAssignmentsApi - object-oriented interface
 * @export
 * @class RoleAssignmentsApi
 * @extends {BaseAPI}
 */
class RoleAssignmentsApi extends BaseAPI {
    /**
     * You can assign a role to a subject into the given workspace for the given scope with this endpoint. If you want to remove the role you can omit the role property.
     * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    assignRole(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).assignRole(requestParameters.workspaceId, requestParameters.createRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can assign a role to a multiple subjects into the given workspace for the given scopes with this endpoint. If you want to remove the role you can omit the role property.
     * @param {RoleAssignmentsApiBatchAssignRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    batchAssignRole(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).batchAssignRole(requestParameters.workspaceId, requestParameters.batchCreateRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a subject into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
     * @param {RoleAssignmentsApiGroupAssignRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    groupAssignRole(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).groupAssignRole(requestParameters.groupId, requestParameters.createRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_batch_assign_role](#tag/Role-assignments/operation/workspace_batch_assign_role).**  **Support for this endpoint will end in 2024.**   You can assign a role to a multiple subjects into the given group for the given scope with this endpoint. If you want to remove the role you can omit the role property.
     * @param {RoleAssignmentsApiGroupBatchAssignRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    groupBatchAssignRole(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).groupBatchAssignRole(requestParameters.groupId, requestParameters.batchCreateRoleAssignment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_assign_role](#tag/Role-assignments/operation/workspace_assign_role).**  **Support for this endpoint will end in 2024.**   You can list the role assignments within a group, optionally filtered down to a specific scope inside of that group. If the scope isn\'t specified,the group will be considered the scope.
     * @param {RoleAssignmentsApiGroupListRoleAssignmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    groupListRoleAssignments(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).groupListRoleAssignments(requestParameters.groupId, requestParameters.scopeId, requestParameters.scopeType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can list the role assignments within a workspace, optionally filtered downto a specific scope inside of that workspace. If the scope isn\'t specified,the workspace will be considered the scope.
     * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    listRoleAssignments(requestParameters, options) {
        return RoleAssignmentsApiFp(this.configuration).listRoleAssignments(requestParameters.workspaceId, requestParameters.scopeId, requestParameters.scopeType, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SecureFileServeApi - axios parameter creator
 * @export
 */
const SecureFileServeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Downloads a file using the backend and the secure file serve feature. The signed data is extracted from the URL and used to verify if the user has access to the file. If the permissions check passes and the file exists, the file is served to the user.  This is a **enterprise** feature.
         * @param {string} signedData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secureFileServeDownload: (signedData_1, ...args_1) => __awaiter(this, [signedData_1, ...args_1], void 0, function* (signedData, options = {}) {
            // verify required parameter 'signedData' is not null or undefined
            assertParamExists('secureFileServeDownload', 'signedData', signedData);
            const localVarPath = `/files/{signed_data}`
                .replace(`{${"signed_data"}}`, encodeURIComponent(String(signedData)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SecureFileServeApi - functional programming interface
 * @export
 */
const SecureFileServeApiFp = function (configuration) {
    const localVarAxiosParamCreator = SecureFileServeApiAxiosParamCreator(configuration);
    return {
        /**
         * Downloads a file using the backend and the secure file serve feature. The signed data is extracted from the URL and used to verify if the user has access to the file. If the permissions check passes and the file exists, the file is served to the user.  This is a **enterprise** feature.
         * @param {string} signedData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secureFileServeDownload(signedData, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.secureFileServeDownload(signedData, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SecureFileServeApi.secureFileServeDownload']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SecureFileServeApi - factory interface
 * @export
 */
const SecureFileServeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SecureFileServeApiFp(configuration);
    return {
        /**
         * Downloads a file using the backend and the secure file serve feature. The signed data is extracted from the URL and used to verify if the user has access to the file. If the permissions check passes and the file exists, the file is served to the user.  This is a **enterprise** feature.
         * @param {SecureFileServeApiSecureFileServeDownloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secureFileServeDownload(requestParameters, options) {
            return localVarFp.secureFileServeDownload(requestParameters.signedData, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SecureFileServeApi - object-oriented interface
 * @export
 * @class SecureFileServeApi
 * @extends {BaseAPI}
 */
class SecureFileServeApi extends BaseAPI {
    /**
     * Downloads a file using the backend and the secure file serve feature. The signed data is extracted from the URL and used to verify if the user has access to the file. If the permissions check passes and the file exists, the file is served to the user.  This is a **enterprise** feature.
     * @param {SecureFileServeApiSecureFileServeDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureFileServeApi
     */
    secureFileServeDownload(requestParameters, options) {
        return SecureFileServeApiFp(this.configuration).secureFileServeDownload(requestParameters.signedData, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SettingsApi - axios parameter creator
 * @export
 */
const SettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Responds with the self hosted instance id. Only a user with staff permissions can request it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceId: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/settings/instance-id/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with all the admin configured settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the admin configured settings if the user has admin permissions.
         * @param {PatchedSettings} [patchedSettings]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: (patchedSettings_1, ...args_1) => __awaiter(this, [patchedSettings_1, ...args_1], void 0, function* (patchedSettings, options = {}) {
            const localVarPath = `/settings/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSettings, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SettingsApi - functional programming interface
 * @export
 */
const SettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Responds with the self hosted instance id. Only a user with staff permissions can request it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceId(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstanceId(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SettingsApi.getInstanceId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with all the admin configured settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSettings(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SettingsApi.getSettings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the admin configured settings if the user has admin permissions.
         * @param {PatchedSettings} [patchedSettings]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(patchedSettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateSettings(patchedSettings, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SettingsApi.updateSettings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SettingsApi - factory interface
 * @export
 */
const SettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SettingsApiFp(configuration);
    return {
        /**
         * Responds with the self hosted instance id. Only a user with staff permissions can request it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceId(options) {
            return localVarFp.getInstanceId(options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with all the admin configured settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options) {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the admin configured settings if the user has admin permissions.
         * @param {SettingsApiUpdateSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(requestParameters = {}, options) {
            return localVarFp.updateSettings(requestParameters.patchedSettings, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
class SettingsApi extends BaseAPI {
    /**
     * Responds with the self hosted instance id. Only a user with staff permissions can request it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    getInstanceId(options) {
        return SettingsApiFp(this.configuration).getInstanceId(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with all the admin configured settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    getSettings(options) {
        return SettingsApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the admin configured settings if the user has admin permissions.
     * @param {SettingsApiUpdateSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    updateSettings(requestParameters = {}, options) {
        return SettingsApiFp(this.configuration).updateSettings(requestParameters.patchedSettings, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
const SnapshotsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new application snapshot. Snapshots represent a state of an application at a specific point in time and can be restored later, making it easy to create backups of entire applications.
         * @param {number} applicationId Application ID for which to list snapshots.
         * @param {Snapshot} snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: (applicationId_1, snapshot_1, ...args_1) => __awaiter(this, [applicationId_1, snapshot_1, ...args_1], void 0, function* (applicationId, snapshot, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createSnapshot', 'applicationId', applicationId);
            // verify required parameter 'snapshot' is not null or undefined
            assertParamExists('createSnapshot', 'snapshot', snapshot);
            const localVarPath = `/snapshots/application/{application_id}/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(snapshot, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a snapshot. Deleting a snapshot doesn\'t affect the application that the snapshot is made from and doesn\'t affect any applications that were created by restoring it. Snapshot deletion is permanent and can\'t be undone.
         * @param {number} snapshotId Id of the snapshot to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot: (snapshotId_1, ...args_1) => __awaiter(this, [snapshotId_1, ...args_1], void 0, function* (snapshotId, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('deleteSnapshot', 'snapshotId', snapshotId);
            const localVarPath = `/snapshots/{snapshot_id}/`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists snapshots that were created for a given application.
         * @param {number} applicationId Application ID for which to list snapshots.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listSnapshots', 'applicationId', applicationId);
            const localVarPath = `/snapshots/application/{application_id}/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restores a snapshot. When an application snapshot is restored, a new application will be created in the same workspace that the original application was placed in with the name of the snapshot and data that were in the original application at the time the snapshot was taken. The original application that the snapshot was taken from is unaffected. Snapshots can be restored multiple times and a number suffix is added to the new application name in the case of a collision.
         * @param {number} snapshotId Id of the snapshot to restore.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshot: (snapshotId_1, ...args_1) => __awaiter(this, [snapshotId_1, ...args_1], void 0, function* (snapshotId, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('restoreSnapshot', 'snapshotId', snapshotId);
            const localVarPath = `/snapshots/{snapshot_id}/restore/`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SnapshotsApi - functional programming interface
 * @export
 */
const SnapshotsApiFp = function (configuration) {
    const localVarAxiosParamCreator = SnapshotsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new application snapshot. Snapshots represent a state of an application at a specific point in time and can be restored later, making it easy to create backups of entire applications.
         * @param {number} applicationId Application ID for which to list snapshots.
         * @param {Snapshot} snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(applicationId, snapshot, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSnapshot(applicationId, snapshot, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SnapshotsApi.createSnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a snapshot. Deleting a snapshot doesn\'t affect the application that the snapshot is made from and doesn\'t affect any applications that were created by restoring it. Snapshot deletion is permanent and can\'t be undone.
         * @param {number} snapshotId Id of the snapshot to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(snapshotId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSnapshot(snapshotId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SnapshotsApi.deleteSnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists snapshots that were created for a given application.
         * @param {number} applicationId Application ID for which to list snapshots.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSnapshots(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SnapshotsApi.listSnapshots']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restores a snapshot. When an application snapshot is restored, a new application will be created in the same workspace that the original application was placed in with the name of the snapshot and data that were in the original application at the time the snapshot was taken. The original application that the snapshot was taken from is unaffected. Snapshots can be restored multiple times and a number suffix is added to the new application name in the case of a collision.
         * @param {number} snapshotId Id of the snapshot to restore.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshot(snapshotId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.restoreSnapshot(snapshotId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['SnapshotsApi.restoreSnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SnapshotsApi - factory interface
 * @export
 */
const SnapshotsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SnapshotsApiFp(configuration);
    return {
        /**
         * Creates a new application snapshot. Snapshots represent a state of an application at a specific point in time and can be restored later, making it easy to create backups of entire applications.
         * @param {SnapshotsApiCreateSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(requestParameters, options) {
            return localVarFp.createSnapshot(requestParameters.applicationId, requestParameters.snapshot, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a snapshot. Deleting a snapshot doesn\'t affect the application that the snapshot is made from and doesn\'t affect any applications that were created by restoring it. Snapshot deletion is permanent and can\'t be undone.
         * @param {SnapshotsApiDeleteSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(requestParameters, options) {
            return localVarFp.deleteSnapshot(requestParameters.snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists snapshots that were created for a given application.
         * @param {SnapshotsApiListSnapshotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots(requestParameters, options) {
            return localVarFp.listSnapshots(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a snapshot. When an application snapshot is restored, a new application will be created in the same workspace that the original application was placed in with the name of the snapshot and data that were in the original application at the time the snapshot was taken. The original application that the snapshot was taken from is unaffected. Snapshots can be restored multiple times and a number suffix is added to the new application name in the case of a collision.
         * @param {SnapshotsApiRestoreSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshot(requestParameters, options) {
            return localVarFp.restoreSnapshot(requestParameters.snapshotId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
class SnapshotsApi extends BaseAPI {
    /**
     * Creates a new application snapshot. Snapshots represent a state of an application at a specific point in time and can be restored later, making it easy to create backups of entire applications.
     * @param {SnapshotsApiCreateSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    createSnapshot(requestParameters, options) {
        return SnapshotsApiFp(this.configuration).createSnapshot(requestParameters.applicationId, requestParameters.snapshot, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a snapshot. Deleting a snapshot doesn\'t affect the application that the snapshot is made from and doesn\'t affect any applications that were created by restoring it. Snapshot deletion is permanent and can\'t be undone.
     * @param {SnapshotsApiDeleteSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    deleteSnapshot(requestParameters, options) {
        return SnapshotsApiFp(this.configuration).deleteSnapshot(requestParameters.snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists snapshots that were created for a given application.
     * @param {SnapshotsApiListSnapshotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    listSnapshots(requestParameters, options) {
        return SnapshotsApiFp(this.configuration).listSnapshots(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restores a snapshot. When an application snapshot is restored, a new application will be created in the same workspace that the original application was placed in with the name of the snapshot and data that were in the original application at the time the snapshot was taken. The original application that the snapshot was taken from is unaffected. Snapshots can be restored multiple times and a number suffix is added to the new application name in the case of a collision.
     * @param {SnapshotsApiRestoreSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    restoreSnapshot(requestParameters, options) {
        return SnapshotsApiFp(this.configuration).restoreSnapshot(requestParameters.snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TeamsApi - axios parameter creator
 * @export
 */
const TeamsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new team subject.
         * @param {string} teamId
         * @param {TeamSubject} teamSubject
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject: (teamId_1, teamSubject_1, clientSessionId_1, ...args_1) => __awaiter(this, [teamId_1, teamSubject_1, clientSessionId_1, ...args_1], void 0, function* (teamId, teamSubject, clientSessionId, options = {}) {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('createSubject', 'teamId', teamId);
            // verify required parameter 'teamSubject' is not null or undefined
            assertParamExists('createSubject', 'teamSubject', teamSubject);
            const localVarPath = `/teams/{team_id}/subjects/`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(teamSubject, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a subject if the authorized user is in the team\'s workspace.
         * @param {number} subjectId The subject id to remove from the team.
         * @param {number} teamId The team id which the subject will be removed from.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject: (subjectId_1, teamId_1, clientSessionId_1, ...args_1) => __awaiter(this, [subjectId_1, teamId_1, clientSessionId_1, ...args_1], void 0, function* (subjectId, teamId, clientSessionId, options = {}) {
            // verify required parameter 'subjectId' is not null or undefined
            assertParamExists('deleteSubject', 'subjectId', subjectId);
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteSubject', 'teamId', teamId);
            const localVarPath = `/teams/{team_id}/subjects/{subject_id}/`
                .replace(`{${"subject_id"}}`, encodeURIComponent(String(subjectId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a team if the authorized user is in the team\'s workspace. All the related children (e.g. subjects) are also going to be deleted.
         * @param {number} teamId Deletes the team related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: (teamId_1, clientSessionId_1, ...args_1) => __awaiter(this, [teamId_1, clientSessionId_1, ...args_1], void 0, function* (teamId, clientSessionId, options = {}) {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeam', 'teamId', teamId);
            const localVarPath = `/teams/{team_id}/`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the information related to the provided subject id
         * @param {number} subjectId Returns the subject related to the provided value.
         * @param {string} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject: (subjectId_1, teamId_1, ...args_1) => __awaiter(this, [subjectId_1, teamId_1, ...args_1], void 0, function* (subjectId, teamId, options = {}) {
            // verify required parameter 'subjectId' is not null or undefined
            assertParamExists('getSubject', 'subjectId', subjectId);
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getSubject', 'teamId', teamId);
            const localVarPath = `/teams/{team_id}/subjects/{subject_id}/`
                .replace(`{${"subject_id"}}`, encodeURIComponent(String(subjectId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the information related to the provided team id.
         * @param {number} teamId Returns the team related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: (teamId_1, ...args_1) => __awaiter(this, [teamId_1, ...args_1], void 0, function* (teamId, options = {}) {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeam', 'teamId', teamId);
            const localVarPath = `/teams/{team_id}/`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_team](#tag/Teams/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new team in a given group.
         * @param {string} groupId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateTeam: (groupId_1, team_1, clientSessionId_1, ...args_1) => __awaiter(this, [groupId_1, team_1, clientSessionId_1, ...args_1], void 0, function* (groupId, team, clientSessionId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupCreateTeam', 'groupId', groupId);
            // verify required parameter 'team' is not null or undefined
            assertParamExists('groupCreateTeam', 'team', team);
            const localVarPath = `/teams/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_teams](#tag/Teams/operation/workspace_list_teams).**  **Support for this endpoint will end in 2024.**   Lists all teams in a given group.
         * @param {number} groupId Lists all teams in a given group.
         * @param {string} [search] Search for teams by their name.
         * @param {string} [sorts] Sort teams by name or subjects.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListTeams: (groupId_1, search_1, sorts_1, ...args_1) => __awaiter(this, [groupId_1, search_1, sorts_1, ...args_1], void 0, function* (groupId, search, sorts, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupListTeams', 'groupId', groupId);
            const localVarPath = `/teams/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all team subjects in a given team.
         * @param {string} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamSubjects: (teamId_1, ...args_1) => __awaiter(this, [teamId_1, ...args_1], void 0, function* (teamId, options = {}) {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listTeamSubjects', 'teamId', teamId);
            const localVarPath = `/teams/{team_id}/subjects/`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing team with a new name.
         * @param {string} teamId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: (teamId_1, team_1, clientSessionId_1, ...args_1) => __awaiter(this, [teamId_1, team_1, clientSessionId_1, ...args_1], void 0, function* (teamId, team, clientSessionId, options = {}) {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeam', 'teamId', teamId);
            // verify required parameter 'team' is not null or undefined
            assertParamExists('updateTeam', 'team', team);
            const localVarPath = `/teams/{team_id}/`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new team.
         * @param {string} workspaceId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateTeam: (workspaceId_1, team_1, clientSessionId_1, ...args_1) => __awaiter(this, [workspaceId_1, team_1, clientSessionId_1, ...args_1], void 0, function* (workspaceId, team, clientSessionId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceCreateTeam', 'workspaceId', workspaceId);
            // verify required parameter 'team' is not null or undefined
            assertParamExists('workspaceCreateTeam', 'team', team);
            const localVarPath = `/teams/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all teams in a given workspace.
         * @param {number} workspaceId Lists all teams in a given workspace.
         * @param {string} [search] Search for teams by their name.
         * @param {string} [sorts] Sort teams by name or subjects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListTeams: (workspaceId_1, search_1, sorts_1, ...args_1) => __awaiter(this, [workspaceId_1, search_1, sorts_1, ...args_1], void 0, function* (workspaceId, search, sorts, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceListTeams', 'workspaceId', workspaceId);
            const localVarPath = `/teams/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TeamsApi - functional programming interface
 * @export
 */
const TeamsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new team subject.
         * @param {string} teamId
         * @param {TeamSubject} teamSubject
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject(teamId, teamSubject, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubject(teamId, teamSubject, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.createSubject']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a subject if the authorized user is in the team\'s workspace.
         * @param {number} subjectId The subject id to remove from the team.
         * @param {number} teamId The team id which the subject will be removed from.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject(subjectId, teamId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSubject(subjectId, teamId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.deleteSubject']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a team if the authorized user is in the team\'s workspace. All the related children (e.g. subjects) are also going to be deleted.
         * @param {number} teamId Deletes the team related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTeam(teamId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.deleteTeam']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the information related to the provided subject id
         * @param {number} subjectId Returns the subject related to the provided value.
         * @param {string} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject(subjectId, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubject(subjectId, teamId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.getSubject']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the information related to the provided team id.
         * @param {number} teamId Returns the team related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTeam(teamId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.getTeam']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_team](#tag/Teams/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new team in a given group.
         * @param {string} groupId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateTeam(groupId, team, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupCreateTeam(groupId, team, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.groupCreateTeam']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_teams](#tag/Teams/operation/workspace_list_teams).**  **Support for this endpoint will end in 2024.**   Lists all teams in a given group.
         * @param {number} groupId Lists all teams in a given group.
         * @param {string} [search] Search for teams by their name.
         * @param {string} [sorts] Sort teams by name or subjects.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListTeams(groupId, search, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupListTeams(groupId, search, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.groupListTeams']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all team subjects in a given team.
         * @param {string} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamSubjects(teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTeamSubjects(teamId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.listTeamSubjects']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing team with a new name.
         * @param {string} teamId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId, team, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTeam(teamId, team, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.updateTeam']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new team.
         * @param {string} workspaceId
         * @param {Team} team
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateTeam(workspaceId, team, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceCreateTeam(workspaceId, team, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.workspaceCreateTeam']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all teams in a given workspace.
         * @param {number} workspaceId Lists all teams in a given workspace.
         * @param {string} [search] Search for teams by their name.
         * @param {string} [sorts] Sort teams by name or subjects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListTeams(workspaceId, search, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceListTeams(workspaceId, search, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TeamsApi.workspaceListTeams']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * TeamsApi - factory interface
 * @export
 */
const TeamsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TeamsApiFp(configuration);
    return {
        /**
         * Creates a new team subject.
         * @param {TeamsApiCreateSubjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject(requestParameters, options) {
            return localVarFp.createSubject(requestParameters.teamId, requestParameters.teamSubject, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a subject if the authorized user is in the team\'s workspace.
         * @param {TeamsApiDeleteSubjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject(requestParameters, options) {
            return localVarFp.deleteSubject(requestParameters.subjectId, requestParameters.teamId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a team if the authorized user is in the team\'s workspace. All the related children (e.g. subjects) are also going to be deleted.
         * @param {TeamsApiDeleteTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(requestParameters, options) {
            return localVarFp.deleteTeam(requestParameters.teamId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the information related to the provided subject id
         * @param {TeamsApiGetSubjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject(requestParameters, options) {
            return localVarFp.getSubject(requestParameters.subjectId, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the information related to the provided team id.
         * @param {TeamsApiGetTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(requestParameters, options) {
            return localVarFp.getTeam(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_team](#tag/Teams/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new team in a given group.
         * @param {TeamsApiGroupCreateTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupCreateTeam(requestParameters, options) {
            return localVarFp.groupCreateTeam(requestParameters.groupId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_teams](#tag/Teams/operation/workspace_list_teams).**  **Support for this endpoint will end in 2024.**   Lists all teams in a given group.
         * @param {TeamsApiGroupListTeamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupListTeams(requestParameters, options) {
            return localVarFp.groupListTeams(requestParameters.groupId, requestParameters.search, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all team subjects in a given team.
         * @param {TeamsApiListTeamSubjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamSubjects(requestParameters, options) {
            return localVarFp.listTeamSubjects(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing team with a new name.
         * @param {TeamsApiUpdateTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(requestParameters, options) {
            return localVarFp.updateTeam(requestParameters.teamId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new team.
         * @param {TeamsApiWorkspaceCreateTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCreateTeam(requestParameters, options) {
            return localVarFp.workspaceCreateTeam(requestParameters.workspaceId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all teams in a given workspace.
         * @param {TeamsApiWorkspaceListTeamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceListTeams(requestParameters, options) {
            return localVarFp.workspaceListTeams(requestParameters.workspaceId, requestParameters.search, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
class TeamsApi extends BaseAPI {
    /**
     * Creates a new team subject.
     * @param {TeamsApiCreateSubjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    createSubject(requestParameters, options) {
        return TeamsApiFp(this.configuration).createSubject(requestParameters.teamId, requestParameters.teamSubject, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a subject if the authorized user is in the team\'s workspace.
     * @param {TeamsApiDeleteSubjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    deleteSubject(requestParameters, options) {
        return TeamsApiFp(this.configuration).deleteSubject(requestParameters.subjectId, requestParameters.teamId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a team if the authorized user is in the team\'s workspace. All the related children (e.g. subjects) are also going to be deleted.
     * @param {TeamsApiDeleteTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    deleteTeam(requestParameters, options) {
        return TeamsApiFp(this.configuration).deleteTeam(requestParameters.teamId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the information related to the provided subject id
     * @param {TeamsApiGetSubjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    getSubject(requestParameters, options) {
        return TeamsApiFp(this.configuration).getSubject(requestParameters.subjectId, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the information related to the provided team id.
     * @param {TeamsApiGetTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    getTeam(requestParameters, options) {
        return TeamsApiFp(this.configuration).getTeam(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_create_team](#tag/Teams/operation/create_workspace).**  **Support for this endpoint will end in 2024.**   Creates a new team in a given group.
     * @param {TeamsApiGroupCreateTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    groupCreateTeam(requestParameters, options) {
        return TeamsApiFp(this.configuration).groupCreateTeam(requestParameters.groupId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_list_teams](#tag/Teams/operation/workspace_list_teams).**  **Support for this endpoint will end in 2024.**   Lists all teams in a given group.
     * @param {TeamsApiGroupListTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    groupListTeams(requestParameters, options) {
        return TeamsApiFp(this.configuration).groupListTeams(requestParameters.groupId, requestParameters.search, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all team subjects in a given team.
     * @param {TeamsApiListTeamSubjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    listTeamSubjects(requestParameters, options) {
        return TeamsApiFp(this.configuration).listTeamSubjects(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing team with a new name.
     * @param {TeamsApiUpdateTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    updateTeam(requestParameters, options) {
        return TeamsApiFp(this.configuration).updateTeam(requestParameters.teamId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new team.
     * @param {TeamsApiWorkspaceCreateTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    workspaceCreateTeam(requestParameters, options) {
        return TeamsApiFp(this.configuration).workspaceCreateTeam(requestParameters.workspaceId, requestParameters.team, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all teams in a given workspace.
     * @param {TeamsApiWorkspaceListTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    workspaceListTeams(requestParameters, options) {
        return TeamsApiFp(this.configuration).workspaceListTeams(requestParameters.workspaceId, requestParameters.search, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TemplatesApi - axios parameter creator
 * @export
 */
const TemplatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template](#tag/Templates/operation/workspace_install_template).**  **Support for this endpoint will end in 2024.**   Installs the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {number} groupId The id related to the group where the template applications must be installed into.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplate: (groupId_1, templateId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [groupId_1, templateId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInstallTemplate', 'groupId', groupId);
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('groupInstallTemplate', 'templateId', templateId);
            const localVarPath = `/templates/install/{group_id}/{template_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template_async](#tag/Templates/operation/workspace_install_template_async).**  **Support for this endpoint will end in 2024.**   Start an async job to install the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {number} groupId The id related to the group where the template applications must be installed into.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplateAsync: (groupId_1, templateId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [groupId_1, templateId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInstallTemplateAsync', 'groupId', groupId);
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('groupInstallTemplateAsync', 'templateId', templateId);
            const localVarPath = `/templates/install/{group_id}/{template_id}/async/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * (Deprecated) Installs the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {number} workspaceId The id related to the workspace where the template applications must be installed into.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplate: (templateId_1, workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [templateId_1, workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('installTemplate', 'templateId', templateId);
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('installTemplate', 'workspaceId', workspaceId);
            const localVarPath = `/templates/install/{workspace_id}/{template_id}/`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Start an async job to install the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {number} workspaceId The id related to the workspace where the template applications must be installed into.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplateAsync: (templateId_1, workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [templateId_1, workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('installTemplateAsync', 'templateId', templateId);
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('installTemplateAsync', 'workspaceId', workspaceId);
            const localVarPath = `/templates/install/{workspace_id}/{template_id}/async/`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the template categories and the related templates that are in that category. The template\'s `workspace_id` can be used for previewing purposes because that workspace contains the applications that are in the template. All the `get` and `list` endpoints related to that workspace are publicly accessible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TemplatesApi - functional programming interface
 * @export
 */
const TemplatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template](#tag/Templates/operation/workspace_install_template).**  **Support for this endpoint will end in 2024.**   Installs the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {number} groupId The id related to the group where the template applications must be installed into.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplate(groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupInstallTemplate(groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.groupInstallTemplate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template_async](#tag/Templates/operation/workspace_install_template_async).**  **Support for this endpoint will end in 2024.**   Start an async job to install the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {number} groupId The id related to the group where the template applications must be installed into.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplateAsync(groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupInstallTemplateAsync(groupId, templateId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.groupInstallTemplateAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * (Deprecated) Installs the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {number} workspaceId The id related to the workspace where the template applications must be installed into.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplate(templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.installTemplate(templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.installTemplate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Start an async job to install the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {number} templateId The id related to the template that must be installed.
         * @param {number} workspaceId The id related to the workspace where the template applications must be installed into.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplateAsync(templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.installTemplateAsync(templateId, workspaceId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.installTemplateAsync']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the template categories and the related templates that are in that category. The template\'s `workspace_id` can be used for previewing purposes because that workspace contains the applications that are in the template. All the `get` and `list` endpoints related to that workspace are publicly accessible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTemplates(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.listTemplates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * TemplatesApi - factory interface
 * @export
 */
const TemplatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TemplatesApiFp(configuration);
    return {
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template](#tag/Templates/operation/workspace_install_template).**  **Support for this endpoint will end in 2024.**   Installs the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {TemplatesApiGroupInstallTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplate(requestParameters, options) {
            return localVarFp.groupInstallTemplate(requestParameters.groupId, requestParameters.templateId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template_async](#tag/Templates/operation/workspace_install_template_async).**  **Support for this endpoint will end in 2024.**   Start an async job to install the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
         * @param {TemplatesApiGroupInstallTemplateAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupInstallTemplateAsync(requestParameters, options) {
            return localVarFp.groupInstallTemplateAsync(requestParameters.groupId, requestParameters.templateId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * (Deprecated) Installs the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {TemplatesApiInstallTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplate(requestParameters, options) {
            return localVarFp.installTemplate(requestParameters.templateId, requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start an async job to install the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
         * @param {TemplatesApiInstallTemplateAsyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installTemplateAsync(requestParameters, options) {
            return localVarFp.installTemplateAsync(requestParameters.templateId, requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the template categories and the related templates that are in that category. The template\'s `workspace_id` can be used for previewing purposes because that workspace contains the applications that are in the template. All the `get` and `list` endpoints related to that workspace are publicly accessible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(options) {
            return localVarFp.listTemplates(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
class TemplatesApi extends BaseAPI {
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template](#tag/Templates/operation/workspace_install_template).**  **Support for this endpoint will end in 2024.**   Installs the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
     * @param {TemplatesApiGroupInstallTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    groupInstallTemplate(requestParameters, options) {
        return TemplatesApiFp(this.configuration).groupInstallTemplate(requestParameters.groupId, requestParameters.templateId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_install_template_async](#tag/Templates/operation/workspace_install_template_async).**  **Support for this endpoint will end in 2024.**   Start an async job to install the applications of the given template into the given group if the user has access to that group. The response contains those newly created applications.
     * @param {TemplatesApiGroupInstallTemplateAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    groupInstallTemplateAsync(requestParameters, options) {
        return TemplatesApiFp(this.configuration).groupInstallTemplateAsync(requestParameters.groupId, requestParameters.templateId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * (Deprecated) Installs the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
     * @param {TemplatesApiInstallTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    installTemplate(requestParameters, options) {
        return TemplatesApiFp(this.configuration).installTemplate(requestParameters.templateId, requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Start an async job to install the applications of the given template into the given workspace if the user has access to that workspace. The response contains those newly created applications.
     * @param {TemplatesApiInstallTemplateAsyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    installTemplateAsync(requestParameters, options) {
        return TemplatesApiFp(this.configuration).installTemplateAsync(requestParameters.templateId, requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the template categories and the related templates that are in that category. The template\'s `workspace_id` can be used for previewing purposes because that workspace contains the applications that are in the template. All the `get` and `list` endpoints related to that workspace are publicly accessible.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    listTemplates(options) {
        return TemplatesApiFp(this.configuration).listTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TrashApi - axios parameter creator
 * @export
 */
const TrashApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Responds with the workspaces and applications available for the requesting user to inspect the trash contents of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashStructure: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/trash/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_empty_contents](#tag/Trash/operation/workspace_empty_contents).**  **Support for this endpoint will end in 2024.**   Empties the specified group and/or application of trash, including the group and application themselves if they are trashed also.
         * @param {number} groupId The group whose trash contents to empty, including the group itself if it is also trashed.
         * @param {number} [applicationId] Optionally filters down the trash to delete to only items for this application in the group.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupEmptyContents: (groupId_1, applicationId_1, ...args_1) => __awaiter(this, [groupId_1, applicationId_1, ...args_1], void 0, function* (groupId, applicationId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupEmptyContents', 'groupId', groupId);
            const localVarPath = `/trash/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_get_contents](#tag/Trash/operation/workspace_get_contents).**  **Support for this endpoint will end in 2024.**   Responds with trash contents for a group optionally filtered to a specific application.
         * @param {number} groupId Returns the trash for the group with this id.
         * @param {number} [applicationId] Optionally filters down the trash to only items for this application in the group.
         * @param {number} [page] Selects which page of trash contents should be returned.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupGetContents: (groupId_1, applicationId_1, page_1, ...args_1) => __awaiter(this, [groupId_1, applicationId_1, page_1, ...args_1], void 0, function* (groupId, applicationId, page, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupGetContents', 'groupId', groupId);
            const localVarPath = `/trash/group/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restores the specified trashed item back into baserow.
         * @param {PatchedTrashEntryRequest} [patchedTrashEntryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore: (patchedTrashEntryRequest_1, ...args_1) => __awaiter(this, [patchedTrashEntryRequest_1, ...args_1], void 0, function* (patchedTrashEntryRequest, options = {}) {
            const localVarPath = `/trash/restore/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTrashEntryRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Empties the specified workspace and/or application of trash, including the workspace and application themselves if they are trashed also.
         * @param {number} workspaceId The workspace whose trash contents to empty, including the workspace itself if it is also trashed.
         * @param {number} [applicationId] Optionally filters down the trash to delete to only items for this application in the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceEmptyContents: (workspaceId_1, applicationId_1, ...args_1) => __awaiter(this, [workspaceId_1, applicationId_1, ...args_1], void 0, function* (workspaceId, applicationId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceEmptyContents', 'workspaceId', workspaceId);
            const localVarPath = `/trash/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with trash contents for a workspace optionally filtered to a specific application.
         * @param {number} workspaceId Returns the trash for the workspace with this id.
         * @param {number} [applicationId] Optionally filters down the trash to only items for this application in the workspace.
         * @param {number} [page] Selects which page of trash contents should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetContents: (workspaceId_1, applicationId_1, page_1, ...args_1) => __awaiter(this, [workspaceId_1, applicationId_1, page_1, ...args_1], void 0, function* (workspaceId, applicationId, page, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceGetContents', 'workspaceId', workspaceId);
            const localVarPath = `/trash/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TrashApi - functional programming interface
 * @export
 */
const TrashApiFp = function (configuration) {
    const localVarAxiosParamCreator = TrashApiAxiosParamCreator(configuration);
    return {
        /**
         * Responds with the workspaces and applications available for the requesting user to inspect the trash contents of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashStructure(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrashStructure(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.getTrashStructure']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_empty_contents](#tag/Trash/operation/workspace_empty_contents).**  **Support for this endpoint will end in 2024.**   Empties the specified group and/or application of trash, including the group and application themselves if they are trashed also.
         * @param {number} groupId The group whose trash contents to empty, including the group itself if it is also trashed.
         * @param {number} [applicationId] Optionally filters down the trash to delete to only items for this application in the group.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupEmptyContents(groupId, applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupEmptyContents(groupId, applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.groupEmptyContents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_get_contents](#tag/Trash/operation/workspace_get_contents).**  **Support for this endpoint will end in 2024.**   Responds with trash contents for a group optionally filtered to a specific application.
         * @param {number} groupId Returns the trash for the group with this id.
         * @param {number} [applicationId] Optionally filters down the trash to only items for this application in the group.
         * @param {number} [page] Selects which page of trash contents should be returned.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupGetContents(groupId, applicationId, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupGetContents(groupId, applicationId, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.groupGetContents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restores the specified trashed item back into baserow.
         * @param {PatchedTrashEntryRequest} [patchedTrashEntryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(patchedTrashEntryRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.restore(patchedTrashEntryRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.restore']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Empties the specified workspace and/or application of trash, including the workspace and application themselves if they are trashed also.
         * @param {number} workspaceId The workspace whose trash contents to empty, including the workspace itself if it is also trashed.
         * @param {number} [applicationId] Optionally filters down the trash to delete to only items for this application in the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceEmptyContents(workspaceId, applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceEmptyContents(workspaceId, applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.workspaceEmptyContents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with trash contents for a workspace optionally filtered to a specific application.
         * @param {number} workspaceId Returns the trash for the workspace with this id.
         * @param {number} [applicationId] Optionally filters down the trash to only items for this application in the workspace.
         * @param {number} [page] Selects which page of trash contents should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetContents(workspaceId, applicationId, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspaceGetContents(workspaceId, applicationId, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TrashApi.workspaceGetContents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * TrashApi - factory interface
 * @export
 */
const TrashApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TrashApiFp(configuration);
    return {
        /**
         * Responds with the workspaces and applications available for the requesting user to inspect the trash contents of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashStructure(options) {
            return localVarFp.getTrashStructure(options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_empty_contents](#tag/Trash/operation/workspace_empty_contents).**  **Support for this endpoint will end in 2024.**   Empties the specified group and/or application of trash, including the group and application themselves if they are trashed also.
         * @param {TrashApiGroupEmptyContentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupEmptyContents(requestParameters, options) {
            return localVarFp.groupEmptyContents(requestParameters.groupId, requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_get_contents](#tag/Trash/operation/workspace_get_contents).**  **Support for this endpoint will end in 2024.**   Responds with trash contents for a group optionally filtered to a specific application.
         * @param {TrashApiGroupGetContentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        groupGetContents(requestParameters, options) {
            return localVarFp.groupGetContents(requestParameters.groupId, requestParameters.applicationId, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the specified trashed item back into baserow.
         * @param {TrashApiRestoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(requestParameters = {}, options) {
            return localVarFp.restore(requestParameters.patchedTrashEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Empties the specified workspace and/or application of trash, including the workspace and application themselves if they are trashed also.
         * @param {TrashApiWorkspaceEmptyContentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceEmptyContents(requestParameters, options) {
            return localVarFp.workspaceEmptyContents(requestParameters.workspaceId, requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with trash contents for a workspace optionally filtered to a specific application.
         * @param {TrashApiWorkspaceGetContentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGetContents(requestParameters, options) {
            return localVarFp.workspaceGetContents(requestParameters.workspaceId, requestParameters.applicationId, requestParameters.page, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TrashApi - object-oriented interface
 * @export
 * @class TrashApi
 * @extends {BaseAPI}
 */
class TrashApi extends BaseAPI {
    /**
     * Responds with the workspaces and applications available for the requesting user to inspect the trash contents of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    getTrashStructure(options) {
        return TrashApiFp(this.configuration).getTrashStructure(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_empty_contents](#tag/Trash/operation/workspace_empty_contents).**  **Support for this endpoint will end in 2024.**   Empties the specified group and/or application of trash, including the group and application themselves if they are trashed also.
     * @param {TrashApiGroupEmptyContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    groupEmptyContents(requestParameters, options) {
        return TrashApiFp(this.configuration).groupEmptyContents(requestParameters.groupId, requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **This endpoint has been deprecated and replaced with a new endpoint, [workspace_get_contents](#tag/Trash/operation/workspace_get_contents).**  **Support for this endpoint will end in 2024.**   Responds with trash contents for a group optionally filtered to a specific application.
     * @param {TrashApiGroupGetContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    groupGetContents(requestParameters, options) {
        return TrashApiFp(this.configuration).groupGetContents(requestParameters.groupId, requestParameters.applicationId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restores the specified trashed item back into baserow.
     * @param {TrashApiRestoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    restore(requestParameters = {}, options) {
        return TrashApiFp(this.configuration).restore(requestParameters.patchedTrashEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Empties the specified workspace and/or application of trash, including the workspace and application themselves if they are trashed also.
     * @param {TrashApiWorkspaceEmptyContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    workspaceEmptyContents(requestParameters, options) {
        return TrashApiFp(this.configuration).workspaceEmptyContents(requestParameters.workspaceId, requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with trash contents for a workspace optionally filtered to a specific application.
     * @param {TrashApiWorkspaceGetContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrashApi
     */
    workspaceGetContents(requestParameters, options) {
        return TrashApiFp(this.configuration).workspaceGetContents(requestParameters.workspaceId, requestParameters.applicationId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Changes the password of an authenticated user, but only if the old password matches.
         * @param {ChangePasswordBodyValidation} changePasswordBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: (changePasswordBodyValidation_1, ...args_1) => __awaiter(this, [changePasswordBodyValidation_1, ...args_1], void 0, function* (changePasswordBodyValidation, options = {}) {
            // verify required parameter 'changePasswordBodyValidation' is not null or undefined
            assertParamExists('changePassword', 'changePasswordBodyValidation', changePasswordBodyValidation);
            const localVarPath = `/user/change-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordBodyValidation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new user based on the provided values. If desired an authentication JWT can be generated right away. After creating an account the initial workspace containing a database is created.
         * @param {Register} register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (register_1, ...args_1) => __awaiter(this, [register_1, ...args_1], void 0, function* (register, options = {}) {
            // verify required parameter 'register' is not null or undefined
            assertParamExists('createUser', 'register', register);
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(register, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the relevant user information that for example could be shown on a dashboard. It will contain all the pending workspace invitations for that user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboard: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user/dashboard/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Redoes the latest redoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be redone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {string} clientSessionId The particular client session to redo actions for. The actions must have been performed with this same header set with the same value for them to be redoable by this endpoint.
         * @param {PatchedUndoRedoRequest} [patchedUndoRedoRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redo: (clientSessionId_1, patchedUndoRedoRequest_1, ...args_1) => __awaiter(this, [clientSessionId_1, patchedUndoRedoRequest_1, ...args_1], void 0, function* (clientSessionId, patchedUndoRedoRequest, options = {}) {
            // verify required parameter 'clientSessionId' is not null or undefined
            assertParamExists('redo', 'clientSessionId', clientSessionId);
            const localVarPath = `/user/redo/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUndoRedoRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes the password of a user if the reset token is valid. The **send_password_reset_email** endpoint sends an email to the user containing the token. That token can be used to change the password here without providing the old password.
         * @param {ResetPasswordBodyValidation} resetPasswordBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: (resetPasswordBodyValidation_1, ...args_1) => __awaiter(this, [resetPasswordBodyValidation_1, ...args_1], void 0, function* (resetPasswordBodyValidation, options = {}) {
            // verify required parameter 'resetPasswordBodyValidation' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordBodyValidation', resetPasswordBodyValidation);
            const localVarPath = `/user/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordBodyValidation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Schedules the account deletion of the authenticated user. The user will be permanently deleted after the grace delay defined by the instance administrator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleAccountDeletion: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user/schedule-account-deletion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends an email containing the password reset link to the email address of the user. This will only be done if a user is found with the given email address. The endpoint will not fail if the email address is not found. The link is going to the valid for 48 hours.
         * @param {SendResetPasswordEmailBodyValidation} sendResetPasswordEmailBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPasswordResetEmail: (sendResetPasswordEmailBodyValidation_1, ...args_1) => __awaiter(this, [sendResetPasswordEmailBodyValidation_1, ...args_1], void 0, function* (sendResetPasswordEmailBodyValidation, options = {}) {
            // verify required parameter 'sendResetPasswordEmailBodyValidation' is not null or undefined
            assertParamExists('sendPasswordResetEmail', 'sendResetPasswordEmailBodyValidation', sendResetPasswordEmailBodyValidation);
            const localVarPath = `/user/send-reset-password-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(sendResetPasswordEmailBodyValidation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends an email to the user with an email verification link if the user\'s email is not verified yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerifyEmail: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user/send-verify-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Authenticates an existing user based on their email and their password. If successful, an access token and a refresh token will be returned.
         * @param {TokenObtainPairWithUser} tokenObtainPairWithUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAuth: (tokenObtainPairWithUser_1, ...args_1) => __awaiter(this, [tokenObtainPairWithUser_1, ...args_1], void 0, function* (tokenObtainPairWithUser, options = {}) {
            // verify required parameter 'tokenObtainPairWithUser' is not null or undefined
            assertParamExists('tokenAuth', 'tokenObtainPairWithUser', tokenObtainPairWithUser);
            const localVarPath = `/user/token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPairWithUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Blacklists the provided token. This can be used the sign the user off.
         * @param {TokenBlacklist} tokenBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenBlacklist: (tokenBlacklist_1, ...args_1) => __awaiter(this, [tokenBlacklist_1, ...args_1], void 0, function* (tokenBlacklist, options = {}) {
            // verify required parameter 'tokenBlacklist' is not null or undefined
            assertParamExists('tokenBlacklist', 'tokenBlacklist', tokenBlacklist);
            const localVarPath = `/user/token-blacklist/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenBlacklist, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate a new access_token that can be used to continue operating on Baserow starting from a valid refresh token.
         * @param {TokenRefreshWithUser} [tokenRefreshWithUser]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefresh: (tokenRefreshWithUser_1, ...args_1) => __awaiter(this, [tokenRefreshWithUser_1, ...args_1], void 0, function* (tokenRefreshWithUser, options = {}) {
            const localVarPath = `/user/token-refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshWithUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Verifies if the refresh token is valid and can be used to generate a new access_token.
         * @param {TokenVerifyWithUser} tokenVerifyWithUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerify: (tokenVerifyWithUser_1, ...args_1) => __awaiter(this, [tokenVerifyWithUser_1, ...args_1], void 0, function* (tokenVerifyWithUser, options = {}) {
            // verify required parameter 'tokenVerifyWithUser' is not null or undefined
            assertParamExists('tokenVerify', 'tokenVerifyWithUser', tokenVerifyWithUser);
            const localVarPath = `/user/token-verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyWithUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * undoes the latest undoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be undone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {string} clientSessionId The particular client session to undo actions for. The actions must have been performed with this same header set with the same value for them to be undoable by this endpoint.
         * @param {PatchedUndoRedoRequest} [patchedUndoRedoRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undo: (clientSessionId_1, patchedUndoRedoRequest_1, ...args_1) => __awaiter(this, [clientSessionId_1, patchedUndoRedoRequest_1, ...args_1], void 0, function* (clientSessionId, patchedUndoRedoRequest, options = {}) {
            // verify required parameter 'clientSessionId' is not null or undefined
            assertParamExists('undo', 'clientSessionId', clientSessionId);
            const localVarPath = `/user/undo/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUndoRedoRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the account information of the authenticated user.
         * @param {PatchedAccount} [patchedAccount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: (patchedAccount_1, ...args_1) => __awaiter(this, [patchedAccount_1, ...args_1], void 0, function* (patchedAccount, options = {}) {
            const localVarPath = `/user/account/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccount, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Passing the correct verification token will confirm that the user\'s email address belongs to the user. This endpoint also optionally returns user information, access token and the refresh token for automatically signing user in the system if the request is performed by unauthenticated user.
         * @param {VerifyEmailAddress} verifyEmailAddress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: (verifyEmailAddress_1, ...args_1) => __awaiter(this, [verifyEmailAddress_1, ...args_1], void 0, function* (verifyEmailAddress, options = {}) {
            // verify required parameter 'verifyEmailAddress' is not null or undefined
            assertParamExists('verifyEmail', 'verifyEmailAddress', verifyEmailAddress);
            const localVarPath = `/user/verify-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailAddress, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Changes the password of an authenticated user, but only if the old password matches.
         * @param {ChangePasswordBodyValidation} changePasswordBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordBodyValidation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changePassword(changePasswordBodyValidation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.changePassword']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new user based on the provided values. If desired an authentication JWT can be generated right away. After creating an account the initial workspace containing a database is created.
         * @param {Register} register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(register, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(register, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.createUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the relevant user information that for example could be shown on a dashboard. It will contain all the pending workspace invitations for that user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboard(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.dashboard(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.dashboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Redoes the latest redoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be redone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {string} clientSessionId The particular client session to redo actions for. The actions must have been performed with this same header set with the same value for them to be redoable by this endpoint.
         * @param {PatchedUndoRedoRequest} [patchedUndoRedoRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redo(clientSessionId, patchedUndoRedoRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.redo(clientSessionId, patchedUndoRedoRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.redo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Changes the password of a user if the reset token is valid. The **send_password_reset_email** endpoint sends an email to the user containing the token. That token can be used to change the password here without providing the old password.
         * @param {ResetPasswordBodyValidation} resetPasswordBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordBodyValidation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetPassword(resetPasswordBodyValidation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.resetPassword']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Schedules the account deletion of the authenticated user. The user will be permanently deleted after the grace delay defined by the instance administrator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleAccountDeletion(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.scheduleAccountDeletion(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.scheduleAccountDeletion']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Sends an email containing the password reset link to the email address of the user. This will only be done if a user is found with the given email address. The endpoint will not fail if the email address is not found. The link is going to the valid for 48 hours.
         * @param {SendResetPasswordEmailBodyValidation} sendResetPasswordEmailBodyValidation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPasswordResetEmail(sendResetPasswordEmailBodyValidation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendPasswordResetEmail(sendResetPasswordEmailBodyValidation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.sendPasswordResetEmail']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Sends an email to the user with an email verification link if the user\'s email is not verified yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerifyEmail(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendVerifyEmail(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.sendVerifyEmail']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Authenticates an existing user based on their email and their password. If successful, an access token and a refresh token will be returned.
         * @param {TokenObtainPairWithUser} tokenObtainPairWithUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAuth(tokenObtainPairWithUser, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenAuth(tokenObtainPairWithUser, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.tokenAuth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Blacklists the provided token. This can be used the sign the user off.
         * @param {TokenBlacklist} tokenBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenBlacklist(tokenBlacklist, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenBlacklist(tokenBlacklist, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.tokenBlacklist']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generate a new access_token that can be used to continue operating on Baserow starting from a valid refresh token.
         * @param {TokenRefreshWithUser} [tokenRefreshWithUser]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefresh(tokenRefreshWithUser, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenRefresh(tokenRefreshWithUser, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.tokenRefresh']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Verifies if the refresh token is valid and can be used to generate a new access_token.
         * @param {TokenVerifyWithUser} tokenVerifyWithUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerify(tokenVerifyWithUser, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokenVerify(tokenVerifyWithUser, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.tokenVerify']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * undoes the latest undoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be undone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {string} clientSessionId The particular client session to undo actions for. The actions must have been performed with this same header set with the same value for them to be undoable by this endpoint.
         * @param {PatchedUndoRedoRequest} [patchedUndoRedoRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undo(clientSessionId, patchedUndoRedoRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.undo(clientSessionId, patchedUndoRedoRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.undo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the account information of the authenticated user.
         * @param {PatchedAccount} [patchedAccount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(patchedAccount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAccount(patchedAccount, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.updateAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Passing the correct verification token will confirm that the user\'s email address belongs to the user. This endpoint also optionally returns user information, access token and the refresh token for automatically signing user in the system if the request is performed by unauthenticated user.
         * @param {VerifyEmailAddress} verifyEmailAddress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(verifyEmailAddress, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.verifyEmail(verifyEmailAddress, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.verifyEmail']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         * Changes the password of an authenticated user, but only if the old password matches.
         * @param {UserApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters, options) {
            return localVarFp.changePassword(requestParameters.changePasswordBodyValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user based on the provided values. If desired an authentication JWT can be generated right away. After creating an account the initial workspace containing a database is created.
         * @param {UserApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters, options) {
            return localVarFp.createUser(requestParameters.register, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the relevant user information that for example could be shown on a dashboard. It will contain all the pending workspace invitations for that user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboard(options) {
            return localVarFp.dashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * Redoes the latest redoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be redone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {UserApiRedoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redo(requestParameters, options) {
            return localVarFp.redo(requestParameters.clientSessionId, requestParameters.patchedUndoRedoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the password of a user if the reset token is valid. The **send_password_reset_email** endpoint sends an email to the user containing the token. That token can be used to change the password here without providing the old password.
         * @param {UserApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters, options) {
            return localVarFp.resetPassword(requestParameters.resetPasswordBodyValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedules the account deletion of the authenticated user. The user will be permanently deleted after the grace delay defined by the instance administrator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleAccountDeletion(options) {
            return localVarFp.scheduleAccountDeletion(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email containing the password reset link to the email address of the user. This will only be done if a user is found with the given email address. The endpoint will not fail if the email address is not found. The link is going to the valid for 48 hours.
         * @param {UserApiSendPasswordResetEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPasswordResetEmail(requestParameters, options) {
            return localVarFp.sendPasswordResetEmail(requestParameters.sendResetPasswordEmailBodyValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to the user with an email verification link if the user\'s email is not verified yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerifyEmail(options) {
            return localVarFp.sendVerifyEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates an existing user based on their email and their password. If successful, an access token and a refresh token will be returned.
         * @param {UserApiTokenAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenAuth(requestParameters, options) {
            return localVarFp.tokenAuth(requestParameters.tokenObtainPairWithUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Blacklists the provided token. This can be used the sign the user off.
         * @param {UserApiTokenBlacklistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenBlacklist(requestParameters, options) {
            return localVarFp.tokenBlacklist(requestParameters.tokenBlacklist, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a new access_token that can be used to continue operating on Baserow starting from a valid refresh token.
         * @param {UserApiTokenRefreshRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefresh(requestParameters = {}, options) {
            return localVarFp.tokenRefresh(requestParameters.tokenRefreshWithUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies if the refresh token is valid and can be used to generate a new access_token.
         * @param {UserApiTokenVerifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenVerify(requestParameters, options) {
            return localVarFp.tokenVerify(requestParameters.tokenVerifyWithUser, options).then((request) => request(axios, basePath));
        },
        /**
         * undoes the latest undoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be undone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
         * @param {UserApiUndoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undo(requestParameters, options) {
            return localVarFp.undo(requestParameters.clientSessionId, requestParameters.patchedUndoRedoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the account information of the authenticated user.
         * @param {UserApiUpdateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(requestParameters = {}, options) {
            return localVarFp.updateAccount(requestParameters.patchedAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Passing the correct verification token will confirm that the user\'s email address belongs to the user. This endpoint also optionally returns user information, access token and the refresh token for automatically signing user in the system if the request is performed by unauthenticated user.
         * @param {UserApiVerifyEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(requestParameters, options) {
            return localVarFp.verifyEmail(requestParameters.verifyEmailAddress, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * Changes the password of an authenticated user, but only if the old password matches.
     * @param {UserApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePassword(requestParameters, options) {
        return UserApiFp(this.configuration).changePassword(requestParameters.changePasswordBodyValidation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new user based on the provided values. If desired an authentication JWT can be generated right away. After creating an account the initial workspace containing a database is created.
     * @param {UserApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(requestParameters, options) {
        return UserApiFp(this.configuration).createUser(requestParameters.register, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the relevant user information that for example could be shown on a dashboard. It will contain all the pending workspace invitations for that user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    dashboard(options) {
        return UserApiFp(this.configuration).dashboard(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Redoes the latest redoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be redone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
     * @param {UserApiRedoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    redo(requestParameters, options) {
        return UserApiFp(this.configuration).redo(requestParameters.clientSessionId, requestParameters.patchedUndoRedoRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the password of a user if the reset token is valid. The **send_password_reset_email** endpoint sends an email to the user containing the token. That token can be used to change the password here without providing the old password.
     * @param {UserApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetPassword(requestParameters, options) {
        return UserApiFp(this.configuration).resetPassword(requestParameters.resetPasswordBodyValidation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Schedules the account deletion of the authenticated user. The user will be permanently deleted after the grace delay defined by the instance administrator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    scheduleAccountDeletion(options) {
        return UserApiFp(this.configuration).scheduleAccountDeletion(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an email containing the password reset link to the email address of the user. This will only be done if a user is found with the given email address. The endpoint will not fail if the email address is not found. The link is going to the valid for 48 hours.
     * @param {UserApiSendPasswordResetEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    sendPasswordResetEmail(requestParameters, options) {
        return UserApiFp(this.configuration).sendPasswordResetEmail(requestParameters.sendResetPasswordEmailBodyValidation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an email to the user with an email verification link if the user\'s email is not verified yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    sendVerifyEmail(options) {
        return UserApiFp(this.configuration).sendVerifyEmail(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Authenticates an existing user based on their email and their password. If successful, an access token and a refresh token will be returned.
     * @param {UserApiTokenAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokenAuth(requestParameters, options) {
        return UserApiFp(this.configuration).tokenAuth(requestParameters.tokenObtainPairWithUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Blacklists the provided token. This can be used the sign the user off.
     * @param {UserApiTokenBlacklistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokenBlacklist(requestParameters, options) {
        return UserApiFp(this.configuration).tokenBlacklist(requestParameters.tokenBlacklist, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate a new access_token that can be used to continue operating on Baserow starting from a valid refresh token.
     * @param {UserApiTokenRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokenRefresh(requestParameters = {}, options) {
        return UserApiFp(this.configuration).tokenRefresh(requestParameters.tokenRefreshWithUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies if the refresh token is valid and can be used to generate a new access_token.
     * @param {UserApiTokenVerifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokenVerify(requestParameters, options) {
        return UserApiFp(this.configuration).tokenVerify(requestParameters.tokenVerifyWithUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * undoes the latest undoable action performed by the user making the request. a ClientSessionId header must be provided and only actions which were performed the same user with the same ClientSessionId value set on the api request that performed the action will be undone.Additionally the ClientSessionId header must be between 1 and 256 characters long and must only contain alphanumeric or the - characters.
     * @param {UserApiUndoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    undo(requestParameters, options) {
        return UserApiFp(this.configuration).undo(requestParameters.clientSessionId, requestParameters.patchedUndoRedoRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the account information of the authenticated user.
     * @param {UserApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAccount(requestParameters = {}, options) {
        return UserApiFp(this.configuration).updateAccount(requestParameters.patchedAccount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Passing the correct verification token will confirm that the user\'s email address belongs to the user. This endpoint also optionally returns user information, access token and the refresh token for automatically signing user in the system if the request is performed by unauthenticated user.
     * @param {UserApiVerifyEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    verifyEmail(requestParameters, options) {
        return UserApiFp(this.configuration).verifyEmail(requestParameters.verifyEmailAddress, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserFilesApi - axios parameter creator
 * @export
 */
const UserFilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Uploads a file to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user-files/upload-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads a file to Baserow by downloading it from the provided URL.
         * @param {UserFileUploadViaURLRequest} userFileUploadViaURLRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadViaUrl: (userFileUploadViaURLRequest_1, ...args_1) => __awaiter(this, [userFileUploadViaURLRequest_1, ...args_1], void 0, function* (userFileUploadViaURLRequest, options = {}) {
            // verify required parameter 'userFileUploadViaURLRequest' is not null or undefined
            assertParamExists('uploadViaUrl', 'userFileUploadViaURLRequest', userFileUploadViaURLRequest);
            const localVarPath = `/user-files/upload-via-url/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            // authentication Database token required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userFileUploadViaURLRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserFilesApi - functional programming interface
 * @export
 */
const UserFilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserFilesApiAxiosParamCreator(configuration);
    return {
        /**
         * Uploads a file to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadFile(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserFilesApi.uploadFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads a file to Baserow by downloading it from the provided URL.
         * @param {UserFileUploadViaURLRequest} userFileUploadViaURLRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadViaUrl(userFileUploadViaURLRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadViaUrl(userFileUploadViaURLRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserFilesApi.uploadViaUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UserFilesApi - factory interface
 * @export
 */
const UserFilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserFilesApiFp(configuration);
    return {
        /**
         * Uploads a file to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(options) {
            return localVarFp.uploadFile(options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file to Baserow by downloading it from the provided URL.
         * @param {UserFilesApiUploadViaUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadViaUrl(requestParameters, options) {
            return localVarFp.uploadViaUrl(requestParameters.userFileUploadViaURLRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserFilesApi - object-oriented interface
 * @export
 * @class UserFilesApi
 * @extends {BaseAPI}
 */
class UserFilesApi extends BaseAPI {
    /**
     * Uploads a file to Baserow by uploading the file contents directly. A `file` multipart is expected containing the file contents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilesApi
     */
    uploadFile(options) {
        return UserFilesApiFp(this.configuration).uploadFile(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads a file to Baserow by downloading it from the provided URL.
     * @param {UserFilesApiUploadViaUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilesApi
     */
    uploadViaUrl(requestParameters, options) {
        return UserFilesApiFp(this.configuration).uploadViaUrl(requestParameters.userFileUploadViaURLRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserSourceRolesApi - axios parameter creator
 * @export
 */
const UserSourceRolesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Lists all the roles of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the roles of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceRoles: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationUserSourceRoles', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/user-sources/roles/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserSourceRolesApi - functional programming interface
 * @export
 */
const UserSourceRolesApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserSourceRolesApiAxiosParamCreator(configuration);
    return {
        /**
         * Lists all the roles of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the roles of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceRoles(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationUserSourceRoles(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourceRolesApi.listApplicationUserSourceRoles']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UserSourceRolesApi - factory interface
 * @export
 */
const UserSourceRolesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserSourceRolesApiFp(configuration);
    return {
        /**
         * Lists all the roles of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {UserSourceRolesApiListApplicationUserSourceRolesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceRoles(requestParameters, options) {
            return localVarFp.listApplicationUserSourceRoles(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserSourceRolesApi - object-oriented interface
 * @export
 * @class UserSourceRolesApi
 * @extends {BaseAPI}
 */
class UserSourceRolesApi extends BaseAPI {
    /**
     * Lists all the roles of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {UserSourceRolesApiListApplicationUserSourceRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourceRolesApi
     */
    listApplicationUserSourceRoles(requestParameters, options) {
        return UserSourceRolesApiFp(this.configuration).listApplicationUserSourceRoles(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserSourcesApi - axios parameter creator
 * @export
 */
const UserSourcesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new user_source
         * @param {number} applicationId Creates an user_source for the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {UserSourceCreateUserSource} [userSourceCreateUserSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserSource: (applicationId_1, clientSessionId_1, userSourceCreateUserSource_1, ...args_1) => __awaiter(this, [applicationId_1, clientSessionId_1, userSourceCreateUserSource_1, ...args_1], void 0, function* (applicationId, clientSessionId, userSourceCreateUserSource, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationUserSource', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/user-sources/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userSourceCreateUserSource, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the user_source related by the given id.
         * @param {number} userSourceId The id of the user_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserSource: (userSourceId_1, clientSessionId_1, ...args_1) => __awaiter(this, [userSourceId_1, clientSessionId_1, ...args_1], void 0, function* (userSourceId, clientSessionId, options = {}) {
            // verify required parameter 'userSourceId' is not null or undefined
            assertParamExists('deleteApplicationUserSource', 'userSourceId', userSourceId);
            const localVarPath = `/user-source/{user_source_id}/`
                .replace(`{${"user_source_id"}}`, encodeURIComponent(String(userSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List per user sources the first 5 users available.
         * @param {number} applicationId The application we want the users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceUsers: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationUserSourceUsers', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/list-user-source-users/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the user_sources of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the user_sources of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSources: (applicationId_1, ...args_1) => __awaiter(this, [applicationId_1, ...args_1], void 0, function* (applicationId, options = {}) {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationUserSources', 'applicationId', applicationId);
            const localVarPath = `/application/{application_id}/user-sources/`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Moves the user_source in the application before another user_source or at the end of the application if no before user_source is given. The user_sources must belong to the same application.
         * @param {number} userSourceId The id of the user_source to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveUserSource} [patchedMoveUserSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationUserSource: (userSourceId_1, clientSessionId_1, patchedMoveUserSource_1, ...args_1) => __awaiter(this, [userSourceId_1, clientSessionId_1, patchedMoveUserSource_1, ...args_1], void 0, function* (userSourceId, clientSessionId, patchedMoveUserSource, options = {}) {
            // verify required parameter 'userSourceId' is not null or undefined
            assertParamExists('moveApplicationUserSource', 'userSourceId', userSourceId);
            const localVarPath = `/user-source/{user_source_id}/move/`
                .replace(`{${"user_source_id"}}`, encodeURIComponent(String(userSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMoveUserSource, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing user_source.
         * @param {number} userSourceId The id of the user_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {LocalBaserowUserSourceUpdateUserSource} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUserSource: (userSourceId_1, clientSessionId_1, body_1, ...args_1) => __awaiter(this, [userSourceId_1, clientSessionId_1, body_1, ...args_1], void 0, function* (userSourceId, clientSessionId, body, options = {}) {
            // verify required parameter 'userSourceId' is not null or undefined
            assertParamExists('updateApplicationUserSource', 'userSourceId', userSourceId);
            const localVarPath = `/user-source/{user_source_id}/`
                .replace(`{${"user_source_id"}}`, encodeURIComponent(String(userSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Force authenticates an existing user based on their ID. If successful, an access token and a refresh token will be returned.
         * @param {number} userSourceId The user source to use to authenticate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceForceTokenAuth: (userSourceId_1, ...args_1) => __awaiter(this, [userSourceId_1, ...args_1], void 0, function* (userSourceId, options = {}) {
            // verify required parameter 'userSourceId' is not null or undefined
            assertParamExists('userSourceForceTokenAuth', 'userSourceId', userSourceId);
            const localVarPath = `/user-source/{user_source_id}/force-token-auth`
                .replace(`{${"user_source_id"}}`, encodeURIComponent(String(userSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Authenticates an existing user against a user source based on their credentials. If successful, an access token and a refresh token will be returned.
         * @param {number} userSourceId The id of the user_source to move
         * @param {TokenObtainPair} tokenObtainPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenAuth: (userSourceId_1, tokenObtainPair_1, ...args_1) => __awaiter(this, [userSourceId_1, tokenObtainPair_1, ...args_1], void 0, function* (userSourceId, tokenObtainPair, options = {}) {
            // verify required parameter 'userSourceId' is not null or undefined
            assertParamExists('userSourceTokenAuth', 'userSourceId', userSourceId);
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('userSourceTokenAuth', 'tokenObtainPair', tokenObtainPair);
            const localVarPath = `/user-source/{user_source_id}/token-auth`
                .replace(`{${"user_source_id"}}`, encodeURIComponent(String(userSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Blacklists the provided user source token. This can be used the sign the user off.
         * @param {TokenBlacklist} tokenBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenBlacklist: (tokenBlacklist_1, ...args_1) => __awaiter(this, [tokenBlacklist_1, ...args_1], void 0, function* (tokenBlacklist, options = {}) {
            // verify required parameter 'tokenBlacklist' is not null or undefined
            assertParamExists('userSourceTokenBlacklist', 'tokenBlacklist', tokenBlacklist);
            const localVarPath = `/user-source-token-blacklist/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(tokenBlacklist, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate a new access_token that can be used to continue operating on Baserow with a user source user starting from a valid refresh token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenRefresh: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user-source-auth-refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserSourcesApi - functional programming interface
 * @export
 */
const UserSourcesApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserSourcesApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new user_source
         * @param {number} applicationId Creates an user_source for the application related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {UserSourceCreateUserSource} [userSourceCreateUserSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserSource(applicationId, clientSessionId, userSourceCreateUserSource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApplicationUserSource(applicationId, clientSessionId, userSourceCreateUserSource, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.createApplicationUserSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the user_source related by the given id.
         * @param {number} userSourceId The id of the user_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserSource(userSourceId, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplicationUserSource(userSourceId, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.deleteApplicationUserSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List per user sources the first 5 users available.
         * @param {number} applicationId The application we want the users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceUsers(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationUserSourceUsers(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.listApplicationUserSourceUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the user_sources of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {number} applicationId Returns only the user_sources of the application related to the provided Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSources(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationUserSources(applicationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.listApplicationUserSources']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Moves the user_source in the application before another user_source or at the end of the application if no before user_source is given. The user_sources must belong to the same application.
         * @param {number} userSourceId The id of the user_source to move
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedMoveUserSource} [patchedMoveUserSource]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationUserSource(userSourceId, clientSessionId, patchedMoveUserSource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.moveApplicationUserSource(userSourceId, clientSessionId, patchedMoveUserSource, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.moveApplicationUserSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing user_source.
         * @param {number} userSourceId The id of the user_source
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {LocalBaserowUserSourceUpdateUserSource} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUserSource(userSourceId, clientSessionId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplicationUserSource(userSourceId, clientSessionId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.updateApplicationUserSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Force authenticates an existing user based on their ID. If successful, an access token and a refresh token will be returned.
         * @param {number} userSourceId The user source to use to authenticate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceForceTokenAuth(userSourceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSourceForceTokenAuth(userSourceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.userSourceForceTokenAuth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Authenticates an existing user against a user source based on their credentials. If successful, an access token and a refresh token will be returned.
         * @param {number} userSourceId The id of the user_source to move
         * @param {TokenObtainPair} tokenObtainPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenAuth(userSourceId, tokenObtainPair, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSourceTokenAuth(userSourceId, tokenObtainPair, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.userSourceTokenAuth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Blacklists the provided user source token. This can be used the sign the user off.
         * @param {TokenBlacklist} tokenBlacklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenBlacklist(tokenBlacklist, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSourceTokenBlacklist(tokenBlacklist, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.userSourceTokenBlacklist']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generate a new access_token that can be used to continue operating on Baserow with a user source user starting from a valid refresh token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenRefresh(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSourceTokenRefresh(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserSourcesApi.userSourceTokenRefresh']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UserSourcesApi - factory interface
 * @export
 */
const UserSourcesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserSourcesApiFp(configuration);
    return {
        /**
         * Creates a new user_source
         * @param {UserSourcesApiCreateApplicationUserSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserSource(requestParameters, options) {
            return localVarFp.createApplicationUserSource(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.userSourceCreateUserSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user_source related by the given id.
         * @param {UserSourcesApiDeleteApplicationUserSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserSource(requestParameters, options) {
            return localVarFp.deleteApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List per user sources the first 5 users available.
         * @param {UserSourcesApiListApplicationUserSourceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSourceUsers(requestParameters, options) {
            return localVarFp.listApplicationUserSourceUsers(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the user_sources of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
         * @param {UserSourcesApiListApplicationUserSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserSources(requestParameters, options) {
            return localVarFp.listApplicationUserSources(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves the user_source in the application before another user_source or at the end of the application if no before user_source is given. The user_sources must belong to the same application.
         * @param {UserSourcesApiMoveApplicationUserSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveApplicationUserSource(requestParameters, options) {
            return localVarFp.moveApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, requestParameters.patchedMoveUserSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing user_source.
         * @param {UserSourcesApiUpdateApplicationUserSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUserSource(requestParameters, options) {
            return localVarFp.updateApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Force authenticates an existing user based on their ID. If successful, an access token and a refresh token will be returned.
         * @param {UserSourcesApiUserSourceForceTokenAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceForceTokenAuth(requestParameters, options) {
            return localVarFp.userSourceForceTokenAuth(requestParameters.userSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates an existing user against a user source based on their credentials. If successful, an access token and a refresh token will be returned.
         * @param {UserSourcesApiUserSourceTokenAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenAuth(requestParameters, options) {
            return localVarFp.userSourceTokenAuth(requestParameters.userSourceId, requestParameters.tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Blacklists the provided user source token. This can be used the sign the user off.
         * @param {UserSourcesApiUserSourceTokenBlacklistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenBlacklist(requestParameters, options) {
            return localVarFp.userSourceTokenBlacklist(requestParameters.tokenBlacklist, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a new access_token that can be used to continue operating on Baserow with a user source user starting from a valid refresh token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSourceTokenRefresh(options) {
            return localVarFp.userSourceTokenRefresh(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserSourcesApi - object-oriented interface
 * @export
 * @class UserSourcesApi
 * @extends {BaseAPI}
 */
class UserSourcesApi extends BaseAPI {
    /**
     * Creates a new user_source
     * @param {UserSourcesApiCreateApplicationUserSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    createApplicationUserSource(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).createApplicationUserSource(requestParameters.applicationId, requestParameters.clientSessionId, requestParameters.userSourceCreateUserSource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the user_source related by the given id.
     * @param {UserSourcesApiDeleteApplicationUserSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    deleteApplicationUserSource(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).deleteApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List per user sources the first 5 users available.
     * @param {UserSourcesApiListApplicationUserSourceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    listApplicationUserSourceUsers(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).listApplicationUserSourceUsers(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the user_sources of the application related to the provided parameter if the user has access to the related application\'s workspace. If the workspace is related to a template, then this endpoint will be publicly accessible.
     * @param {UserSourcesApiListApplicationUserSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    listApplicationUserSources(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).listApplicationUserSources(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Moves the user_source in the application before another user_source or at the end of the application if no before user_source is given. The user_sources must belong to the same application.
     * @param {UserSourcesApiMoveApplicationUserSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    moveApplicationUserSource(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).moveApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, requestParameters.patchedMoveUserSource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing user_source.
     * @param {UserSourcesApiUpdateApplicationUserSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    updateApplicationUserSource(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).updateApplicationUserSource(requestParameters.userSourceId, requestParameters.clientSessionId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Force authenticates an existing user based on their ID. If successful, an access token and a refresh token will be returned.
     * @param {UserSourcesApiUserSourceForceTokenAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    userSourceForceTokenAuth(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).userSourceForceTokenAuth(requestParameters.userSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Authenticates an existing user against a user source based on their credentials. If successful, an access token and a refresh token will be returned.
     * @param {UserSourcesApiUserSourceTokenAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    userSourceTokenAuth(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).userSourceTokenAuth(requestParameters.userSourceId, requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Blacklists the provided user source token. This can be used the sign the user off.
     * @param {UserSourcesApiUserSourceTokenBlacklistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    userSourceTokenBlacklist(requestParameters, options) {
        return UserSourcesApiFp(this.configuration).userSourceTokenBlacklist(requestParameters.tokenBlacklist, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate a new access_token that can be used to continue operating on Baserow with a user source user starting from a valid refresh token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSourcesApi
     */
    userSourceTokenRefresh(options) {
        return UserSourcesApiFp(this.configuration).userSourceTokenRefresh(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspaceInvitationsApi - axios parameter creator
 * @export
 */
const WorkspaceInvitationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accepts a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} workspaceInvitationId Accepts the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptWorkspaceInvitation: (workspaceInvitationId_1, ...args_1) => __awaiter(this, [workspaceInvitationId_1, ...args_1], void 0, function* (workspaceInvitationId, options = {}) {
            // verify required parameter 'workspaceInvitationId' is not null or undefined
            assertParamExists('acceptWorkspaceInvitation', 'workspaceInvitationId', workspaceInvitationId);
            const localVarPath = `/workspaces/invitations/{workspace_invitation_id}/accept/`
                .replace(`{${"workspace_invitation_id"}}`, encodeURIComponent(String(workspaceInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new workspace invitations for an email address if the authorized user has admin rights to the related workspace. An email containing a sign up link will be send to the user.
         * @param {number} workspaceId Creates a workspace invitation to the workspace related to the provided value.
         * @param {CreateWorkspaceInvitation} createWorkspaceInvitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceInvitation: (workspaceId_1, createWorkspaceInvitation_1, ...args_1) => __awaiter(this, [workspaceId_1, createWorkspaceInvitation_1, ...args_1], void 0, function* (workspaceId, createWorkspaceInvitation, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceInvitation', 'workspaceId', workspaceId);
            // verify required parameter 'createWorkspaceInvitation' is not null or undefined
            assertParamExists('createWorkspaceInvitation', 'createWorkspaceInvitation', createWorkspaceInvitation);
            const localVarPath = `/workspaces/invitations/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceInvitation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a workspace invitation if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceInvitationId Deletes the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceInvitation: (workspaceInvitationId_1, ...args_1) => __awaiter(this, [workspaceInvitationId_1, ...args_1], void 0, function* (workspaceInvitationId, options = {}) {
            // verify required parameter 'workspaceInvitationId' is not null or undefined
            assertParamExists('deleteWorkspaceInvitation', 'workspaceInvitationId', workspaceInvitationId);
            const localVarPath = `/workspaces/invitations/{workspace_invitation_id}/`
                .replace(`{${"workspace_invitation_id"}}`, encodeURIComponent(String(workspaceInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the requested workspace invitation if the authorized user has admin right to the related workspace
         * @param {number} workspaceInvitationId Returns the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitation: (workspaceInvitationId_1, ...args_1) => __awaiter(this, [workspaceInvitationId_1, ...args_1], void 0, function* (workspaceInvitationId, options = {}) {
            // verify required parameter 'workspaceInvitationId' is not null or undefined
            assertParamExists('getWorkspaceInvitation', 'workspaceInvitationId', workspaceInvitationId);
            const localVarPath = `/workspaces/invitations/{workspace_invitation_id}/`
                .replace(`{${"workspace_invitation_id"}}`, encodeURIComponent(String(workspaceInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Responds with the serialized workspace invitation if an invitation with the provided token is found.
         * @param {string} token Returns the workspace invitation related to the provided token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitationByToken: (token_1, ...args_1) => __awaiter(this, [token_1, ...args_1], void 0, function* (token, options = {}) {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getWorkspaceInvitationByToken', 'token', token);
            const localVarPath = `/workspaces/invitations/token/{token}/`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the workspace invitations of the workspace related to the provided `workspace_id` parameter if the authorized user has admin rights to that workspace.
         * @param {number} workspaceId Returns only invitations that are in the workspace related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceInvitations: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceInvitations', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/invitations/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Rejects a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} workspaceInvitationId Rejects the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWorkspaceInvitation: (workspaceInvitationId_1, ...args_1) => __awaiter(this, [workspaceInvitationId_1, ...args_1], void 0, function* (workspaceInvitationId, options = {}) {
            // verify required parameter 'workspaceInvitationId' is not null or undefined
            assertParamExists('rejectWorkspaceInvitation', 'workspaceInvitationId', workspaceInvitationId);
            const localVarPath = `/workspaces/invitations/{workspace_invitation_id}/reject/`
                .replace(`{${"workspace_invitation_id"}}`, encodeURIComponent(String(workspaceInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing workspace invitation related to the provided `workspace_invitation_id` param if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceInvitationId Updates the workspace invitation related to the provided value.
         * @param {PatchedUpdateWorkspaceInvitation} [patchedUpdateWorkspaceInvitation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceInvitation: (workspaceInvitationId_1, patchedUpdateWorkspaceInvitation_1, ...args_1) => __awaiter(this, [workspaceInvitationId_1, patchedUpdateWorkspaceInvitation_1, ...args_1], void 0, function* (workspaceInvitationId, patchedUpdateWorkspaceInvitation, options = {}) {
            // verify required parameter 'workspaceInvitationId' is not null or undefined
            assertParamExists('updateWorkspaceInvitation', 'workspaceInvitationId', workspaceInvitationId);
            const localVarPath = `/workspaces/invitations/{workspace_invitation_id}/`
                .replace(`{${"workspace_invitation_id"}}`, encodeURIComponent(String(workspaceInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateWorkspaceInvitation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkspaceInvitationsApi - functional programming interface
 * @export
 */
const WorkspaceInvitationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspaceInvitationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Accepts a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} workspaceInvitationId Accepts the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptWorkspaceInvitation(workspaceInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptWorkspaceInvitation(workspaceInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.acceptWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new workspace invitations for an email address if the authorized user has admin rights to the related workspace. An email containing a sign up link will be send to the user.
         * @param {number} workspaceId Creates a workspace invitation to the workspace related to the provided value.
         * @param {CreateWorkspaceInvitation} createWorkspaceInvitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceInvitation(workspaceId, createWorkspaceInvitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWorkspaceInvitation(workspaceId, createWorkspaceInvitation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.createWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a workspace invitation if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceInvitationId Deletes the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceInvitation(workspaceInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWorkspaceInvitation(workspaceInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.deleteWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the requested workspace invitation if the authorized user has admin right to the related workspace
         * @param {number} workspaceInvitationId Returns the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitation(workspaceInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWorkspaceInvitation(workspaceInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.getWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Responds with the serialized workspace invitation if an invitation with the provided token is found.
         * @param {string} token Returns the workspace invitation related to the provided token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitationByToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWorkspaceInvitationByToken(token, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.getWorkspaceInvitationByToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the workspace invitations of the workspace related to the provided `workspace_id` parameter if the authorized user has admin rights to that workspace.
         * @param {number} workspaceId Returns only invitations that are in the workspace related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceInvitations(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkspaceInvitations(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.listWorkspaceInvitations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Rejects a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {number} workspaceInvitationId Rejects the workspace invitation related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWorkspaceInvitation(workspaceInvitationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rejectWorkspaceInvitation(workspaceInvitationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.rejectWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing workspace invitation related to the provided `workspace_invitation_id` param if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceInvitationId Updates the workspace invitation related to the provided value.
         * @param {PatchedUpdateWorkspaceInvitation} [patchedUpdateWorkspaceInvitation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceInvitation(workspaceInvitationId, patchedUpdateWorkspaceInvitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWorkspaceInvitation(workspaceInvitationId, patchedUpdateWorkspaceInvitation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspaceInvitationsApi.updateWorkspaceInvitation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkspaceInvitationsApi - factory interface
 * @export
 */
const WorkspaceInvitationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspaceInvitationsApiFp(configuration);
    return {
        /**
         * Accepts a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {WorkspaceInvitationsApiAcceptWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptWorkspaceInvitation(requestParameters, options) {
            return localVarFp.acceptWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new workspace invitations for an email address if the authorized user has admin rights to the related workspace. An email containing a sign up link will be send to the user.
         * @param {WorkspaceInvitationsApiCreateWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceInvitation(requestParameters, options) {
            return localVarFp.createWorkspaceInvitation(requestParameters.workspaceId, requestParameters.createWorkspaceInvitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a workspace invitation if the authorized user has admin rights to the related workspace.
         * @param {WorkspaceInvitationsApiDeleteWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceInvitation(requestParameters, options) {
            return localVarFp.deleteWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested workspace invitation if the authorized user has admin right to the related workspace
         * @param {WorkspaceInvitationsApiGetWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitation(requestParameters, options) {
            return localVarFp.getWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with the serialized workspace invitation if an invitation with the provided token is found.
         * @param {WorkspaceInvitationsApiGetWorkspaceInvitationByTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceInvitationByToken(requestParameters, options) {
            return localVarFp.getWorkspaceInvitationByToken(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the workspace invitations of the workspace related to the provided `workspace_id` parameter if the authorized user has admin rights to that workspace.
         * @param {WorkspaceInvitationsApiListWorkspaceInvitationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceInvitations(requestParameters, options) {
            return localVarFp.listWorkspaceInvitations(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects a workspace invitation with the given id if the email address of the user matches that of the invitation.
         * @param {WorkspaceInvitationsApiRejectWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWorkspaceInvitation(requestParameters, options) {
            return localVarFp.rejectWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing workspace invitation related to the provided `workspace_invitation_id` param if the authorized user has admin rights to the related workspace.
         * @param {WorkspaceInvitationsApiUpdateWorkspaceInvitationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceInvitation(requestParameters, options) {
            return localVarFp.updateWorkspaceInvitation(requestParameters.workspaceInvitationId, requestParameters.patchedUpdateWorkspaceInvitation, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspaceInvitationsApi - object-oriented interface
 * @export
 * @class WorkspaceInvitationsApi
 * @extends {BaseAPI}
 */
class WorkspaceInvitationsApi extends BaseAPI {
    /**
     * Accepts a workspace invitation with the given id if the email address of the user matches that of the invitation.
     * @param {WorkspaceInvitationsApiAcceptWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    acceptWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).acceptWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new workspace invitations for an email address if the authorized user has admin rights to the related workspace. An email containing a sign up link will be send to the user.
     * @param {WorkspaceInvitationsApiCreateWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    createWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).createWorkspaceInvitation(requestParameters.workspaceId, requestParameters.createWorkspaceInvitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a workspace invitation if the authorized user has admin rights to the related workspace.
     * @param {WorkspaceInvitationsApiDeleteWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    deleteWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).deleteWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the requested workspace invitation if the authorized user has admin right to the related workspace
     * @param {WorkspaceInvitationsApiGetWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    getWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).getWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Responds with the serialized workspace invitation if an invitation with the provided token is found.
     * @param {WorkspaceInvitationsApiGetWorkspaceInvitationByTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    getWorkspaceInvitationByToken(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).getWorkspaceInvitationByToken(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the workspace invitations of the workspace related to the provided `workspace_id` parameter if the authorized user has admin rights to that workspace.
     * @param {WorkspaceInvitationsApiListWorkspaceInvitationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    listWorkspaceInvitations(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).listWorkspaceInvitations(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rejects a workspace invitation with the given id if the email address of the user matches that of the invitation.
     * @param {WorkspaceInvitationsApiRejectWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    rejectWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).rejectWorkspaceInvitation(requestParameters.workspaceInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing workspace invitation related to the provided `workspace_invitation_id` param if the authorized user has admin rights to the related workspace.
     * @param {WorkspaceInvitationsApiUpdateWorkspaceInvitationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceInvitationsApi
     */
    updateWorkspaceInvitation(requestParameters, options) {
        return WorkspaceInvitationsApiFp(this.configuration).updateWorkspaceInvitation(requestParameters.workspaceInvitationId, requestParameters.patchedUpdateWorkspaceInvitation, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
const WorkspacesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates an initial workspace. This is typically called after the user signs up and skips the onboarding in the frontend. It contains some example data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInitialWorkspace: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/workspaces/create-initial-workspace/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new workspace where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {Workspace} workspace
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: (workspace_1, clientSessionId_1, ...args_1) => __awaiter(this, [workspace_1, clientSessionId_1, ...args_1], void 0, function* (workspace, clientSessionId, options = {}) {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspace', 'workspace', workspace);
            const localVarPath = `/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an existing workspace if the authorized user belongs to the workspace. All the applications, databases, tables etc that were in the workspace are going to be deleted also.
         * @param {number} workspaceId Deletes the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: (workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (workspaceId, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a workspace user if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceUserId Deletes the workspace user related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser: (workspaceUserId_1, ...args_1) => __awaiter(this, [workspaceUserId_1, ...args_1], void 0, function* (workspaceUserId, options = {}) {
            // verify required parameter 'workspaceUserId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'workspaceUserId', workspaceUserId);
            const localVarPath = `/workspaces/users/{workspace_user_id}/`
                .replace(`{${"workspace_user_id"}}`, encodeURIComponent(String(workspaceUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the generative AI models settings for the given workspace.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceGenerativeAiModelsSettings: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceGenerativeAiModelsSettings', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/settings/generative-ai/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Makes the authenticated user leave the workspace related to the provided `workspace_id` if the user is in that workspace. If the user is the last admin in the workspace, they will not be able to leave it. There must always be one admin in the workspace, otherwise it will be left without control. If that is the case, they must either delete the workspace or give another member admin permissions first.
         * @param {number} workspaceId Leaves the workspace related to the value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveWorkspace: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('leaveWorkspace', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/leave/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the users that are in a workspace if the authorized user has admin permissions to the related workspace. To add a user to a workspace an invitation must be sent first.
         * @param {number} workspaceId Lists workspace users related to the provided workspace value.
         * @param {string} [search] Search for workspace users by username, or email.
         * @param {string} [sorts] Sort workspace users by name, email or role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers: (workspaceId_1, search_1, sorts_1, ...args_1) => __awaiter(this, [workspaceId_1, search_1, sorts_1, ...args_1], void 0, function* (workspaceId, search, sorts, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceUsers', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/users/workspace/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (sorts !== undefined) {
                localVarQueryParameter['sorts'] = sorts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the workspaces of the authorized user. A workspace can contain multiple applications like a database. Multiple users can have access to a workspace. For example each company could have their own workspace containing databases related to that company. The order of the workspaces are custom for each user. The order is configurable via the **order_workspaces** endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes the order of the provided workspace ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order will be custom for each user.
         * @param {OrderWorkspaces} orderWorkspaces
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderWorkspaces: (orderWorkspaces_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1) => __awaiter(this, [orderWorkspaces_1, clientSessionId_1, clientUndoRedoActionGroupId_1, ...args_1], void 0, function* (orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options = {}) {
            // verify required parameter 'orderWorkspaces' is not null or undefined
            assertParamExists('orderWorkspaces', 'orderWorkspaces', orderWorkspaces);
            const localVarPath = `/workspaces/order/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(orderWorkspaces, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing workspace related to the provided `workspace_id` parameter if the authorized user belongs to the workspace. It is not yet possible to add additional users to a workspace.
         * @param {number} workspaceId Updates the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedWorkspace} [patchedWorkspace]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: (workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedWorkspace_1, ...args_1) => __awaiter(this, [workspaceId_1, clientSessionId_1, clientUndoRedoActionGroupId_1, patchedWorkspace_1, ...args_1], void 0, function* (workspaceId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            if (clientUndoRedoActionGroupId != null) {
                localVarHeaderParameter['ClientUndoRedoActionGroupId'] = String(clientUndoRedoActionGroupId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorkspace, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the generative AI models settings for the given workspace.
         * @param {number} workspaceId Updates the workspace settings for the generative AI models available.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedGenerativeAISettings} [patchedGenerativeAISettings]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceGenerativeAiModelsSettings: (workspaceId_1, clientSessionId_1, patchedGenerativeAISettings_1, ...args_1) => __awaiter(this, [workspaceId_1, clientSessionId_1, patchedGenerativeAISettings_1, ...args_1], void 0, function* (workspaceId, clientSessionId, patchedGenerativeAISettings, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceGenerativeAiModelsSettings', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/settings/generative-ai/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (clientSessionId != null) {
                localVarHeaderParameter['ClientSessionId'] = String(clientSessionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGenerativeAISettings, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the existing workspace user related to the provided `workspace_user_id` param if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceUserId Updates the workspace user related to the provided value.
         * @param {PatchedUpdateWorkspaceUser} [patchedUpdateWorkspaceUser]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser: (workspaceUserId_1, patchedUpdateWorkspaceUser_1, ...args_1) => __awaiter(this, [workspaceUserId_1, patchedUpdateWorkspaceUser_1, ...args_1], void 0, function* (workspaceUserId, patchedUpdateWorkspaceUser, options = {}) {
            // verify required parameter 'workspaceUserId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceUserId', workspaceUserId);
            const localVarPath = `/workspaces/users/{workspace_user_id}/`
                .replace(`{${"workspace_user_id"}}`, encodeURIComponent(String(workspaceUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateWorkspaceUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a the permission data necessary to determine the permissions of a specific user over a specific workspace.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {number} workspaceId The workspace id we want the permission object for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePermissions: (workspaceId_1, ...args_1) => __awaiter(this, [workspaceId_1, ...args_1], void 0, function* (workspaceId, options = {}) {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspacePermissions', 'workspaceId', workspaceId);
            const localVarPath = `/workspaces/{workspace_id}/permissions/`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkspacesApi - functional programming interface
 * @export
 */
const WorkspacesApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates an initial workspace. This is typically called after the user signs up and skips the onboarding in the frontend. It contains some example data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInitialWorkspace(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInitialWorkspace(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.createInitialWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new workspace where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {Workspace} workspace
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(workspace, clientSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWorkspace(workspace, clientSessionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.createWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an existing workspace if the authorized user belongs to the workspace. All the applications, databases, tables etc that were in the workspace are going to be deleted also.
         * @param {number} workspaceId Deletes the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspaceId, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWorkspace(workspaceId, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.deleteWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a workspace user if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceUserId Deletes the workspace user related to the provided value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser(workspaceUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWorkspaceUser(workspaceUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.deleteWorkspaceUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the generative AI models settings for the given workspace.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceGenerativeAiModelsSettings(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWorkspaceGenerativeAiModelsSettings(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.getWorkspaceGenerativeAiModelsSettings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Makes the authenticated user leave the workspace related to the provided `workspace_id` if the user is in that workspace. If the user is the last admin in the workspace, they will not be able to leave it. There must always be one admin in the workspace, otherwise it will be left without control. If that is the case, they must either delete the workspace or give another member admin permissions first.
         * @param {number} workspaceId Leaves the workspace related to the value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveWorkspace(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.leaveWorkspace(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.leaveWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the users that are in a workspace if the authorized user has admin permissions to the related workspace. To add a user to a workspace an invitation must be sent first.
         * @param {number} workspaceId Lists workspace users related to the provided workspace value.
         * @param {string} [search] Search for workspace users by username, or email.
         * @param {string} [sorts] Sort workspace users by name, email or role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers(workspaceId, search, sorts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkspaceUsers(workspaceId, search, sorts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.listWorkspaceUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the workspaces of the authorized user. A workspace can contain multiple applications like a database. Multiple users can have access to a workspace. For example each company could have their own workspace containing databases related to that company. The order of the workspaces are custom for each user. The order is configurable via the **order_workspaces** endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkspaces(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.listWorkspaces']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Changes the order of the provided workspace ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order will be custom for each user.
         * @param {OrderWorkspaces} orderWorkspaces
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderWorkspaces(orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.orderWorkspaces(orderWorkspaces, clientSessionId, clientUndoRedoActionGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.orderWorkspaces']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing workspace related to the provided `workspace_id` parameter if the authorized user belongs to the workspace. It is not yet possible to add additional users to a workspace.
         * @param {number} workspaceId Updates the workspace related to the provided value.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {string} [clientUndoRedoActionGroupId] An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
         * @param {PatchedWorkspace} [patchedWorkspace]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(workspaceId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWorkspace(workspaceId, clientSessionId, clientUndoRedoActionGroupId, patchedWorkspace, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.updateWorkspace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the generative AI models settings for the given workspace.
         * @param {number} workspaceId Updates the workspace settings for the generative AI models available.
         * @param {string} [clientSessionId] An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
         * @param {PatchedGenerativeAISettings} [patchedGenerativeAISettings]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceGenerativeAiModelsSettings(workspaceId, clientSessionId, patchedGenerativeAISettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWorkspaceGenerativeAiModelsSettings(workspaceId, clientSessionId, patchedGenerativeAISettings, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.updateWorkspaceGenerativeAiModelsSettings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the existing workspace user related to the provided `workspace_user_id` param if the authorized user has admin rights to the related workspace.
         * @param {number} workspaceUserId Updates the workspace user related to the provided value.
         * @param {PatchedUpdateWorkspaceUser} [patchedUpdateWorkspaceUser]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser(workspaceUserId, patchedUpdateWorkspaceUser, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWorkspaceUser(workspaceUserId, patchedUpdateWorkspaceUser, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.updateWorkspaceUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a the permission data necessary to determine the permissions of a specific user over a specific workspace.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {number} workspaceId The workspace id we want the permission object for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePermissions(workspaceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.workspacePermissions(workspaceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WorkspacesApi.workspacePermissions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios$1, basePath) => createRequestFunction(localVarAxiosArgs, axios, BASE_PATH, configuration)(axios$1, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkspacesApi - factory interface
 * @export
 */
const WorkspacesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspacesApiFp(configuration);
    return {
        /**
         * Creates an initial workspace. This is typically called after the user signs up and skips the onboarding in the frontend. It contains some example data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInitialWorkspace(options) {
            return localVarFp.createInitialWorkspace(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new workspace where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
         * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(requestParameters, options) {
            return localVarFp.createWorkspace(requestParameters.workspace, requestParameters.clientSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing workspace if the authorized user belongs to the workspace. All the applications, databases, tables etc that were in the workspace are going to be deleted also.
         * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(requestParameters, options) {
            return localVarFp.deleteWorkspace(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a workspace user if the authorized user has admin rights to the related workspace.
         * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser(requestParameters, options) {
            return localVarFp.deleteWorkspaceUser(requestParameters.workspaceUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the generative AI models settings for the given workspace.
         * @param {WorkspacesApiGetWorkspaceGenerativeAiModelsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceGenerativeAiModelsSettings(requestParameters, options) {
            return localVarFp.getWorkspaceGenerativeAiModelsSettings(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes the authenticated user leave the workspace related to the provided `workspace_id` if the user is in that workspace. If the user is the last admin in the workspace, they will not be able to leave it. There must always be one admin in the workspace, otherwise it will be left without control. If that is the case, they must either delete the workspace or give another member admin permissions first.
         * @param {WorkspacesApiLeaveWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveWorkspace(requestParameters, options) {
            return localVarFp.leaveWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the users that are in a workspace if the authorized user has admin permissions to the related workspace. To add a user to a workspace an invitation must be sent first.
         * @param {WorkspacesApiListWorkspaceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers(requestParameters, options) {
            return localVarFp.listWorkspaceUsers(requestParameters.workspaceId, requestParameters.search, requestParameters.sorts, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the workspaces of the authorized user. A workspace can contain multiple applications like a database. Multiple users can have access to a workspace. For example each company could have their own workspace containing databases related to that company. The order of the workspaces are custom for each user. The order is configurable via the **order_workspaces** endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options) {
            return localVarFp.listWorkspaces(options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the order of the provided workspace ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order will be custom for each user.
         * @param {WorkspacesApiOrderWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderWorkspaces(requestParameters, options) {
            return localVarFp.orderWorkspaces(requestParameters.orderWorkspaces, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing workspace related to the provided `workspace_id` parameter if the authorized user belongs to the workspace. It is not yet possible to add additional users to a workspace.
         * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(requestParameters, options) {
            return localVarFp.updateWorkspace(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedWorkspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the generative AI models settings for the given workspace.
         * @param {WorkspacesApiUpdateWorkspaceGenerativeAiModelsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceGenerativeAiModelsSettings(requestParameters, options) {
            return localVarFp.updateWorkspaceGenerativeAiModelsSettings(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.patchedGenerativeAISettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing workspace user related to the provided `workspace_user_id` param if the authorized user has admin rights to the related workspace.
         * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser(requestParameters, options) {
            return localVarFp.updateWorkspaceUser(requestParameters.workspaceUserId, requestParameters.patchedUpdateWorkspaceUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a the permission data necessary to determine the permissions of a specific user over a specific workspace.  See `core.handler.CoreHandler.get_permissions()` for more details.
         * @param {WorkspacesApiWorkspacePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePermissions(requestParameters, options) {
            return localVarFp.workspacePermissions(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
class WorkspacesApi extends BaseAPI {
    /**
     * Creates an initial workspace. This is typically called after the user signs up and skips the onboarding in the frontend. It contains some example data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    createInitialWorkspace(options) {
        return WorkspacesApiFp(this.configuration).createInitialWorkspace(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new workspace where only the authorized user has access to. No initial data like database applications are added, they have to be created via other endpoints.
     * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    createWorkspace(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).createWorkspace(requestParameters.workspace, requestParameters.clientSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an existing workspace if the authorized user belongs to the workspace. All the applications, databases, tables etc that were in the workspace are going to be deleted also.
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    deleteWorkspace(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a workspace user if the authorized user has admin rights to the related workspace.
     * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    deleteWorkspaceUser(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).deleteWorkspaceUser(requestParameters.workspaceUserId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the generative AI models settings for the given workspace.
     * @param {WorkspacesApiGetWorkspaceGenerativeAiModelsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    getWorkspaceGenerativeAiModelsSettings(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).getWorkspaceGenerativeAiModelsSettings(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Makes the authenticated user leave the workspace related to the provided `workspace_id` if the user is in that workspace. If the user is the last admin in the workspace, they will not be able to leave it. There must always be one admin in the workspace, otherwise it will be left without control. If that is the case, they must either delete the workspace or give another member admin permissions first.
     * @param {WorkspacesApiLeaveWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    leaveWorkspace(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).leaveWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the users that are in a workspace if the authorized user has admin permissions to the related workspace. To add a user to a workspace an invitation must be sent first.
     * @param {WorkspacesApiListWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    listWorkspaceUsers(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).listWorkspaceUsers(requestParameters.workspaceId, requestParameters.search, requestParameters.sorts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the workspaces of the authorized user. A workspace can contain multiple applications like a database. Multiple users can have access to a workspace. For example each company could have their own workspace containing databases related to that company. The order of the workspaces are custom for each user. The order is configurable via the **order_workspaces** endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    listWorkspaces(options) {
        return WorkspacesApiFp(this.configuration).listWorkspaces(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the order of the provided workspace ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order will be custom for each user.
     * @param {WorkspacesApiOrderWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    orderWorkspaces(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).orderWorkspaces(requestParameters.orderWorkspaces, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing workspace related to the provided `workspace_id` parameter if the authorized user belongs to the workspace. It is not yet possible to add additional users to a workspace.
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    updateWorkspace(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).updateWorkspace(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.clientUndoRedoActionGroupId, requestParameters.patchedWorkspace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the generative AI models settings for the given workspace.
     * @param {WorkspacesApiUpdateWorkspaceGenerativeAiModelsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    updateWorkspaceGenerativeAiModelsSettings(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceGenerativeAiModelsSettings(requestParameters.workspaceId, requestParameters.clientSessionId, requestParameters.patchedGenerativeAISettings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the existing workspace user related to the provided `workspace_user_id` param if the authorized user has admin rights to the related workspace.
     * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    updateWorkspaceUser(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceUser(requestParameters.workspaceUserId, requestParameters.patchedUpdateWorkspaceUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a the permission data necessary to determine the permissions of a specific user over a specific workspace.  See `core.handler.CoreHandler.get_permissions()` for more details.
     * @param {WorkspacesApiWorkspacePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    workspacePermissions(requestParameters, options) {
        return WorkspacesApiFp(this.configuration).workspacePermissions(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Baserow API spec
 * For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).
 *
 * The version of the OpenAPI document: 1.26.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

export { AcceptGroupInvitation400ResponseErrorEnum, AdminAddUserToLicense400ResponseErrorEnum, AdminAddUserToLicense404ResponseErrorEnum, AdminApi, AdminApiAxiosParamCreator, AdminApiFactory, AdminApiFp, AdminCreateUser400ResponseErrorEnum, AdminDeleteGroup400ResponseErrorEnum, AdminDeleteUser400ResponseErrorEnum, AdminEditUser400ResponseErrorEnum, AdminGetLicense404ResponseErrorEnum, AdminRegisterLicense400ResponseErrorEnum, AdminRemoveUserFromLicense400ResponseErrorEnum, AggregationRawTypeEnum, AlignmentEnum, ApplicationsApi, ApplicationsApiAxiosParamCreator, ApplicationsApiFactory, ApplicationsApiFp, ArrayFormulaTypeEnum, AsyncAuditLogExport400ResponseErrorEnum, AsyncAuditLogExport404ResponseErrorEnum, AuditLogApi, AuditLogApiAxiosParamCreator, AuditLogApiFactory, AuditLogApiFp, AuditLogList400ResponseErrorEnum, AuthApi, AuthApiAxiosParamCreator, AuthApiFactory, AuthApiFp, AuthProviderLoginUrl400ResponseErrorEnum, BatchCreateDatabaseTableRows400ResponseErrorEnum, BatchDeleteDatabaseTableRows400ResponseErrorEnum, BlankEnum, BuilderDataSourcesApi, BuilderDataSourcesApiAxiosParamCreator, BuilderDataSourcesApiFactory, BuilderDataSourcesApiFp, BuilderDomainsApi, BuilderDomainsApiAxiosParamCreator, BuilderDomainsApiFactory, BuilderDomainsApiFp, BuilderElementsApi, BuilderElementsApiAxiosParamCreator, BuilderElementsApiFactory, BuilderElementsApiFp, BuilderPagesApi, BuilderPagesApiAxiosParamCreator, BuilderPagesApiFactory, BuilderPagesApiFp, BuilderPublicApi, BuilderPublicApiAxiosParamCreator, BuilderPublicApiFactory, BuilderPublicApiFp, BuilderThemeApi, BuilderThemeApiAxiosParamCreator, BuilderThemeApiFactory, BuilderThemeApiFp, BuilderWorkflowActionsApi, BuilderWorkflowActionsApiAxiosParamCreator, BuilderWorkflowActionsApiFactory, BuilderWorkflowActionsApiFp, ButtonWidthEnum, CalendarIcalFeed400ResponseErrorEnum, ChangePassword400ResponseErrorEnum, ChangePrimaryField400ResponseErrorEnum, ChangePrimaryField404ResponseErrorEnum, ConditionTypeEnum, Configuration, CreateBuilderPage400ResponseErrorEnum, CreateDatabaseTable400ResponseErrorEnum, CreateDatabaseTableField400ResponseErrorEnum, CreateDatabaseTableRow400ResponseErrorEnum, CreateDatabaseTableRow404ResponseErrorEnum, CreateDatabaseTableViewFilter400ResponseErrorEnum, CreateDatabaseTableViewFilter404ResponseErrorEnum, CreateDatabaseTableViewGroup400ResponseErrorEnum, CreateDatabaseTableViewSort400ResponseErrorEnum, CreateDatabaseTableWebhook400ResponseErrorEnum, CreateRowComment400ResponseErrorEnum, CreateSnapshot400ResponseErrorEnum, CreateSubject400ResponseErrorEnum, CreateSubject404ResponseErrorEnum, CreateUser400ResponseErrorEnum, CreateWorkspaceInvitation400ResponseErrorEnum, CsvColumnSeparatorEnum, DatabaseTableCalendarViewApi, DatabaseTableCalendarViewApiAxiosParamCreator, DatabaseTableCalendarViewApiFactory, DatabaseTableCalendarViewApiFp, DatabaseTableExportApi, DatabaseTableExportApiAxiosParamCreator, DatabaseTableExportApiFactory, DatabaseTableExportApiFp, DatabaseTableFieldsApi, DatabaseTableFieldsApiAxiosParamCreator, DatabaseTableFieldsApiFactory, DatabaseTableFieldsApiFp, DatabaseTableFormViewApi, DatabaseTableFormViewApiAxiosParamCreator, DatabaseTableFormViewApiFactory, DatabaseTableFormViewApiFp, DatabaseTableGalleryViewApi, DatabaseTableGalleryViewApiAxiosParamCreator, DatabaseTableGalleryViewApiFactory, DatabaseTableGalleryViewApiFp, DatabaseTableGridViewApi, DatabaseTableGridViewApiAxiosParamCreator, DatabaseTableGridViewApiFactory, DatabaseTableGridViewApiFp, DatabaseTableKanbanViewApi, DatabaseTableKanbanViewApiAxiosParamCreator, DatabaseTableKanbanViewApiFactory, DatabaseTableKanbanViewApiFp, DatabaseTablePublicViewLinkRowFieldLookup401ResponseErrorEnum, DatabaseTablePublicViewLinkRowFieldLookup404ResponseErrorEnum, DatabaseTableRowsApi, DatabaseTableRowsApiAxiosParamCreator, DatabaseTableRowsApiFactory, DatabaseTableRowsApiFp, DatabaseTableViewDecorationsApi, DatabaseTableViewDecorationsApiAxiosParamCreator, DatabaseTableViewDecorationsApiFactory, DatabaseTableViewDecorationsApiFp, DatabaseTableViewFiltersApi, DatabaseTableViewFiltersApiAxiosParamCreator, DatabaseTableViewFiltersApiFactory, DatabaseTableViewFiltersApiFp, DatabaseTableViewGroupingsApi, DatabaseTableViewGroupingsApiAxiosParamCreator, DatabaseTableViewGroupingsApiFactory, DatabaseTableViewGroupingsApiFp, DatabaseTableViewSortingsApi, DatabaseTableViewSortingsApiAxiosParamCreator, DatabaseTableViewSortingsApiFactory, DatabaseTableViewSortingsApiFp, DatabaseTableViewsApi, DatabaseTableViewsApiAxiosParamCreator, DatabaseTableViewsApiFactory, DatabaseTableViewsApiFp, DatabaseTableWebhooksApi, DatabaseTableWebhooksApiAxiosParamCreator, DatabaseTableWebhooksApiFactory, DatabaseTableWebhooksApiFp, DatabaseTablesApi, DatabaseTablesApiAxiosParamCreator, DatabaseTablesApiFactory, DatabaseTablesApiFp, DatabaseTokensApi, DatabaseTokensApiAxiosParamCreator, DatabaseTokensApiFactory, DatabaseTokensApiFp, DateFormatEnum, DateTimeFormatEnum, DeleteApplication400ResponseErrorEnum, DeleteApplicationIntegration404ResponseErrorEnum, DeleteApplicationUserSource404ResponseErrorEnum, DeleteBuilderDomain404ResponseErrorEnum, DeleteBuilderPageDataSource404ResponseErrorEnum, DeleteBuilderPageElement404ResponseErrorEnum, DeleteBuilderPageWorkflowAction404ResponseErrorEnum, DeleteDatabaseTableField400ResponseErrorEnum, DeleteGroup400ResponseErrorEnum, DeleteRowComment400ResponseErrorEnum, DeleteRowComment404ResponseErrorEnum, DeleteSnapshot400ResponseErrorEnum, DeleteSnapshot404ResponseErrorEnum, DeleteSubject400ResponseErrorEnum, DispatchBuilderPageDataSource404ResponseErrorEnum, DispatchBuilderPageDataSources404ResponseErrorEnum, DispatchBuilderPageWorkflowAction400ResponseErrorEnum, DuplicateApplicationAsync400ResponseErrorEnum, DuplicateTableField400ResponseErrorEnum, DurationFormatEnum, EmailNotificationFrequencyEnum, EmailTester400ResponseErrorEnum, EmailVerificationEnum, EventTypeEnum, EventTypesEnum, Events29bEnum, ExportCharsetEnum, ExportTable400ResponseErrorEnum, ExportTable404ResponseErrorEnum, ExporterTypeEnum, FilterActionTypeEnum, FormatEnum, FormulaTypeEnum, GenerateFormulaWithAi400ResponseErrorEnum, GenerateTableAiFieldValue400ResponseErrorEnum, GenerateTableAiFieldValue404ResponseErrorEnum, GetAdjacentDatabaseTableRow404ResponseErrorEnum, GetAuthProvider404ResponseErrorEnum, GetDatabaseTableField404ResponseErrorEnum, GetDatabaseTableGridViewFieldAggregation400ResponseErrorEnum, GetDatabaseTableGridViewFieldAggregation404ResponseErrorEnum, GetDatabaseTablePublicGridViewFieldAggregations400ResponseErrorEnum, GetDatabaseTablePublicGridViewFieldAggregations404ResponseErrorEnum, GetDatabaseTableViewDecoration404ResponseErrorEnum, GetDatabaseTableViewFieldOptions400ResponseErrorEnum, GetDatabaseTableViewFilter404ResponseErrorEnum, GetDatabaseTableViewFilterGroup404ResponseErrorEnum, GetDatabaseTableViewGroup404ResponseErrorEnum, GetDatabaseTableViewSort404ResponseErrorEnum, GetDatabaseTableWebhook404ResponseErrorEnum, GetDatabaseToken404ResponseErrorEnum, GetExportJob404ResponseErrorEnum, GetGroupInvitation400ResponseErrorEnum, GetGroupInvitation404ResponseErrorEnum, GetGroupInvitationByToken400ResponseErrorEnum, GetJob404ResponseErrorEnum, GetMetaDatabaseTableFormView401ResponseErrorEnum, GetMetaDatabaseTableFormView404ResponseErrorEnum, GetPublicBuilderById404ResponseErrorEnum, GetTeam404ResponseErrorEnum, GroupAssignRole400ResponseErrorEnum, GroupAssignRole404ResponseErrorEnum, GroupBatchAssignRole400ResponseErrorEnum, GroupCreateTeam400ResponseErrorEnum, GroupCreateTeam404ResponseErrorEnum, GroupGetContents400ResponseErrorEnum, GroupInstallTemplate400ResponseErrorEnum, GroupInstallTemplate404ResponseErrorEnum, GroupInstallTemplateAsync400ResponseErrorEnum, GroupInvitationsApi, GroupInvitationsApiAxiosParamCreator, GroupInvitationsApiFactory, GroupInvitationsApiFp, GroupListRoleAssignments404ResponseErrorEnum, GroupOrderApplications400ResponseErrorEnum, GroupPermissions404ResponseErrorEnum, GroupsApi, GroupsApiAxiosParamCreator, GroupsApiFactory, GroupsApiFp, HealthApi, HealthApiAxiosParamCreator, HealthApiFactory, HealthApiFp, IdEnum, ImageConstraintEnum, ImageSourceTypeEnum, InputTypeEnum, IntegrationsApi, IntegrationsApiAxiosParamCreator, IntegrationsApiFactory, IntegrationsApiFp, JobsApi, JobsApiAxiosParamCreator, JobsApiFactory, JobsApiFp, LeaveGroup400ResponseErrorEnum, ListAllApplications400ResponseErrorEnum, ListApplicationIntegrations404ResponseErrorEnum, ListDatabaseTableCalendarViewRows400ResponseErrorEnum, ListDatabaseTableFields401ResponseErrorEnum, ListDatabaseTableFields404ResponseErrorEnum, ListDatabaseTableGalleryViewRows400ResponseErrorEnum, ListDatabaseTableGalleryViewRows404ResponseErrorEnum, ListDatabaseTableKanbanViewRows400ResponseErrorEnum, ListDatabaseTableRows400ResponseErrorEnum, ListDatabaseTableRows404ResponseErrorEnum, ListGroupUsers400ResponseErrorEnum, ListPublicBuilderPageDataSources404ResponseErrorEnum, LocalBaserowPasswordAppAuthProviderBaseAppAuthProviderTypeEnum, MarkNotificationAsRead404ResponseErrorEnum, Mode51eEnum, Mode884Enum, MoveApplicationIntegration400ResponseErrorEnum, MoveApplicationUserSource400ResponseErrorEnum, MoveBuilderPageDataSource400ResponseErrorEnum, MoveBuilderPageElement400ResponseErrorEnum, NavigationTypeEnum, NotificationsApi, NotificationsApiAxiosParamCreator, NotificationsApiFactory, NotificationsApiFp, NullEnum, NumberDecimalPlacesEnum, OptionTypeEnum, OrderBuilderDomains400ResponseErrorEnum, OrderBuilderDomains404ResponseErrorEnum, OrderBuilderPages400ResponseErrorEnum, OrderBuilderPages404ResponseErrorEnum, OrderBuilderWorkflowActions404ResponseErrorEnum, OrderByEnum, OrderDatabaseTableViews400ResponseErrorEnum, OrderDatabaseTables400ResponseErrorEnum, OrderEnum, OrientationEnum, OwnershipTypeEnum, PageBackgroundModeEnum, PathParamTypeEnum, PremiumViewAttributesUpdate400ResponseErrorEnum, PremiumViewAttributesUpdate404ResponseErrorEnum, PublicListDatabaseTableGalleryViewRows400ResponseErrorEnum, PublicListDatabaseTableGalleryViewRows404ResponseErrorEnum, PublicListDatabaseTableGridViewRows400ResponseErrorEnum, PublicListDatabaseTableGridViewRows404ResponseErrorEnum, PublicListDatabaseTableKanbanViewRows400ResponseErrorEnum, PublicListDatabaseTableKanbanViewRows404ResponseErrorEnum, RequestMethodEnum, ResetPassword400ResponseErrorEnum, Restore400ResponseErrorEnum, RoleAssignmentsApi, RoleAssignmentsApiAxiosParamCreator, RoleAssignmentsApiFactory, RoleAssignmentsApiFp, RoleTypeEnum, RotateDatabaseViewSlug400ResponseErrorEnum, RowCommentsNotificationModeEnum, RowIdentifierTypeEnum, ScopeTypeEnum, SecureFileServeApi, SecureFileServeApiAxiosParamCreator, SecureFileServeApiFactory, SecureFileServeApiFp, SecureFileServeDownload403ResponseErrorEnum, SendPasswordResetEmail400ResponseErrorEnum, SettingsApi, SettingsApiAxiosParamCreator, SettingsApiFactory, SettingsApiFp, SnapshotsApi, SnapshotsApiAxiosParamCreator, SnapshotsApiFactory, SnapshotsApiFp, SourceTypeEnum, StateEnum, StyleBackgroundEnum, StyleBackgroundModeEnum, StyleEnum, StyleWidthEnum, SubjectType0b2Enum, SubjectType398Enum, SubmitActionEnum, TableCellAlignmentEnum, TargetEnum, TeamsApi, TeamsApiAxiosParamCreator, TeamsApiFactory, TeamsApiFp, TemplatesApi, TemplatesApiAxiosParamCreator, TemplatesApiFactory, TemplatesApiFp, TokenAuth401ResponseErrorEnum, TokenRefresh401ResponseErrorEnum, TrashApi, TrashApiAxiosParamCreator, TrashApiFactory, TrashApiFp, TrashItemTypeEnum, Type050Enum, Type051Enum, Type083Enum, Type509Enum, Type6ebEnum, Type8b0Enum, Type8b6Enum, Type9c4Enum, TypeB6cEnum, TypeC66Enum, TypeFormulaField400ResponseErrorEnum, UpdateBuilderPage404ResponseErrorEnum, UpdateDatabaseTableField400ResponseErrorEnum, UpdateDatabaseTableView400ResponseErrorEnum, UpdateDatabaseTableViewGroup400ResponseErrorEnum, UpdateDatabaseTableViewSort400ResponseErrorEnum, UpdateDatabaseToken400ResponseErrorEnum, UpdateGroup400ResponseErrorEnum, UpdateGroupInvitation400ResponseErrorEnum, UpdateGroupUser404ResponseErrorEnum, UpdateRowComment400ResponseErrorEnum, UpdateTeam400ResponseErrorEnum, UpdateTeam404ResponseErrorEnum, UploadFile400ResponseErrorEnum, UploadFileFormView400ResponseErrorEnum, UploadViaUrl400ResponseErrorEnum, UserApi, UserApiAxiosParamCreator, UserApiFactory, UserApiFp, UserFilesApi, UserFilesApiAxiosParamCreator, UserFilesApiFactory, UserFilesApiFp, UserSourceRolesApi, UserSourceRolesApiAxiosParamCreator, UserSourceRolesApiFactory, UserSourceRolesApiFp, UserSourcesApi, UserSourcesApiAxiosParamCreator, UserSourcesApiFactory, UserSourcesApiFp, ValidationTypeEnum, ValueProviderTypeEnum, VariantEnum, VerifyEmail400ResponseErrorEnum, VerifyEmail401ResponseErrorEnum, ViewTypesEnum, VisibilityEnum, WorkspaceGetApplication400ResponseErrorEnum, WorkspaceInvitationsApi, WorkspaceInvitationsApiAxiosParamCreator, WorkspaceInvitationsApiFactory, WorkspaceInvitationsApiFp, WorkspacesApi, WorkspacesApiAxiosParamCreator, WorkspacesApiFactory, WorkspacesApiFp };
//# sourceMappingURL=index.esm.js.map
